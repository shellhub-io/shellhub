// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	io "io"
	net "net"

	mock "github.com/stretchr/testify/mock"

	ssh "github.com/gliderlabs/ssh"
)

// Session is an autogenerated mock type for the Session type
type Session struct {
	mock.Mock
}

// Break provides a mock function with given fields: c
func (_m *Session) Break(c chan<- bool) {
	_m.Called(c)
}

// Close provides a mock function with given fields:
func (_m *Session) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloseWrite provides a mock function with given fields:
func (_m *Session) CloseWrite() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Command provides a mock function with given fields:
func (_m *Session) Command() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Context provides a mock function with given fields:
func (_m *Session) Context() ssh.Context {
	ret := _m.Called()

	var r0 ssh.Context
	if rf, ok := ret.Get(0).(func() ssh.Context); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ssh.Context)
		}
	}

	return r0
}

// Environ provides a mock function with given fields:
func (_m *Session) Environ() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Exit provides a mock function with given fields: code
func (_m *Session) Exit(code int) error {
	ret := _m.Called(code)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(code)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LocalAddr provides a mock function with given fields:
func (_m *Session) LocalAddr() net.Addr {
	ret := _m.Called()

	var r0 net.Addr
	if rf, ok := ret.Get(0).(func() net.Addr); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.Addr)
		}
	}

	return r0
}

// Permissions provides a mock function with given fields:
func (_m *Session) Permissions() ssh.Permissions {
	ret := _m.Called()

	var r0 ssh.Permissions
	if rf, ok := ret.Get(0).(func() ssh.Permissions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ssh.Permissions)
	}

	return r0
}

// Pty provides a mock function with given fields:
func (_m *Session) Pty() (ssh.Pty, <-chan ssh.Window, bool) {
	ret := _m.Called()

	var r0 ssh.Pty
	var r1 <-chan ssh.Window
	var r2 bool
	if rf, ok := ret.Get(0).(func() (ssh.Pty, <-chan ssh.Window, bool)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ssh.Pty); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ssh.Pty)
	}

	if rf, ok := ret.Get(1).(func() <-chan ssh.Window); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(<-chan ssh.Window)
		}
	}

	if rf, ok := ret.Get(2).(func() bool); ok {
		r2 = rf()
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// PublicKey provides a mock function with given fields:
func (_m *Session) PublicKey() ssh.PublicKey {
	ret := _m.Called()

	var r0 ssh.PublicKey
	if rf, ok := ret.Get(0).(func() ssh.PublicKey); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ssh.PublicKey)
		}
	}

	return r0
}

// RawCommand provides a mock function with given fields:
func (_m *Session) RawCommand() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Read provides a mock function with given fields: data
func (_m *Session) Read(data []byte) (int, error) {
	ret := _m.Called(data)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoteAddr provides a mock function with given fields:
func (_m *Session) RemoteAddr() net.Addr {
	ret := _m.Called()

	var r0 net.Addr
	if rf, ok := ret.Get(0).(func() net.Addr); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.Addr)
		}
	}

	return r0
}

// SendRequest provides a mock function with given fields: name, wantReply, payload
func (_m *Session) SendRequest(name string, wantReply bool, payload []byte) (bool, error) {
	ret := _m.Called(name, wantReply, payload)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, bool, []byte) (bool, error)); ok {
		return rf(name, wantReply, payload)
	}
	if rf, ok := ret.Get(0).(func(string, bool, []byte) bool); ok {
		r0 = rf(name, wantReply, payload)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, bool, []byte) error); ok {
		r1 = rf(name, wantReply, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Signals provides a mock function with given fields: c
func (_m *Session) Signals(c chan<- ssh.Signal) {
	_m.Called(c)
}

// Stderr provides a mock function with given fields:
func (_m *Session) Stderr() io.ReadWriter {
	ret := _m.Called()

	var r0 io.ReadWriter
	if rf, ok := ret.Get(0).(func() io.ReadWriter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadWriter)
		}
	}

	return r0
}

// Subsystem provides a mock function with given fields:
func (_m *Session) Subsystem() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// User provides a mock function with given fields:
func (_m *Session) User() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Write provides a mock function with given fields: data
func (_m *Session) Write(data []byte) (int, error) {
	ret := _m.Called(data)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewSession interface {
	mock.TestingT
	Cleanup(func())
}

// NewSession creates a new instance of Session. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewSession(t mockConstructorTestingTNewSession) *Session {
	mock := &Session{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
