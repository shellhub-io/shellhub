package storetest

import (
	"context"
	"testing"

	"github.com/shellhub-io/shellhub/api/store"
	"github.com/shellhub-io/shellhub/pkg/api/query"
	"github.com/shellhub-io/shellhub/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestNamespaceList tests the NamespaceList method across all implementations
func (s *Suite) TestNamespaceList(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("empty database returns empty list", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		namespaces, count, err := st.NamespaceList(ctx)
		require.NoError(t, err)
		assert.Empty(t, namespaces)
		assert.Equal(t, 0, count)
	})

	t.Run("returns all namespaces without pagination", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create test namespaces
		s.CreateNamespace(t, WithNamespaceName("namespace-1"))
		s.CreateNamespace(t, WithNamespaceName("namespace-2"))
		s.CreateNamespace(t, WithNamespaceName("namespace-3"))
		s.CreateNamespace(t, WithNamespaceName("namespace-4"))

		// List all
		namespaces, count, err := st.NamespaceList(ctx,
			st.Options().Match(&query.Filters{}),
			st.Options().Paginate(&query.Paginator{Page: -1, PerPage: -1}),
		)

		require.NoError(t, err)
		assert.Equal(t, 4, count)
		assert.Len(t, namespaces, 4)

		// Verify namespace names
		names := []string{}
		for _, ns := range namespaces {
			names = append(names, ns.Name)
		}
		assert.Contains(t, names, "namespace-1")
		assert.Contains(t, names, "namespace-2")
		assert.Contains(t, names, "namespace-3")
		assert.Contains(t, names, "namespace-4")
	})

	t.Run("pagination works correctly - page 1", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create test namespaces
		s.CreateNamespace(t, WithNamespaceName("ns-1"))
		s.CreateNamespace(t, WithNamespaceName("ns-2"))
		s.CreateNamespace(t, WithNamespaceName("ns-3"))
		s.CreateNamespace(t, WithNamespaceName("ns-4"))

		// Get page 1
		namespaces, count, err := st.NamespaceList(ctx,
			st.Options().Match(&query.Filters{}),
			st.Options().Paginate(&query.Paginator{Page: 1, PerPage: 2}),
		)

		require.NoError(t, err)
		assert.Equal(t, 4, count, "total count should be 4")
		assert.Len(t, namespaces, 2, "page should contain 2 items")
	})

	t.Run("pagination works correctly - page 2", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create test namespaces
		s.CreateNamespace(t, WithNamespaceName("ns-1"))
		s.CreateNamespace(t, WithNamespaceName("ns-2"))
		s.CreateNamespace(t, WithNamespaceName("ns-3"))
		s.CreateNamespace(t, WithNamespaceName("ns-4"))

		// Get page 2
		namespaces, count, err := st.NamespaceList(ctx,
			st.Options().Match(&query.Filters{}),
			st.Options().Paginate(&query.Paginator{Page: 2, PerPage: 2}),
		)

		require.NoError(t, err)
		assert.Equal(t, 4, count)
		assert.Len(t, namespaces, 2, "page 2 should contain remaining 2 items")
	})
}

// TestNamespaceResolve tests namespace resolution by different keys
func (s *Suite) TestNamespaceResolve(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("resolve by tenant ID", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create test namespace
		tenantID := s.CreateNamespace(t, WithNamespaceName("namespace-1"))

		// Resolve by tenant ID
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		require.NotNil(t, ns)
		assert.Equal(t, "namespace-1", ns.Name)
		assert.Equal(t, tenantID, ns.TenantID)
	})

	t.Run("resolve by name", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create test namespace
		tenantID := s.CreateNamespace(t, WithNamespaceName("namespace-2"))

		// Resolve by name
		ns, err := st.NamespaceResolve(ctx, store.NamespaceNameResolver, "namespace-2")
		require.NoError(t, err)
		require.NotNil(t, ns)
		assert.Equal(t, "namespace-2", ns.Name)
		assert.Equal(t, tenantID, ns.TenantID)
	})

	t.Run("returns error for non-existent tenant ID", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Use a nil UUID that will never be generated by the system
		nonExistentID := "00000000-0000-0000-0000-000000000000"

		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, nonExistentID)
		assert.ErrorIs(t, err, store.ErrNoDocuments)
		assert.Nil(t, ns)
	})

	t.Run("returns error for non-existent name", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		ns, err := st.NamespaceResolve(ctx, store.NamespaceNameResolver, "non-existent-namespace")
		assert.ErrorIs(t, err, store.ErrNoDocuments)
		assert.Nil(t, ns)
	})
}

// TestNamespaceGetPreferred tests getting user's preferred namespace
func (s *Suite) TestNamespaceGetPreferred(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("returns first namespace for user with memberships", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create user and namespace with membership
		userID := s.CreateUser(t)
		tenantID := s.CreateNamespace(t, WithOwner(userID))
		s.CreateMembership(t, tenantID, userID, "owner")

		// Get preferred namespace
		ns, err := st.NamespaceGetPreferred(ctx, userID)
		require.NoError(t, err)
		require.NotNil(t, ns)
		assert.NotEmpty(t, ns.TenantID)
	})

	t.Run("returns error for user with no namespaces", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create user without any namespaces
		userID := s.CreateUser(t)

		ns, err := st.NamespaceGetPreferred(ctx, userID)
		assert.Error(t, err)
		assert.Nil(t, ns)
	})
}

// TestNamespaceCreate tests namespace creation
func (s *Suite) TestNamespaceCreate(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("creates namespace successfully", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create owner
		userID := s.CreateUser(t)

		// Create namespace
		namespace := &models.Namespace{
			Name:       "test-namespace",
			Owner:      userID,
			MaxDevices: -1,
			Settings:   &models.NamespaceSettings{SessionRecord: true},
		}

		tenantID, err := st.NamespaceCreate(ctx, namespace)
		require.NoError(t, err)
		assert.NotEmpty(t, tenantID)

		// Verify it was created
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		assert.Equal(t, "test-namespace", ns.Name)
		assert.Equal(t, -1, ns.MaxDevices)
		assert.True(t, ns.Settings.SessionRecord)
	})
}

// TestNamespaceConflicts tests checking for namespace conflicts
func (s *Suite) TestNamespaceConflicts(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("detects name conflict", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create namespace
		s.CreateNamespace(t, WithNamespaceName("namespace-1"))

		// Check for conflict with same name
		conflicts, has, err := st.NamespaceConflicts(ctx, &models.NamespaceConflicts{
			Name: "namespace-1",
		})

		require.NoError(t, err)
		assert.True(t, has)
		assert.Len(t, conflicts, 1)
	})

	t.Run("no conflict with unique name", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create namespace
		s.CreateNamespace(t, WithNamespaceName("namespace-1"))

		// Check with different name
		conflicts, has, err := st.NamespaceConflicts(ctx, &models.NamespaceConflicts{
			Name: "unique-namespace",
		})

		require.NoError(t, err)
		assert.False(t, has)
		assert.Empty(t, conflicts)
	})
}

// TestNamespaceUpdate tests namespace updates
func (s *Suite) TestNamespaceUpdate(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("updates namespace successfully", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create namespace
		tenantID := s.CreateNamespace(t, WithNamespaceName("original-name"))

		// Get and update it
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)

		originalName := ns.Name
		ns.Name = "updated-namespace"
		ns.MaxDevices = 100
		err = st.NamespaceUpdate(ctx, ns)
		require.NoError(t, err)

		// Verify update
		updated, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		assert.Equal(t, "updated-namespace", updated.Name)
		assert.NotEqual(t, originalName, updated.Name)
		assert.Equal(t, 100, updated.MaxDevices)
	})

	t.Run("fails for non-existent namespace", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Use a nil UUID that will never be generated by the system
		nonExistentID := "00000000-0000-0000-0000-000000000000"

		nonExistent := &models.Namespace{
			TenantID: nonExistentID,
			Name:     "test",
		}
		err := st.NamespaceUpdate(ctx, nonExistent)
		assert.ErrorIs(t, err, store.ErrNoDocuments)
	})
}

// TestNamespaceIncrementDeviceCount tests atomic device counter updates
func (s *Suite) TestNamespaceIncrementDeviceCount(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("increments and decrements device count", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create namespace
		tenantID := s.CreateNamespace(t)

		// Get initial counts
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		initialAccepted := ns.DevicesAcceptedCount
		initialPending := ns.DevicesPendingCount

		// Increment accepted count
		err = st.NamespaceIncrementDeviceCount(ctx, tenantID, models.DeviceStatusAccepted, 5)
		require.NoError(t, err)

		// Verify increment
		ns, err = st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		assert.Equal(t, initialAccepted+5, ns.DevicesAcceptedCount)
		assert.Equal(t, initialPending, ns.DevicesPendingCount, "other counters should not change")

		// Decrement
		err = st.NamespaceIncrementDeviceCount(ctx, tenantID, models.DeviceStatusAccepted, -3)
		require.NoError(t, err)

		// Verify decrement
		ns, err = st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)
		assert.Equal(t, initialAccepted+2, ns.DevicesAcceptedCount)
	})

	t.Run("fails for non-existent namespace", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Use a nil UUID that will never be generated by the system
		nonExistentID := "00000000-0000-0000-0000-000000000000"

		err := st.NamespaceIncrementDeviceCount(ctx, nonExistentID, models.DeviceStatusAccepted, 1)
		assert.ErrorIs(t, err, store.ErrNoDocuments)
	})
}

// TestNamespaceDelete tests namespace deletion
func (s *Suite) TestNamespaceDelete(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("deletes namespace successfully", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create namespace
		tenantID := s.CreateNamespace(t)

		// Get namespace to delete
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		require.NoError(t, err)

		// Delete it
		err = st.NamespaceDelete(ctx, ns)
		require.NoError(t, err)

		// Verify deletion
		_, err = st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
		assert.ErrorIs(t, err, store.ErrNoDocuments)
	})
}

// TestNamespaceDeleteMany tests bulk namespace deletion
func (s *Suite) TestNamespaceDeleteMany(t *testing.T) {
	ctx := context.Background()
	st := s.provider.Store()

	t.Run("deletes multiple namespaces", func(t *testing.T) {
		require.NoError(t, s.provider.CleanDatabase(t))

		// Create multiple namespaces
		tenant1 := s.CreateNamespace(t, WithNamespaceName("ns-1"))
		tenant2 := s.CreateNamespace(t, WithNamespaceName("ns-2"))
		tenant3 := s.CreateNamespace(t, WithNamespaceName("ns-3"))

		// Delete first two
		tenantIDs := []string{tenant1, tenant2}
		deleted, err := st.NamespaceDeleteMany(ctx, tenantIDs)
		require.NoError(t, err)
		assert.Equal(t, int64(2), deleted)

		// Verify deletions
		for _, tenantID := range tenantIDs {
			_, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenantID)
			assert.ErrorIs(t, err, store.ErrNoDocuments)
		}

		// Verify remaining namespace still exists
		ns, err := st.NamespaceResolve(ctx, store.NamespaceTenantIDResolver, tenant3)
		require.NoError(t, err)
		assert.Equal(t, "ns-3", ns.Name)
	})
}
