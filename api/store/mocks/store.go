// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/shellhub-io/shellhub/pkg/models"
	mock "github.com/stretchr/testify/mock"

	store "github.com/shellhub-io/shellhub/api/store"

	time "time"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// APIKeyConflicts provides a mock function with given fields: ctx, tenantID, target
func (_m *Store) APIKeyConflicts(ctx context.Context, tenantID string, target *models.APIKeyConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, tenantID, target)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.APIKeyConflicts) ([]string, bool, error)); ok {
		return rf(ctx, tenantID, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.APIKeyConflicts) []string); ok {
		r0 = rf(ctx, tenantID, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *models.APIKeyConflicts) bool); ok {
		r1 = rf(ctx, tenantID, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *models.APIKeyConflicts) error); ok {
		r2 = rf(ctx, tenantID, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// APIKeyCreate provides a mock function with given fields: ctx, APIKey
func (_m *Store) APIKeyCreate(ctx context.Context, APIKey *models.APIKey) (string, error) {
	ret := _m.Called(ctx, APIKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) (string, error)); ok {
		return rf(ctx, APIKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) string); ok {
		r0 = rf(ctx, APIKey)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.APIKey) error); ok {
		r1 = rf(ctx, APIKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIKeyDelete provides a mock function with given fields: ctx, apiKey
func (_m *Store) APIKeyDelete(ctx context.Context, apiKey *models.APIKey) error {
	ret := _m.Called(ctx, apiKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) error); ok {
		r0 = rf(ctx, apiKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// APIKeyList provides a mock function with given fields: ctx, opts
func (_m *Store) APIKeyList(ctx context.Context, opts ...store.QueryOption) ([]models.APIKey, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyList")
	}

	var r0 []models.APIKey
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.APIKey, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.APIKey); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.APIKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// APIKeyResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) APIKeyResolve(ctx context.Context, resolver store.APIKeyResolver, value string, opts ...store.QueryOption) (*models.APIKey, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyResolve")
	}

	var r0 *models.APIKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) (*models.APIKey, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) *models.APIKey); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.APIKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIKeyUpdate provides a mock function with given fields: ctx, apiKey
func (_m *Store) APIKeyUpdate(ctx context.Context, apiKey *models.APIKey) error {
	ret := _m.Called(ctx, apiKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) error); ok {
		r0 = rf(ctx, apiKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ActiveSessionCreate provides a mock function with given fields: ctx, session
func (_m *Store) ActiveSessionCreate(ctx context.Context, session *models.Session) error {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for ActiveSessionCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Session) error); ok {
		r0 = rf(ctx, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ActiveSessionDelete provides a mock function with given fields: ctx, uid
func (_m *Store) ActiveSessionDelete(ctx context.Context, uid models.UID) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for ActiveSessionDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ActiveSessionResolve provides a mock function with given fields: ctx, resolver, value
func (_m *Store) ActiveSessionResolve(ctx context.Context, resolver store.SessionResolver, value string) (*models.ActiveSession, error) {
	ret := _m.Called(ctx, resolver, value)

	if len(ret) == 0 {
		panic("no return value specified for ActiveSessionResolve")
	}

	var r0 *models.ActiveSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.SessionResolver, string) (*models.ActiveSession, error)); ok {
		return rf(ctx, resolver, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.SessionResolver, string) *models.ActiveSession); ok {
		r0 = rf(ctx, resolver, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ActiveSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.SessionResolver, string) error); ok {
		r1 = rf(ctx, resolver, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ActiveSessionUpdate provides a mock function with given fields: ctx, activeSession
func (_m *Store) ActiveSessionUpdate(ctx context.Context, activeSession *models.ActiveSession) error {
	ret := _m.Called(ctx, activeSession)

	if len(ret) == 0 {
		panic("no return value specified for ActiveSessionUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ActiveSession) error); ok {
		r0 = rf(ctx, activeSession)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceConflicts provides a mock function with given fields: ctx, target
func (_m *Store) DeviceConflicts(ctx context.Context, target *models.DeviceConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for DeviceConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.DeviceConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.DeviceConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.DeviceConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.DeviceConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeviceCreate provides a mock function with given fields: ctx, device
func (_m *Store) DeviceCreate(ctx context.Context, device *models.Device) (string, error) {
	ret := _m.Called(ctx, device)

	if len(ret) == 0 {
		panic("no return value specified for DeviceCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) (string, error)); ok {
		return rf(ctx, device)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) string); ok {
		r0 = rf(ctx, device)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Device) error); ok {
		r1 = rf(ctx, device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceDelete provides a mock function with given fields: ctx, device
func (_m *Store) DeviceDelete(ctx context.Context, device *models.Device) error {
	ret := _m.Called(ctx, device)

	if len(ret) == 0 {
		panic("no return value specified for DeviceDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) error); ok {
		r0 = rf(ctx, device)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceDeleteMany provides a mock function with given fields: ctx, uids
func (_m *Store) DeviceDeleteMany(ctx context.Context, uids []string) (int64, error) {
	ret := _m.Called(ctx, uids)

	if len(ret) == 0 {
		panic("no return value specified for DeviceDeleteMany")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int64, error)); ok {
		return rf(ctx, uids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int64); ok {
		r0 = rf(ctx, uids)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, uids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceHeartbeat provides a mock function with given fields: ctx, uids, lastSeen
func (_m *Store) DeviceHeartbeat(ctx context.Context, uids []string, lastSeen time.Time) (int64, error) {
	ret := _m.Called(ctx, uids, lastSeen)

	if len(ret) == 0 {
		panic("no return value specified for DeviceHeartbeat")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, time.Time) (int64, error)); ok {
		return rf(ctx, uids, lastSeen)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, time.Time) int64); ok {
		r0 = rf(ctx, uids, lastSeen)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, time.Time) error); ok {
		r1 = rf(ctx, uids, lastSeen)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceList provides a mock function with given fields: ctx, acceptable, opts
func (_m *Store) DeviceList(ctx context.Context, acceptable store.DeviceAcceptable, opts ...store.QueryOption) ([]models.Device, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, acceptable)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeviceList")
	}

	var r0 []models.Device
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) ([]models.Device, int, error)); ok {
		return rf(ctx, acceptable, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) []models.Device); ok {
		r0 = rf(ctx, acceptable, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) int); ok {
		r1 = rf(ctx, acceptable, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) error); ok {
		r2 = rf(ctx, acceptable, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeviceResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) DeviceResolve(ctx context.Context, resolver store.DeviceResolver, value string, opts ...store.QueryOption) (*models.Device, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeviceResolve")
	}

	var r0 *models.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) (*models.Device, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) *models.Device); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceUpdate provides a mock function with given fields: ctx, device
func (_m *Store) DeviceUpdate(ctx context.Context, device *models.Device) error {
	ret := _m.Called(ctx, device)

	if len(ret) == 0 {
		panic("no return value specified for DeviceUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) error); ok {
		r0 = rf(ctx, device)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetStats provides a mock function with given fields: ctx, tenantID
func (_m *Store) GetStats(ctx context.Context, tenantID string) (*models.Stats, error) {
	ret := _m.Called(ctx, tenantID)

	if len(ret) == 0 {
		panic("no return value specified for GetStats")
	}

	var r0 *models.Stats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Stats, error)); ok {
		return rf(ctx, tenantID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Stats); ok {
		r0 = rf(ctx, tenantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Stats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, tenantID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MembershipInvitationCreate provides a mock function with given fields: ctx, invitation
func (_m *Store) MembershipInvitationCreate(ctx context.Context, invitation *models.MembershipInvitation) error {
	ret := _m.Called(ctx, invitation)

	if len(ret) == 0 {
		panic("no return value specified for MembershipInvitationCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.MembershipInvitation) error); ok {
		r0 = rf(ctx, invitation)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MembershipInvitationResolve provides a mock function with given fields: ctx, tenantID, userID
func (_m *Store) MembershipInvitationResolve(ctx context.Context, tenantID string, userID string) (*models.MembershipInvitation, error) {
	ret := _m.Called(ctx, tenantID, userID)

	if len(ret) == 0 {
		panic("no return value specified for MembershipInvitationResolve")
	}

	var r0 *models.MembershipInvitation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.MembershipInvitation, error)); ok {
		return rf(ctx, tenantID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.MembershipInvitation); ok {
		r0 = rf(ctx, tenantID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.MembershipInvitation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MembershipInvitationUpdate provides a mock function with given fields: ctx, invitation
func (_m *Store) MembershipInvitationUpdate(ctx context.Context, invitation *models.MembershipInvitation) error {
	ret := _m.Called(ctx, invitation)

	if len(ret) == 0 {
		panic("no return value specified for MembershipInvitationUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.MembershipInvitation) error); ok {
		r0 = rf(ctx, invitation)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceConflicts provides a mock function with given fields: ctx, target
func (_m *Store) NamespaceConflicts(ctx context.Context, target *models.NamespaceConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.NamespaceConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.NamespaceConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.NamespaceConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.NamespaceConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NamespaceCreate provides a mock function with given fields: ctx, namespace
func (_m *Store) NamespaceCreate(ctx context.Context, namespace *models.Namespace) (string, error) {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) (string, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) string); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Namespace) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceCreateMembership provides a mock function with given fields: ctx, tenantID, member
func (_m *Store) NamespaceCreateMembership(ctx context.Context, tenantID string, member *models.Member) error {
	ret := _m.Called(ctx, tenantID, member)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceCreateMembership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.Member) error); ok {
		r0 = rf(ctx, tenantID, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceDelete provides a mock function with given fields: ctx, namespace
func (_m *Store) NamespaceDelete(ctx context.Context, namespace *models.Namespace) error {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceDeleteMany provides a mock function with given fields: ctx, tenantIDs
func (_m *Store) NamespaceDeleteMany(ctx context.Context, tenantIDs []string) (int64, error) {
	ret := _m.Called(ctx, tenantIDs)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceDeleteMany")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int64, error)); ok {
		return rf(ctx, tenantIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int64); ok {
		r0 = rf(ctx, tenantIDs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, tenantIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceDeleteMembership provides a mock function with given fields: ctx, tenantID, member
func (_m *Store) NamespaceDeleteMembership(ctx context.Context, tenantID string, member *models.Member) error {
	ret := _m.Called(ctx, tenantID, member)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceDeleteMembership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.Member) error); ok {
		r0 = rf(ctx, tenantID, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceGetPreferred provides a mock function with given fields: ctx, userID
func (_m *Store) NamespaceGetPreferred(ctx context.Context, userID string) (*models.Namespace, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceGetPreferred")
	}

	var r0 *models.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Namespace, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Namespace); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceIncrementDeviceCount provides a mock function with given fields: ctx, tenantID, status, count
func (_m *Store) NamespaceIncrementDeviceCount(ctx context.Context, tenantID string, status models.DeviceStatus, count int64) error {
	ret := _m.Called(ctx, tenantID, status, count)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceIncrementDeviceCount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, models.DeviceStatus, int64) error); ok {
		r0 = rf(ctx, tenantID, status, count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceList provides a mock function with given fields: ctx, opts
func (_m *Store) NamespaceList(ctx context.Context, opts ...store.QueryOption) ([]models.Namespace, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceList")
	}

	var r0 []models.Namespace
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Namespace, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Namespace); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NamespaceResolve provides a mock function with given fields: ctx, resolver, value
func (_m *Store) NamespaceResolve(ctx context.Context, resolver store.NamespaceResolver, value string) (*models.Namespace, error) {
	ret := _m.Called(ctx, resolver, value)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceResolve")
	}

	var r0 *models.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.NamespaceResolver, string) (*models.Namespace, error)); ok {
		return rf(ctx, resolver, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.NamespaceResolver, string) *models.Namespace); ok {
		r0 = rf(ctx, resolver, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.NamespaceResolver, string) error); ok {
		r1 = rf(ctx, resolver, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceSyncDeviceCounts provides a mock function with given fields: ctx
func (_m *Store) NamespaceSyncDeviceCounts(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceSyncDeviceCounts")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceUpdate provides a mock function with given fields: ctx, namespace
func (_m *Store) NamespaceUpdate(ctx context.Context, namespace *models.Namespace) error {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceUpdateMembership provides a mock function with given fields: ctx, tenantID, member
func (_m *Store) NamespaceUpdateMembership(ctx context.Context, tenantID string, member *models.Member) error {
	ret := _m.Called(ctx, tenantID, member)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceUpdateMembership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.Member) error); ok {
		r0 = rf(ctx, tenantID, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Options provides a mock function with no fields
func (_m *Store) Options() store.QueryOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 store.QueryOptions
	if rf, ok := ret.Get(0).(func() store.QueryOptions); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(store.QueryOptions)
		}
	}

	return r0
}

// PrivateKeyCreate provides a mock function with given fields: ctx, key
func (_m *Store) PrivateKeyCreate(ctx context.Context, key *models.PrivateKey) error {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PrivateKeyCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PrivateKey) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PrivateKeyGet provides a mock function with given fields: ctx, fingerprint
func (_m *Store) PrivateKeyGet(ctx context.Context, fingerprint string) (*models.PrivateKey, error) {
	ret := _m.Called(ctx, fingerprint)

	if len(ret) == 0 {
		panic("no return value specified for PrivateKeyGet")
	}

	var r0 *models.PrivateKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.PrivateKey, error)); ok {
		return rf(ctx, fingerprint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.PrivateKey); ok {
		r0 = rf(ctx, fingerprint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PrivateKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fingerprint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublicKeyCreate provides a mock function with given fields: ctx, key
func (_m *Store) PublicKeyCreate(ctx context.Context, key *models.PublicKey) (string, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PublicKey) (string, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.PublicKey) string); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.PublicKey) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublicKeyDelete provides a mock function with given fields: ctx, publicKey
func (_m *Store) PublicKeyDelete(ctx context.Context, publicKey *models.PublicKey) error {
	ret := _m.Called(ctx, publicKey)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PublicKey) error); ok {
		r0 = rf(ctx, publicKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PublicKeyList provides a mock function with given fields: ctx, opts
func (_m *Store) PublicKeyList(ctx context.Context, opts ...store.QueryOption) ([]models.PublicKey, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyList")
	}

	var r0 []models.PublicKey
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.PublicKey, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.PublicKey); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PublicKeyResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) PublicKeyResolve(ctx context.Context, resolver store.PublicKeyResolver, value string, opts ...store.QueryOption) (*models.PublicKey, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyResolve")
	}

	var r0 *models.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.PublicKeyResolver, string, ...store.QueryOption) (*models.PublicKey, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.PublicKeyResolver, string, ...store.QueryOption) *models.PublicKey); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.PublicKeyResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublicKeyUpdate provides a mock function with given fields: ctx, publicKey
func (_m *Store) PublicKeyUpdate(ctx context.Context, publicKey *models.PublicKey) error {
	ret := _m.Called(ctx, publicKey)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PublicKey) error); ok {
		r0 = rf(ctx, publicKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionCreate provides a mock function with given fields: ctx, session
func (_m *Store) SessionCreate(ctx context.Context, session models.Session) (string, error) {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for SessionCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.Session) (string, error)); ok {
		return rf(ctx, session)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.Session) string); ok {
		r0 = rf(ctx, session)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.Session) error); ok {
		r1 = rf(ctx, session)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionEventsCreate provides a mock function with given fields: ctx, event
func (_m *Store) SessionEventsCreate(ctx context.Context, event *models.SessionEvent) error {
	ret := _m.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for SessionEventsCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.SessionEvent) error); ok {
		r0 = rf(ctx, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionEventsDelete provides a mock function with given fields: ctx, uid, seat, event
func (_m *Store) SessionEventsDelete(ctx context.Context, uid models.UID, seat int, event models.SessionEventType) error {
	ret := _m.Called(ctx, uid, seat, event)

	if len(ret) == 0 {
		panic("no return value specified for SessionEventsDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType) error); ok {
		r0 = rf(ctx, uid, seat, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionEventsList provides a mock function with given fields: ctx, uid, seat, event, opts
func (_m *Store) SessionEventsList(ctx context.Context, uid models.UID, seat int, event models.SessionEventType, opts ...store.QueryOption) ([]models.SessionEvent, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, uid, seat, event)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionEventsList")
	}

	var r0 []models.SessionEvent
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) ([]models.SessionEvent, int, error)); ok {
		return rf(ctx, uid, seat, event, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) []models.SessionEvent); ok {
		r0 = rf(ctx, uid, seat, event, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SessionEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) int); ok {
		r1 = rf(ctx, uid, seat, event, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) error); ok {
		r2 = rf(ctx, uid, seat, event, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SessionList provides a mock function with given fields: ctx, opts
func (_m *Store) SessionList(ctx context.Context, opts ...store.QueryOption) ([]models.Session, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionList")
	}

	var r0 []models.Session
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Session, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Session); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SessionResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) SessionResolve(ctx context.Context, resolver store.SessionResolver, value string, opts ...store.QueryOption) (*models.Session, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionResolve")
	}

	var r0 *models.Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.SessionResolver, string, ...store.QueryOption) (*models.Session, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.SessionResolver, string, ...store.QueryOption) *models.Session); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.SessionResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionUpdate provides a mock function with given fields: ctx, session
func (_m *Store) SessionUpdate(ctx context.Context, session *models.Session) error {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for SessionUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Session) error); ok {
		r0 = rf(ctx, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionUpdateDeviceUID provides a mock function with given fields: ctx, oldUID, newUID
func (_m *Store) SessionUpdateDeviceUID(ctx context.Context, oldUID models.UID, newUID models.UID) error {
	ret := _m.Called(ctx, oldUID, newUID)

	if len(ret) == 0 {
		panic("no return value specified for SessionUpdateDeviceUID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, models.UID) error); ok {
		r0 = rf(ctx, oldUID, newUID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SystemGet provides a mock function with given fields: ctx
func (_m *Store) SystemGet(ctx context.Context) (*models.System, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SystemGet")
	}

	var r0 *models.System
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*models.System, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *models.System); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.System)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemSet provides a mock function with given fields: ctx, system
func (_m *Store) SystemSet(ctx context.Context, system *models.System) error {
	ret := _m.Called(ctx, system)

	if len(ret) == 0 {
		panic("no return value specified for SystemSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.System) error); ok {
		r0 = rf(ctx, system)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagConflicts provides a mock function with given fields: ctx, tenantID, target
func (_m *Store) TagConflicts(ctx context.Context, tenantID string, target *models.TagConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, tenantID, target)

	if len(ret) == 0 {
		panic("no return value specified for TagConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.TagConflicts) ([]string, bool, error)); ok {
		return rf(ctx, tenantID, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.TagConflicts) []string); ok {
		r0 = rf(ctx, tenantID, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *models.TagConflicts) bool); ok {
		r1 = rf(ctx, tenantID, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *models.TagConflicts) error); ok {
		r2 = rf(ctx, tenantID, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TagCreate provides a mock function with given fields: ctx, tag
func (_m *Store) TagCreate(ctx context.Context, tag *models.Tag) (string, error) {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for TagCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) (string, error)); ok {
		return rf(ctx, tag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) string); ok {
		r0 = rf(ctx, tag)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Tag) error); ok {
		r1 = rf(ctx, tag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagDelete provides a mock function with given fields: ctx, tag
func (_m *Store) TagDelete(ctx context.Context, tag *models.Tag) error {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for TagDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) error); ok {
		r0 = rf(ctx, tag)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagList provides a mock function with given fields: ctx, opts
func (_m *Store) TagList(ctx context.Context, opts ...store.QueryOption) ([]models.Tag, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagList")
	}

	var r0 []models.Tag
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Tag, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Tag); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TagPullFromTarget provides a mock function with given fields: ctx, id, target, targetIDs
func (_m *Store) TagPullFromTarget(ctx context.Context, id string, target store.TagTarget, targetIDs ...string) error {
	_va := make([]interface{}, len(targetIDs))
	for _i := range targetIDs {
		_va[_i] = targetIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, target)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagPullFromTarget")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, store.TagTarget, ...string) error); ok {
		r0 = rf(ctx, id, target, targetIDs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagPushToTarget provides a mock function with given fields: ctx, id, target, targetID
func (_m *Store) TagPushToTarget(ctx context.Context, id string, target store.TagTarget, targetID string) error {
	ret := _m.Called(ctx, id, target, targetID)

	if len(ret) == 0 {
		panic("no return value specified for TagPushToTarget")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, store.TagTarget, string) error); ok {
		r0 = rf(ctx, id, target, targetID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) TagResolve(ctx context.Context, resolver store.TagResolver, value string, opts ...store.QueryOption) (*models.Tag, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResolve")
	}

	var r0 *models.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.TagResolver, string, ...store.QueryOption) (*models.Tag, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.TagResolver, string, ...store.QueryOption) *models.Tag); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.TagResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagUpdate provides a mock function with given fields: ctx, tag
func (_m *Store) TagUpdate(ctx context.Context, tag *models.Tag) error {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for TagUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) error); ok {
		r0 = rf(ctx, tag)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserConflicts provides a mock function with given fields: ctx, target
func (_m *Store) UserConflicts(ctx context.Context, target *models.UserConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for UserConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.UserConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.UserConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.UserConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.UserConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UserCreate provides a mock function with given fields: ctx, user
func (_m *Store) UserCreate(ctx context.Context, user *models.User) (string, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UserCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) (string, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) string); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserDelete provides a mock function with given fields: ctx, user
func (_m *Store) UserDelete(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UserDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserGetInfo provides a mock function with given fields: ctx, id
func (_m *Store) UserGetInfo(ctx context.Context, id string) (*models.UserInfo, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for UserGetInfo")
	}

	var r0 *models.UserInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.UserInfo, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.UserInfo); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.UserInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserInvitationsUpsert provides a mock function with given fields: ctx, email
func (_m *Store) UserInvitationsUpsert(ctx context.Context, email string) (string, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for UserInvitationsUpsert")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, email)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserList provides a mock function with given fields: ctx, opts
func (_m *Store) UserList(ctx context.Context, opts ...store.QueryOption) ([]models.User, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserList")
	}

	var r0 []models.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.User, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.User); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UserResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) UserResolve(ctx context.Context, resolver store.UserResolver, value string, opts ...store.QueryOption) (*models.User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserResolve")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.UserResolver, string, ...store.QueryOption) (*models.User, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.UserResolver, string, ...store.QueryOption) *models.User); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.UserResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserUpdate provides a mock function with given fields: ctx, user
func (_m *Store) UserUpdate(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithTransaction provides a mock function with given fields: ctx, cb
func (_m *Store) WithTransaction(ctx context.Context, cb store.TransactionCb) error {
	ret := _m.Called(ctx, cb)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, store.TransactionCb) error); ok {
		r0 = rf(ctx, cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
