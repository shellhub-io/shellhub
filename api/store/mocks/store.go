// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/shellhub-io/shellhub/pkg/models"
	mock "github.com/stretchr/testify/mock"

	store "github.com/shellhub-io/shellhub/api/store"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// APIKeyConflicts provides a mock function with given fields: ctx, tenantID, target
func (_m *Store) APIKeyConflicts(ctx context.Context, tenantID string, target *models.APIKeyConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, tenantID, target)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.APIKeyConflicts) ([]string, bool, error)); ok {
		return rf(ctx, tenantID, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.APIKeyConflicts) []string); ok {
		r0 = rf(ctx, tenantID, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *models.APIKeyConflicts) bool); ok {
		r1 = rf(ctx, tenantID, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *models.APIKeyConflicts) error); ok {
		r2 = rf(ctx, tenantID, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// APIKeyCreate provides a mock function with given fields: ctx, APIKey
func (_m *Store) APIKeyCreate(ctx context.Context, APIKey *models.APIKey) (string, error) {
	ret := _m.Called(ctx, APIKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) (string, error)); ok {
		return rf(ctx, APIKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) string); ok {
		r0 = rf(ctx, APIKey)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.APIKey) error); ok {
		r1 = rf(ctx, APIKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIKeyDelete provides a mock function with given fields: ctx, apiKey
func (_m *Store) APIKeyDelete(ctx context.Context, apiKey *models.APIKey) error {
	ret := _m.Called(ctx, apiKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) error); ok {
		r0 = rf(ctx, apiKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// APIKeyList provides a mock function with given fields: ctx, opts
func (_m *Store) APIKeyList(ctx context.Context, opts ...store.QueryOption) ([]models.APIKey, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyList")
	}

	var r0 []models.APIKey
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.APIKey, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.APIKey); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.APIKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// APIKeyResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) APIKeyResolve(ctx context.Context, resolver store.APIKeyResolver, value string, opts ...store.QueryOption) (*models.APIKey, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyResolve")
	}

	var r0 *models.APIKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) (*models.APIKey, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) *models.APIKey); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.APIKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.APIKeyResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIKeyUpdate provides a mock function with given fields: ctx, apiKey
func (_m *Store) APIKeyUpdate(ctx context.Context, apiKey *models.APIKey) error {
	ret := _m.Called(ctx, apiKey)

	if len(ret) == 0 {
		panic("no return value specified for APIKeyUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.APIKey) error); ok {
		r0 = rf(ctx, apiKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceBulkUpdate provides a mock function with given fields: ctx, uids, changes
func (_m *Store) DeviceBulkUpdate(ctx context.Context, uids []string, changes *models.DeviceChanges) (int64, error) {
	ret := _m.Called(ctx, uids, changes)

	if len(ret) == 0 {
		panic("no return value specified for DeviceBulkUpdate")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *models.DeviceChanges) (int64, error)); ok {
		return rf(ctx, uids, changes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *models.DeviceChanges) int64); ok {
		r0 = rf(ctx, uids, changes)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *models.DeviceChanges) error); ok {
		r1 = rf(ctx, uids, changes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceConflicts provides a mock function with given fields: ctx, target
func (_m *Store) DeviceConflicts(ctx context.Context, target *models.DeviceConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for DeviceConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.DeviceConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.DeviceConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.DeviceConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.DeviceConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeviceCreate provides a mock function with given fields: ctx, device
func (_m *Store) DeviceCreate(ctx context.Context, device *models.Device) (string, error) {
	ret := _m.Called(ctx, device)

	if len(ret) == 0 {
		panic("no return value specified for DeviceCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) (string, error)); ok {
		return rf(ctx, device)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Device) string); ok {
		r0 = rf(ctx, device)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Device) error); ok {
		r1 = rf(ctx, device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceDelete provides a mock function with given fields: ctx, uid
func (_m *Store) DeviceDelete(ctx context.Context, uid models.UID) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for DeviceDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceList provides a mock function with given fields: ctx, acceptable, opts
func (_m *Store) DeviceList(ctx context.Context, acceptable store.DeviceAcceptable, opts ...store.QueryOption) ([]models.Device, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, acceptable)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeviceList")
	}

	var r0 []models.Device
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) ([]models.Device, int, error)); ok {
		return rf(ctx, acceptable, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) []models.Device); ok {
		r0 = rf(ctx, acceptable, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) int); ok {
		r1 = rf(ctx, acceptable, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, store.DeviceAcceptable, ...store.QueryOption) error); ok {
		r2 = rf(ctx, acceptable, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeviceResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) DeviceResolve(ctx context.Context, resolver store.DeviceResolver, value string, opts ...store.QueryOption) (*models.Device, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeviceResolve")
	}

	var r0 *models.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) (*models.Device, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) *models.Device); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.DeviceResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceUpdate provides a mock function with given fields: ctx, tenant, uid, changes
func (_m *Store) DeviceUpdate(ctx context.Context, tenant string, uid string, changes *models.DeviceChanges) error {
	ret := _m.Called(ctx, tenant, uid, changes)

	if len(ret) == 0 {
		panic("no return value specified for DeviceUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *models.DeviceChanges) error); ok {
		r0 = rf(ctx, tenant, uid, changes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetStats provides a mock function with given fields: ctx
func (_m *Store) GetStats(ctx context.Context) (*models.Stats, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetStats")
	}

	var r0 *models.Stats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*models.Stats, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *models.Stats); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Stats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceAddMember provides a mock function with given fields: ctx, tenantID, member
func (_m *Store) NamespaceAddMember(ctx context.Context, tenantID string, member *models.Member) error {
	ret := _m.Called(ctx, tenantID, member)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceAddMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.Member) error); ok {
		r0 = rf(ctx, tenantID, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceConflicts provides a mock function with given fields: ctx, target
func (_m *Store) NamespaceConflicts(ctx context.Context, target *models.NamespaceConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.NamespaceConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.NamespaceConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.NamespaceConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.NamespaceConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NamespaceCreate provides a mock function with given fields: ctx, namespace
func (_m *Store) NamespaceCreate(ctx context.Context, namespace *models.Namespace) (*models.Namespace, error) {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceCreate")
	}

	var r0 *models.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) (*models.Namespace, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Namespace) *models.Namespace); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Namespace) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceDelete provides a mock function with given fields: ctx, tenantID
func (_m *Store) NamespaceDelete(ctx context.Context, tenantID string) error {
	ret := _m.Called(ctx, tenantID)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, tenantID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceGetPreferred provides a mock function with given fields: ctx, userID
func (_m *Store) NamespaceGetPreferred(ctx context.Context, userID string) (*models.Namespace, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceGetPreferred")
	}

	var r0 *models.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Namespace, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Namespace); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceIncrementDeviceCount provides a mock function with given fields: ctx, tenantID, status, count
func (_m *Store) NamespaceIncrementDeviceCount(ctx context.Context, tenantID string, status models.DeviceStatus, count int64) error {
	ret := _m.Called(ctx, tenantID, status, count)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceIncrementDeviceCount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, models.DeviceStatus, int64) error); ok {
		r0 = rf(ctx, tenantID, status, count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceList provides a mock function with given fields: ctx, opts
func (_m *Store) NamespaceList(ctx context.Context, opts ...store.QueryOption) ([]models.Namespace, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceList")
	}

	var r0 []models.Namespace
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Namespace, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Namespace); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NamespaceRemoveMember provides a mock function with given fields: ctx, tenantID, memberID
func (_m *Store) NamespaceRemoveMember(ctx context.Context, tenantID string, memberID string) error {
	ret := _m.Called(ctx, tenantID, memberID)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceRemoveMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, tenantID, memberID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceResolve provides a mock function with given fields: ctx, resolver, value
func (_m *Store) NamespaceResolve(ctx context.Context, resolver store.NamespaceResolver, value string) (*models.Namespace, error) {
	ret := _m.Called(ctx, resolver, value)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceResolve")
	}

	var r0 *models.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.NamespaceResolver, string) (*models.Namespace, error)); ok {
		return rf(ctx, resolver, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.NamespaceResolver, string) *models.Namespace); ok {
		r0 = rf(ctx, resolver, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.NamespaceResolver, string) error); ok {
		r1 = rf(ctx, resolver, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NamespaceUpdate provides a mock function with given fields: ctx, tenant, changes
func (_m *Store) NamespaceUpdate(ctx context.Context, tenant string, changes *models.NamespaceChanges) error {
	ret := _m.Called(ctx, tenant, changes)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.NamespaceChanges) error); ok {
		r0 = rf(ctx, tenant, changes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NamespaceUpdateMember provides a mock function with given fields: ctx, tenantID, memberID, changes
func (_m *Store) NamespaceUpdateMember(ctx context.Context, tenantID string, memberID string, changes *models.MemberChanges) error {
	ret := _m.Called(ctx, tenantID, memberID, changes)

	if len(ret) == 0 {
		panic("no return value specified for NamespaceUpdateMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *models.MemberChanges) error); ok {
		r0 = rf(ctx, tenantID, memberID, changes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Options provides a mock function with no fields
func (_m *Store) Options() store.QueryOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 store.QueryOptions
	if rf, ok := ret.Get(0).(func() store.QueryOptions); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(store.QueryOptions)
		}
	}

	return r0
}

// PrivateKeyCreate provides a mock function with given fields: ctx, key
func (_m *Store) PrivateKeyCreate(ctx context.Context, key *models.PrivateKey) error {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PrivateKeyCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PrivateKey) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PrivateKeyGet provides a mock function with given fields: ctx, fingerprint
func (_m *Store) PrivateKeyGet(ctx context.Context, fingerprint string) (*models.PrivateKey, error) {
	ret := _m.Called(ctx, fingerprint)

	if len(ret) == 0 {
		panic("no return value specified for PrivateKeyGet")
	}

	var r0 *models.PrivateKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.PrivateKey, error)); ok {
		return rf(ctx, fingerprint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.PrivateKey); ok {
		r0 = rf(ctx, fingerprint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PrivateKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fingerprint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublicKeyCreate provides a mock function with given fields: ctx, key
func (_m *Store) PublicKeyCreate(ctx context.Context, key *models.PublicKey) error {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PublicKey) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PublicKeyDelete provides a mock function with given fields: ctx, fingerprint, tenantID
func (_m *Store) PublicKeyDelete(ctx context.Context, fingerprint string, tenantID string) error {
	ret := _m.Called(ctx, fingerprint, tenantID)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, fingerprint, tenantID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PublicKeyGet provides a mock function with given fields: ctx, fingerprint, tenantID
func (_m *Store) PublicKeyGet(ctx context.Context, fingerprint string, tenantID string) (*models.PublicKey, error) {
	ret := _m.Called(ctx, fingerprint, tenantID)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyGet")
	}

	var r0 *models.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.PublicKey, error)); ok {
		return rf(ctx, fingerprint, tenantID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.PublicKey); ok {
		r0 = rf(ctx, fingerprint, tenantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, fingerprint, tenantID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PublicKeyList provides a mock function with given fields: ctx, opts
func (_m *Store) PublicKeyList(ctx context.Context, opts ...store.QueryOption) ([]models.PublicKey, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyList")
	}

	var r0 []models.PublicKey
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.PublicKey, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.PublicKey); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PublicKeyUpdate provides a mock function with given fields: ctx, fingerprint, tenantID, key
func (_m *Store) PublicKeyUpdate(ctx context.Context, fingerprint string, tenantID string, key *models.PublicKeyUpdate) (*models.PublicKey, error) {
	ret := _m.Called(ctx, fingerprint, tenantID, key)

	if len(ret) == 0 {
		panic("no return value specified for PublicKeyUpdate")
	}

	var r0 *models.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *models.PublicKeyUpdate) (*models.PublicKey, error)); ok {
		return rf(ctx, fingerprint, tenantID, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *models.PublicKeyUpdate) *models.PublicKey); ok {
		r0 = rf(ctx, fingerprint, tenantID, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *models.PublicKeyUpdate) error); ok {
		r1 = rf(ctx, fingerprint, tenantID, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionCreate provides a mock function with given fields: ctx, session
func (_m *Store) SessionCreate(ctx context.Context, session models.Session) (*models.Session, error) {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for SessionCreate")
	}

	var r0 *models.Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.Session) (*models.Session, error)); ok {
		return rf(ctx, session)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.Session) *models.Session); ok {
		r0 = rf(ctx, session)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.Session) error); ok {
		r1 = rf(ctx, session)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionCreateActive provides a mock function with given fields: ctx, uid, session
func (_m *Store) SessionCreateActive(ctx context.Context, uid models.UID, session *models.Session) error {
	ret := _m.Called(ctx, uid, session)

	if len(ret) == 0 {
		panic("no return value specified for SessionCreateActive")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, *models.Session) error); ok {
		r0 = rf(ctx, uid, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionDeleteActives provides a mock function with given fields: ctx, uid
func (_m *Store) SessionDeleteActives(ctx context.Context, uid models.UID) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for SessionDeleteActives")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionDeleteEvents provides a mock function with given fields: ctx, uid, seat, event
func (_m *Store) SessionDeleteEvents(ctx context.Context, uid models.UID, seat int, event models.SessionEventType) error {
	ret := _m.Called(ctx, uid, seat, event)

	if len(ret) == 0 {
		panic("no return value specified for SessionDeleteEvents")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType) error); ok {
		r0 = rf(ctx, uid, seat, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionEvent provides a mock function with given fields: ctx, uid, event
func (_m *Store) SessionEvent(ctx context.Context, uid models.UID, event *models.SessionEvent) error {
	ret := _m.Called(ctx, uid, event)

	if len(ret) == 0 {
		panic("no return value specified for SessionEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, *models.SessionEvent) error); ok {
		r0 = rf(ctx, uid, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionGet provides a mock function with given fields: ctx, uid
func (_m *Store) SessionGet(ctx context.Context, uid models.UID) (*models.Session, error) {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for SessionGet")
	}

	var r0 *models.Session
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) (*models.Session, error)); ok {
		return rf(ctx, uid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) *models.Session); ok {
		r0 = rf(ctx, uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UID) error); ok {
		r1 = rf(ctx, uid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionList provides a mock function with given fields: ctx, opts
func (_m *Store) SessionList(ctx context.Context, opts ...store.QueryOption) ([]models.Session, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionList")
	}

	var r0 []models.Session
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Session, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Session); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Session)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SessionListEvents provides a mock function with given fields: ctx, uid, seat, event, opts
func (_m *Store) SessionListEvents(ctx context.Context, uid models.UID, seat int, event models.SessionEventType, opts ...store.QueryOption) ([]models.SessionEvent, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, uid, seat, event)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SessionListEvents")
	}

	var r0 []models.SessionEvent
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) ([]models.SessionEvent, int, error)); ok {
		return rf(ctx, uid, seat, event, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) []models.SessionEvent); ok {
		r0 = rf(ctx, uid, seat, event, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SessionEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) int); ok {
		r1 = rf(ctx, uid, seat, event, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, models.UID, int, models.SessionEventType, ...store.QueryOption) error); ok {
		r2 = rf(ctx, uid, seat, event, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SessionSetLastSeen provides a mock function with given fields: ctx, uid
func (_m *Store) SessionSetLastSeen(ctx context.Context, uid models.UID) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for SessionSetLastSeen")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionSetRecorded provides a mock function with given fields: ctx, uid, recorded
func (_m *Store) SessionSetRecorded(ctx context.Context, uid models.UID, recorded bool) error {
	ret := _m.Called(ctx, uid, recorded)

	if len(ret) == 0 {
		panic("no return value specified for SessionSetRecorded")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, bool) error); ok {
		r0 = rf(ctx, uid, recorded)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionSetType provides a mock function with given fields: ctx, uid, kind
func (_m *Store) SessionSetType(ctx context.Context, uid models.UID, kind string) error {
	ret := _m.Called(ctx, uid, kind)

	if len(ret) == 0 {
		panic("no return value specified for SessionSetType")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, string) error); ok {
		r0 = rf(ctx, uid, kind)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionUpdate provides a mock function with given fields: ctx, uid, sess, update
func (_m *Store) SessionUpdate(ctx context.Context, uid models.UID, sess *models.Session, update *models.SessionUpdate) error {
	ret := _m.Called(ctx, uid, sess, update)

	if len(ret) == 0 {
		panic("no return value specified for SessionUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, *models.Session, *models.SessionUpdate) error); ok {
		r0 = rf(ctx, uid, sess, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SessionUpdateDeviceUID provides a mock function with given fields: ctx, oldUID, newUID
func (_m *Store) SessionUpdateDeviceUID(ctx context.Context, oldUID models.UID, newUID models.UID) error {
	ret := _m.Called(ctx, oldUID, newUID)

	if len(ret) == 0 {
		panic("no return value specified for SessionUpdateDeviceUID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UID, models.UID) error); ok {
		r0 = rf(ctx, oldUID, newUID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SystemGet provides a mock function with given fields: ctx
func (_m *Store) SystemGet(ctx context.Context) (*models.System, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SystemGet")
	}

	var r0 *models.System
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*models.System, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *models.System); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.System)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemSet provides a mock function with given fields: ctx, key, value
func (_m *Store) SystemSet(ctx context.Context, key string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SystemSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagConflicts provides a mock function with given fields: ctx, tenantID, target
func (_m *Store) TagConflicts(ctx context.Context, tenantID string, target *models.TagConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, tenantID, target)

	if len(ret) == 0 {
		panic("no return value specified for TagConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.TagConflicts) ([]string, bool, error)); ok {
		return rf(ctx, tenantID, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.TagConflicts) []string); ok {
		r0 = rf(ctx, tenantID, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *models.TagConflicts) bool); ok {
		r1 = rf(ctx, tenantID, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *models.TagConflicts) error); ok {
		r2 = rf(ctx, tenantID, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TagCreate provides a mock function with given fields: ctx, tag
func (_m *Store) TagCreate(ctx context.Context, tag *models.Tag) (string, error) {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for TagCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) (string, error)); ok {
		return rf(ctx, tag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Tag) string); ok {
		r0 = rf(ctx, tag)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Tag) error); ok {
		r1 = rf(ctx, tag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagDelete provides a mock function with given fields: ctx, id
func (_m *Store) TagDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for TagDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagList provides a mock function with given fields: ctx, opts
func (_m *Store) TagList(ctx context.Context, opts ...store.QueryOption) ([]models.Tag, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagList")
	}

	var r0 []models.Tag
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.Tag, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.Tag); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TagPullFromTarget provides a mock function with given fields: ctx, id, target, targetIDs
func (_m *Store) TagPullFromTarget(ctx context.Context, id string, target store.TagTarget, targetIDs ...string) error {
	_va := make([]interface{}, len(targetIDs))
	for _i := range targetIDs {
		_va[_i] = targetIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, target)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagPullFromTarget")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, store.TagTarget, ...string) error); ok {
		r0 = rf(ctx, id, target, targetIDs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagPushToTarget provides a mock function with given fields: ctx, id, target, targetID
func (_m *Store) TagPushToTarget(ctx context.Context, id string, target store.TagTarget, targetID string) error {
	ret := _m.Called(ctx, id, target, targetID)

	if len(ret) == 0 {
		panic("no return value specified for TagPushToTarget")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, store.TagTarget, string) error); ok {
		r0 = rf(ctx, id, target, targetID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TagResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) TagResolve(ctx context.Context, resolver store.TagResolver, value string, opts ...store.QueryOption) (*models.Tag, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResolve")
	}

	var r0 *models.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.TagResolver, string, ...store.QueryOption) (*models.Tag, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.TagResolver, string, ...store.QueryOption) *models.Tag); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.TagResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagUpdate provides a mock function with given fields: ctx, id, changes
func (_m *Store) TagUpdate(ctx context.Context, id string, changes *models.TagChanges) error {
	ret := _m.Called(ctx, id, changes)

	if len(ret) == 0 {
		panic("no return value specified for TagUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.TagChanges) error); ok {
		r0 = rf(ctx, id, changes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TunnelUpdateDeviceUID provides a mock function with given fields: ctx, tenantID, oldUID, newUID
func (_m *Store) TunnelUpdateDeviceUID(ctx context.Context, tenantID string, oldUID string, newUID string) error {
	ret := _m.Called(ctx, tenantID, oldUID, newUID)

	if len(ret) == 0 {
		panic("no return value specified for TunnelUpdateDeviceUID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, tenantID, oldUID, newUID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserConflicts provides a mock function with given fields: ctx, target
func (_m *Store) UserConflicts(ctx context.Context, target *models.UserConflicts) ([]string, bool, error) {
	ret := _m.Called(ctx, target)

	if len(ret) == 0 {
		panic("no return value specified for UserConflicts")
	}

	var r0 []string
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.UserConflicts) ([]string, bool, error)); ok {
		return rf(ctx, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.UserConflicts) []string); ok {
		r0 = rf(ctx, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.UserConflicts) bool); ok {
		r1 = rf(ctx, target)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *models.UserConflicts) error); ok {
		r2 = rf(ctx, target)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UserCreate provides a mock function with given fields: ctx, user
func (_m *Store) UserCreate(ctx context.Context, user *models.User) (string, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UserCreate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) (string, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) string); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserCreateInvited provides a mock function with given fields: ctx, email
func (_m *Store) UserCreateInvited(ctx context.Context, email string) (string, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for UserCreateInvited")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, email)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserDelete provides a mock function with given fields: ctx, id
func (_m *Store) UserDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for UserDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserGetInfo provides a mock function with given fields: ctx, id
func (_m *Store) UserGetInfo(ctx context.Context, id string) (*models.UserInfo, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for UserGetInfo")
	}

	var r0 *models.UserInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.UserInfo, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.UserInfo); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.UserInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserList provides a mock function with given fields: ctx, opts
func (_m *Store) UserList(ctx context.Context, opts ...store.QueryOption) ([]models.User, int, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserList")
	}

	var r0 []models.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) ([]models.User, int, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...store.QueryOption) []models.User); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...store.QueryOption) int); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, ...store.QueryOption) error); ok {
		r2 = rf(ctx, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UserResolve provides a mock function with given fields: ctx, resolver, value, opts
func (_m *Store) UserResolve(ctx context.Context, resolver store.UserResolver, value string, opts ...store.QueryOption) (*models.User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resolver, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserResolve")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, store.UserResolver, string, ...store.QueryOption) (*models.User, error)); ok {
		return rf(ctx, resolver, value, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, store.UserResolver, string, ...store.QueryOption) *models.User); ok {
		r0 = rf(ctx, resolver, value, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, store.UserResolver, string, ...store.QueryOption) error); ok {
		r1 = rf(ctx, resolver, value, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserUpdate provides a mock function with given fields: ctx, id, changes
func (_m *Store) UserUpdate(ctx context.Context, id string, changes *models.UserChanges) error {
	ret := _m.Called(ctx, id, changes)

	if len(ret) == 0 {
		panic("no return value specified for UserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.UserChanges) error); ok {
		r0 = rf(ctx, id, changes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithTransaction provides a mock function with given fields: ctx, cb
func (_m *Store) WithTransaction(ctx context.Context, cb store.TransactionCb) error {
	ret := _m.Called(ctx, cb)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, store.TransactionCb) error); ok {
		r0 = rf(ctx, cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
