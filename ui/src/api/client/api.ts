/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub Cloud OpenAPI
 * > NOTICE: THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR.  ShellHub Cloud OpenAPI specification.  It documents all routes provided by ShellHub Cloud. 
 *
 * The version of the OpenAPI document: 0.18.0
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * The unique key included in the email link.
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    'sig': string;
}
/**
 * 
 * @export
 * @interface AddTagPublicKeyRequest
 */
export interface AddTagPublicKeyRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof AddTagPublicKeyRequest
     */
    'tag': string;
}
/**
 * Announcement.
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof Announcement
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof Announcement
     */
    'title'?: string;
    /**
     * Announcement description.
     * @type {string}
     * @memberof Announcement
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface AnnouncementShort
 */
export interface AnnouncementShort {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementShort
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * The tenant ID of the namespace with which the key is associated.
     * @type {string}
     * @memberof ApiKey
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     * @type {string}
     * @memberof ApiKey
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     * @type {string}
     * @memberof ApiKey
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKey
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     * @type {number}
     * @memberof ApiKey
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     * @type {string}
     * @memberof ApiKey
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyCreate
 */
export interface ApiKeyCreate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'name': string;
    /**
     * Number of days until expiration. Use -1 for no expiration.
     * @type {number}
     * @memberof ApiKeyCreate
     */
    'expires_at': ApiKeyCreateExpiresAtEnum;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. Leave it blank to use the user\'s role. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'role'?: string;
    /**
     * An optional and unique value to be used as the API key\'s internal identifier. This value is the \"internal ID\" and will NEVER be returned to the client. Leave it blank for a random one to be generated. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'key'?: string;
}

export const ApiKeyCreateExpiresAtEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_30: 30,
    NUMBER_60: 60,
    NUMBER_90: 90,
    NUMBER_365: 365
} as const;

export type ApiKeyCreateExpiresAtEnum = typeof ApiKeyCreateExpiresAtEnum[keyof typeof ApiKeyCreateExpiresAtEnum];

/**
 * 
 * @export
 * @interface ApiKeyUpdate
 */
export interface ApiKeyUpdate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyUpdate
     */
    'name'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. 
     * @type {string}
     * @memberof ApiKeyUpdate
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyWithID
 */
export interface ApiKeyWithID {
    /**
     * The UUID of the API key. It is used only internally and, except for the create operation, is never returned to the client. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'id'?: string;
    /**
     * The tenant ID of the namespace with which the key is associated.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     * @type {number}
     * @memberof ApiKeyWithID
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface AttachPaymentMethodRequest
 */
export interface AttachPaymentMethodRequest {
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof AttachPaymentMethodRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AuthDevice200Response
 */
export interface AuthDevice200Response {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'uid'?: string;
    /**
     * Device\'s token
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'token'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'name'?: string;
    /**
     * Device\'s namespace name
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface AuthDeviceRequest
 */
export interface AuthDeviceRequest {
    /**
     * 
     * @type {DeviceInfo}
     * @memberof AuthDeviceRequest
     */
    'info': DeviceInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthDeviceRequest
     */
    'sessions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'hostname': string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof AuthDeviceRequest
     */
    'identity'?: DeviceIdentity;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'public_key': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'tenant_id': string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKey200Response
 */
export interface AuthSSHPublicKey200Response {
    /**
     * Device\'s signature.
     * @type {string}
     * @memberof AuthSSHPublicKey200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKeyRequest
 */
export interface AuthSSHPublicKeyRequest {
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'fingerprint': string;
    /**
     * Public key\'s data.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ChoiceDevicesRequest
 */
export interface ChoiceDevicesRequest {
    /**
     * Device\'s list.
     * @type {Array<string>}
     * @memberof ChoiceDevicesRequest
     */
    'choices': Array<string>;
}
/**
 * 
 * @export
 * @interface ClsoeSession500Response
 */
export interface ClsoeSession500Response {
    /**
     * Error message.
     * @type {string}
     * @memberof ClsoeSession500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ClsoeSessionRequest
 */
export interface ClsoeSessionRequest {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof ClsoeSessionRequest
     */
    'device': string;
}
/**
 * 
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * Connector\'s UID
     * @type {string}
     * @memberof Connector
     */
    'uid'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Connector
     */
    'tenant_id'?: string;
    /**
     * Connector\'s connection is enabled.
     * @type {boolean}
     * @memberof Connector
     */
    'enable'?: boolean;
    /**
     * Address to the Container Engine.
     * @type {string}
     * @memberof Connector
     */
    'address'?: string;
    /**
     * Port to the Container Engine.
     * @type {number}
     * @memberof Connector
     */
    'port'?: number;
    /**
     * onnector\'s connection is using HTTPS for authentication.
     * @type {boolean}
     * @memberof Connector
     */
    'secure'?: boolean;
    /**
     * 
     * @type {ConnectorStatus}
     * @memberof Connector
     */
    'status'?: ConnectorStatus;
    /**
     * 
     * @type {ConnectorTLS}
     * @memberof Connector
     */
    'tls'?: ConnectorTLS;
}
/**
 * 
 * @export
 * @interface ConnectorData
 */
export interface ConnectorData {
    /**
     * Connector\'s connection is enabled.
     * @type {boolean}
     * @memberof ConnectorData
     */
    'enable'?: boolean;
    /**
     * Address to the Container Engine.
     * @type {string}
     * @memberof ConnectorData
     */
    'address'?: string;
    /**
     * Port to the Container Engine.
     * @type {number}
     * @memberof ConnectorData
     */
    'port'?: number;
    /**
     * onnector\'s connection is using HTTPS for authentication.
     * @type {boolean}
     * @memberof ConnectorData
     */
    'secure'?: boolean;
    /**
     * 
     * @type {ConnectorTLS}
     * @memberof ConnectorData
     */
    'tls'?: ConnectorTLS;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200Response
 */
export interface ConnectorInfo200Response {
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'ID'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'Containers'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'ContainersRunning'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'ContainersPaused'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'ContainersStopped'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'Images'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'Driver'?: string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof ConnectorInfo200Response
     */
    'DriverStatus'?: Array<Array<string>>;
    /**
     * 
     * @type {ConnectorInfo200ResponsePlugins}
     * @memberof ConnectorInfo200Response
     */
    'Plugins'?: ConnectorInfo200ResponsePlugins;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'MemoryLimit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'SwapLimit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'CpuCfsPeriod'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'CpuCfsQuota'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'CPUShares'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'CPUSet'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'PidsLimit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'IPv4Forwarding'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'BridgeNfIptables'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'BridgeNfIp6tables'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'Debug'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'NFd'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'OomKillDisable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'NGoroutines'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'SystemTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'LoggingDriver'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'CgroupDriver'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'CgroupVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'NEventsListener'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'KernelVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'OperatingSystem'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'OSVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'OSType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'Architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'IndexServerAddress'?: string;
    /**
     * 
     * @type {ConnectorInfo200ResponseRegistryConfig}
     * @memberof ConnectorInfo200Response
     */
    'RegistryConfig'?: ConnectorInfo200ResponseRegistryConfig;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'NCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorInfo200Response
     */
    'MemTotal'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200Response
     */
    'GenericResources'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'DockerRootDir'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'HttpProxy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'HttpsProxy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'NoProxy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'Name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200Response
     */
    'Labels'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'ExperimentalBuild'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'ServerVersion'?: string;
    /**
     * 
     * @type {ConnectorInfo200ResponseRuntimes}
     * @memberof ConnectorInfo200Response
     */
    'Runtimes'?: ConnectorInfo200ResponseRuntimes;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'DefaultRuntime'?: string;
    /**
     * 
     * @type {ConnectorInfo200ResponseSwarm}
     * @memberof ConnectorInfo200Response
     */
    'Swarm'?: ConnectorInfo200ResponseSwarm;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200Response
     */
    'LiveRestoreEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'Isolation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200Response
     */
    'InitBinary'?: string;
    /**
     * 
     * @type {ConnectorInfo200ResponseContainerdCommit}
     * @memberof ConnectorInfo200Response
     */
    'ContainerdCommit'?: ConnectorInfo200ResponseContainerdCommit;
    /**
     * 
     * @type {ConnectorInfo200ResponseContainerdCommit}
     * @memberof ConnectorInfo200Response
     */
    'RuncCommit'?: ConnectorInfo200ResponseContainerdCommit;
    /**
     * 
     * @type {ConnectorInfo200ResponseContainerdCommit}
     * @memberof ConnectorInfo200Response
     */
    'InitCommit'?: ConnectorInfo200ResponseContainerdCommit;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200Response
     */
    'SecurityOptions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200Response
     */
    'CDISpecDirs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200Response
     */
    'Warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseContainerdCommit
 */
export interface ConnectorInfo200ResponseContainerdCommit {
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseContainerdCommit
     */
    'ID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseContainerdCommit
     */
    'Expected'?: string;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponsePlugins
 */
export interface ConnectorInfo200ResponsePlugins {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponsePlugins
     */
    'Volume'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponsePlugins
     */
    'Network'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponsePlugins
     */
    'Authorization'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponsePlugins
     */
    'Log'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseRegistryConfig
 */
export interface ConnectorInfo200ResponseRegistryConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseRegistryConfig
     */
    'AllowNondistributableArtifactsCIDRs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseRegistryConfig
     */
    'AllowNondistributableArtifactsHostnames'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseRegistryConfig
     */
    'InsecureRegistryCIDRs'?: Array<string>;
    /**
     * 
     * @type {ConnectorInfo200ResponseRegistryConfigIndexConfigs}
     * @memberof ConnectorInfo200ResponseRegistryConfig
     */
    'IndexConfigs'?: ConnectorInfo200ResponseRegistryConfigIndexConfigs;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseRegistryConfig
     */
    'Mirrors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseRegistryConfigIndexConfigs
 */
export interface ConnectorInfo200ResponseRegistryConfigIndexConfigs {
    /**
     * 
     * @type {ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo}
     * @memberof ConnectorInfo200ResponseRegistryConfigIndexConfigs
     */
    'docker.io'?: ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo
 */
export interface ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo {
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo
     */
    'Name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo
     */
    'Mirrors'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo
     */
    'Secure'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo
     */
    'Official'?: boolean;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseRuntimes
 */
export interface ConnectorInfo200ResponseRuntimes {
    /**
     * 
     * @type {ConnectorInfo200ResponseRuntimesIoContainerdRuncV2}
     * @memberof ConnectorInfo200ResponseRuntimes
     */
    'io.containerd.runc.v2'?: ConnectorInfo200ResponseRuntimesIoContainerdRuncV2;
    /**
     * 
     * @type {ConnectorInfo200ResponseRuntimesIoContainerdRuncV2}
     * @memberof ConnectorInfo200ResponseRuntimes
     */
    'runc'?: ConnectorInfo200ResponseRuntimesIoContainerdRuncV2;
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseRuntimesIoContainerdRuncV2
 */
export interface ConnectorInfo200ResponseRuntimesIoContainerdRuncV2 {
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseRuntimesIoContainerdRuncV2
     */
    'path'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConnectorInfo200ResponseRuntimesIoContainerdRuncV2
     */
    'status'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ConnectorInfo200ResponseSwarm
 */
export interface ConnectorInfo200ResponseSwarm {
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'NodeID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'NodeAddr'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'LocalNodeState'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'ControlAvailable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'Error'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectorInfo200ResponseSwarm
     */
    'RemoteManagers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConnectorStatus
 */
export interface ConnectorStatus {
    /**
     * Connector\'s connetion state type.
     * @type {boolean}
     * @memberof ConnectorStatus
     */
    'State'?: boolean;
    /**
     * Connector\'s connetion status message.
     * @type {string}
     * @memberof ConnectorStatus
     */
    'Message'?: string;
}
/**
 * 
 * @export
 * @interface ConnectorTLS
 */
export interface ConnectorTLS {
    /**
     * Certificate Authority used to generate the Cert for the server and the client.
     * @type {string}
     * @memberof ConnectorTLS
     */
    'ca': string;
    /**
     * Certificate generated from the CA certificate and used by the client to authorize the connection to the Docker Engine.
     * @type {string}
     * @memberof ConnectorTLS
     */
    'cert': string;
    /**
     * Private key for the certificate on the Cert field.
     * @type {string}
     * @memberof ConnectorTLS
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface CreateDeviceTagRequest
 */
export interface CreateDeviceTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof CreateDeviceTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface CreateNamespaceRequest
 */
export interface CreateNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof CreateNamespaceRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreatePublicKey200Response
 */
export interface CreatePublicKey200Response {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'fingerprint'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof CreatePublicKey200Response
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CreateTunnelRequest
 */
export interface CreateTunnelRequest {
    /**
     * Tunnel\'s agent host address
     * @type {string}
     * @memberof CreateTunnelRequest
     */
    'host': string;
    /**
     * Tunnel\'s agent port number
     * @type {number}
     * @memberof CreateTunnelRequest
     */
    'port': number;
    /**
     * Tunnel\'s time to live in seconds
     * @type {number}
     * @memberof CreateTunnelRequest
     */
    'ttl': number;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Device
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof Device
     */
    'identity'?: DeviceIdentity;
    /**
     * 
     * @type {DeviceInfo}
     * @memberof Device
     */
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof Device
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Device
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     * @type {string}
     * @memberof Device
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     * @type {boolean}
     * @memberof Device
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Device
     */
    'namespace'?: string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof Device
     */
    'status'?: DeviceStatus;
    /**
     * Device\'s status update date
     * @type {string}
     * @memberof Device
     */
    'status_update_at'?: string;
    /**
     * Device\'s creation date
     * @type {string}
     * @memberof Device
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     * @type {string}
     * @memberof Device
     */
    'remote_addr'?: string;
    /**
     * 
     * @type {DevicePosition}
     * @memberof Device
     */
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof Device
     */
    'tags'?: Array<string>;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof Device
     */
    'public_url'?: boolean;
    /**
     * Device\'s acceptable  The value \"acceptable\" is based on the number of devices removed and already accepted into a namespace. All devices are \"acceptable\" unless the \"namespace.max_devices\" is reached. This limit is set based on the sum up of accepted and removed devices into the namespace. When this limit is reached, only removed devices between 720 hours or 30 days are set to \"acceptable\". 
     * @type {boolean}
     * @memberof Device
     */
    'acceptable'?: boolean;
}
/**
 * Device\'s identity
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     * @type {string}
     * @memberof DeviceIdentity
     */
    'mac'?: string;
}
/**
 * Device\'s info
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     * @type {string}
     * @memberof DeviceInfo
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     * @type {string}
     * @memberof DeviceInfo
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     * @type {string}
     * @memberof DeviceInfo
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     * @type {string}
     * @memberof DeviceInfo
     */
    'arch'?: string;
    /**
     * Device\'s OS platform
     * @type {string}
     * @memberof DeviceInfo
     */
    'platform'?: DeviceInfoPlatformEnum;
}

export const DeviceInfoPlatformEnum = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatformEnum = typeof DeviceInfoPlatformEnum[keyof typeof DeviceInfoPlatformEnum];

/**
 * Device\'s geolocation position
 * @export
 * @interface DevicePosition
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Removed: 'removed',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface EditNamespaceRequest
 */
export interface EditNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof EditNamespaceRequest
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof EditNamespaceRequest
     */
    'settings'?: NamespaceSettings;
}
/**
 * 
 * @export
 * @interface Evaluate200Response
 */
export interface Evaluate200Response {
    /**
     * Namespaces\'s acceptance status.
     * @type {boolean}
     * @memberof Evaluate200Response
     */
    'can_accept'?: boolean;
    /**
     * Namespace\'s connection status.
     * @type {boolean}
     * @memberof Evaluate200Response
     */
    'can_connect'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallRulesRequest
 */
export interface FirewallRulesRequest {
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'action': FirewallRulesRequestActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesRequest
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesRequest
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesRequest
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'username': string;
}

export const FirewallRulesRequestActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesRequestActionEnum = typeof FirewallRulesRequestActionEnum[keyof typeof FirewallRulesRequestActionEnum];

/**
 * 
 * @export
 * @interface FirewallRulesResponse
 */
export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'tenant_id': string;
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'action': FirewallRulesResponseActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesResponse
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesResponse
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesResponse
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'username': string;
}

export const FirewallRulesResponseActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseActionEnum = typeof FirewallRulesResponseActionEnum[keyof typeof FirewallRulesResponseActionEnum];

/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 * @export
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf
 */
export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     * @type {string}
     * @memberof FirewallRulesResponseFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf1
 */
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     * @type {Array<string>}
     * @memberof FirewallRulesResponseFilterOneOf1
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GenerateInvitationLink200Response
 */
export interface GenerateInvitationLink200Response {
    /**
     * The invitation link.
     * @type {string}
     * @memberof GenerateInvitationLink200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface GenerateInvitationLinkRequest
 */
export interface GenerateInvitationLinkRequest {
    /**
     * The email of the member.
     * @type {string}
     * @memberof GenerateInvitationLinkRequest
     */
    'email': string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof GenerateInvitationLinkRequest
     */
    'role': NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface GetCustomer200Response
 */
export interface GetCustomer200Response {
    /**
     * Customer\'s ID.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'id'?: string;
    /**
     * Customer\'s name.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'name'?: string;
    /**
     * Customer\'s e-mail.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'email'?: string;
    /**
     * Customer\'s payment methods.
     * @type {Array<GetCustomer200ResponsePaymentMethodsInner>}
     * @memberof GetCustomer200Response
     */
    'payment_methods'?: Array<GetCustomer200ResponsePaymentMethodsInner>;
}
/**
 * 
 * @export
 * @interface GetCustomer200ResponsePaymentMethodsInner
 */
export interface GetCustomer200ResponsePaymentMethodsInner {
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'id'?: string;
    /**
     * Payment method card\'s number.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'number'?: string;
    /**
     * Payment method card\'s brand.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'brand'?: string;
    /**
     * Payment method card\'s expiration month.
     * @type {number}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'exp_month'?: number;
    /**
     * Payment method card\'s expiration year.
     * @type {number}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'exp_year'?: number;
    /**
     * Payment method card\'s CVC.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'cvc'?: string;
    /**
     * Payment method default status.
     * @type {boolean}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'default'?: boolean;
}
/**
 * @type GetCustomer400Response
 * @export
 */
export type GetCustomer400Response = GetCustomer400ResponseOneOf | RecordSession422Response;

/**
 * 
 * @export
 * @interface GetCustomer400ResponseOneOf
 */
export interface GetCustomer400ResponseOneOf {
    /**
     * Error\'s message.
     * @type {string}
     * @memberof GetCustomer400ResponseOneOf
     */
    'message'?: string;
    /**
     * Error\'s code.
     * @type {string}
     * @memberof GetCustomer400ResponseOneOf
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface GetFirewallRules401Response
 */
export interface GetFirewallRules401Response {
    /**
     * Error message
     * @type {string}
     * @memberof GetFirewallRules401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetSamlAuthUrl200Response
 */
export interface GetSamlAuthUrl200Response {
    /**
     * The complete URL to the Identity Provider\'s login page
     * @type {string}
     * @memberof GetSamlAuthUrl200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetStatusDevices200Response
 */
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'active_sessions'?: number;
}
/**
 * 
 * @export
 * @interface GetSubscription200Response
 */
export interface GetSubscription200Response {
    /**
     * Subscription\'s ID.
     * @type {string}
     * @memberof GetSubscription200Response
     */
    'id'?: string;
    /**
     * Subscription\'s active.
     * @type {boolean}
     * @memberof GetSubscription200Response
     */
    'active'?: boolean;
    /**
     * Subscription\'s status.
     * @type {string}
     * @memberof GetSubscription200Response
     */
    'status'?: GetSubscription200ResponseStatusEnum;
    /**
     * Subscription\'s current period end.
     * @type {number}
     * @memberof GetSubscription200Response
     */
    'end_at'?: number;
    /**
     * Subscription\'s invoices.
     * @type {Array<GetSubscription200ResponseInvoicesInner>}
     * @memberof GetSubscription200Response
     */
    'invoices'?: Array<GetSubscription200ResponseInvoicesInner>;
}

export const GetSubscription200ResponseStatusEnum = {
    Inactive: 'inactive',
    Active: 'active',
    Trialing: 'trialing',
    Incomplete: 'incomplete',
    IncompleteExpired: 'incomplete_expired',
    PastDue: 'past_due',
    Canceled: 'canceled',
    Unpaid: 'unpaid',
    Paused: 'paused',
    ToCancelAtEndOfPeriod: 'to_cancel_at_end_of_period'
} as const;

export type GetSubscription200ResponseStatusEnum = typeof GetSubscription200ResponseStatusEnum[keyof typeof GetSubscription200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetSubscription200ResponseInvoicesInner
 */
export interface GetSubscription200ResponseInvoicesInner {
    /**
     * Invoice\'s ID.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'id'?: string;
    /**
     * Invoice\'s status.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'status'?: GetSubscription200ResponseInvoicesInnerStatusEnum;
    /**
     * Invoice\'s currency.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'currency'?: GetSubscription200ResponseInvoicesInnerCurrencyEnum;
    /**
     * Invoice\'s amount in cents.
     * @type {number}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'amount'?: number;
}

export const GetSubscription200ResponseInvoicesInnerStatusEnum = {
    Draft: 'draft',
    Open: 'open',
    Paid: 'paid',
    Uncollectible: 'uncollectible',
    Voided: 'voided'
} as const;

export type GetSubscription200ResponseInvoicesInnerStatusEnum = typeof GetSubscription200ResponseInvoicesInnerStatusEnum[keyof typeof GetSubscription200ResponseInvoicesInnerStatusEnum];
export const GetSubscription200ResponseInvoicesInnerCurrencyEnum = {
    Usd: 'usd',
    Brl: 'brl'
} as const;

export type GetSubscription200ResponseInvoicesInnerCurrencyEnum = typeof GetSubscription200ResponseInvoicesInnerCurrencyEnum[keyof typeof GetSubscription200ResponseInvoicesInnerCurrencyEnum];

/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * The current version of ShellHub.
     * @type {string}
     * @memberof Info
     */
    'version'?: string;
    /**
     * 
     * @type {InfoEndpoints}
     * @memberof Info
     */
    'endpoints'?: InfoEndpoints;
    /**
     * Indicates whether the instance setup is complete.
     * @type {boolean}
     * @memberof Info
     */
    'setup'?: boolean;
    /**
     * 
     * @type {InfoAuthentication}
     * @memberof Info
     */
    'authentication'?: InfoAuthentication;
}
/**
 * Authentication methods available for the ShellHub instance.
 * @export
 * @interface InfoAuthentication
 */
export interface InfoAuthentication {
    /**
     * Indicates if local authentication using email and password is enabled.
     * @type {boolean}
     * @memberof InfoAuthentication
     */
    'local'?: boolean;
    /**
     * Indicates if SAML-based single sign-on (SSO) is enabled.
     * @type {boolean}
     * @memberof InfoAuthentication
     */
    'saml'?: boolean;
}
/**
 * Network endpoints for the ShellHub instance.
 * @export
 * @interface InfoEndpoints
 */
export interface InfoEndpoints {
    /**
     * The SSH endpoint where devices connect.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'ssh'?: string;
    /**
     * The API endpoint for managing ShellHub configurations.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LookupUserStatus200Response
 */
export interface LookupUserStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof LookupUserStatus200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface MfaAuth
 */
export interface MfaAuth {
    /**
     * The `X-MFA-Token` header returned by the authUser endpoint.
     * @type {string}
     * @memberof MfaAuth
     */
    'token': string;
    /**
     * The current code from the MFA authenticator.
     * @type {string}
     * @memberof MfaAuth
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface MfaDisable
 */
export interface MfaDisable {
    /**
     * The code generated by the MFA app.
     * @type {string}
     * @memberof MfaDisable
     */
    'code'?: string;
    /**
     * User\'s recovery code.
     * @type {string}
     * @memberof MfaDisable
     */
    'recovery_code'?: string;
}
/**
 * 
 * @export
 * @interface MfaEnable
 */
export interface MfaEnable {
    /**
     * The code generated by the MFA app.
     * @type {string}
     * @memberof MfaEnable
     */
    'code': string;
    /**
     * The secret generated by generateMFA endpoint.
     * @type {string}
     * @memberof MfaEnable
     */
    'secret': string;
    /**
     * A list of codes generated by generateMFA endpoint. These codes can be used when a user loses their MFA app. 
     * @type {Array<string>}
     * @memberof MfaEnable
     */
    'recovery_codes': Array<string>;
}
/**
 * 
 * @export
 * @interface MfaGenerate
 */
export interface MfaGenerate {
    /**
     * The link to establish a connection with the OTP server.
     * @type {string}
     * @memberof MfaGenerate
     */
    'link'?: string;
    /**
     * A secret key to authenticate with the OTP server.
     * @type {string}
     * @memberof MfaGenerate
     */
    'secret'?: string;
    /**
     * A list of recovery codes to use when the user loses access to their MFA app.
     * @type {Array<string>}
     * @memberof MfaGenerate
     */
    'recovery_codes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MfaRecover
 */
export interface MfaRecover {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     * @type {string}
     * @memberof MfaRecover
     */
    'identifier': string;
    /**
     * One of the user\'s recovery codes.
     * @type {string}
     * @memberof MfaRecover
     */
    'recovery_code': string;
}
/**
 * 
 * @export
 * @interface MfaReset
 */
export interface MfaReset {
    /**
     * The code sent to the main email address.
     * @type {string}
     * @memberof MfaReset
     */
    'main_email_code': string;
    /**
     * The code sent to the recovery email address.
     * @type {string}
     * @memberof MfaReset
     */
    'recovery_email_code': string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof Namespace
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Namespace
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     * @type {Array<NamespaceMembersInner>}
     * @memberof Namespace
     */
    'members'?: Array<NamespaceMembersInner>;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof Namespace
     */
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     * @type {number}
     * @memberof Namespace
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     * @type {number}
     * @memberof Namespace
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     * @type {string}
     * @memberof Namespace
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     * @type {object}
     * @memberof Namespace
     */
    'billing'?: object;
}
/**
 * Namespace\'s member role
 * @export
 * @enum {string}
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


/**
 * 
 * @export
 * @interface NamespaceMembersInner
 */
export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'id'?: string;
    /**
     * The time when the member was invited.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'added_at'?: string;
    /**
     * **NOTE: ONLY USED IN CLOUD INSTANCE.**  The time when the invite expires. If the member is not in `pending` status, this will be set to the zero UTC time. 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'expires_at'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof NamespaceMembersInner
     */
    'role'?: NamespaceMemberRole;
    /**
     * this field, on majority of cases is default \'personal\', if the running instance of shellhub is cloud, the default value is \'team\'.  This field requires a valid input of either \'personal\' or \'team\'. the default will match the current Shellhub instance type. When a \"type\" field value is specified, it will override the default, but must be either \'personal\' or \'team\'. Any other input will be rejected. 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'type'?: NamespaceMembersInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'status'?: NamespaceMembersInnerStatusEnum;
    /**
     * Member\'s email.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'email'?: string;
}

export const NamespaceMembersInnerTypeEnum = {
    Personal: 'personal',
    Team: 'team'
} as const;

export type NamespaceMembersInnerTypeEnum = typeof NamespaceMembersInnerTypeEnum[keyof typeof NamespaceMembersInnerTypeEnum];
export const NamespaceMembersInnerStatusEnum = {
    Accepted: 'accepted',
    Pending: 'pending'
} as const;

export type NamespaceMembersInnerStatusEnum = typeof NamespaceMembersInnerStatusEnum[keyof typeof NamespaceMembersInnerStatusEnum];

/**
 * Namespace\'s settings.
 * @export
 * @interface NamespaceSettings
 */
export interface NamespaceSettings {
    /**
     * The session records define when the namespace should save or not record a session. This can be used to check logged activity when connecting to a device.
     * @type {boolean}
     * @memberof NamespaceSettings
     */
    'session_record'?: boolean;
    /**
     * A connection announcement is a custom string written during a session when a connection is established on a device within the namespace.
     * @type {string}
     * @memberof NamespaceSettings
     */
    'connection_announcement'?: string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags. 
 * @export
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf
 */
export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     * @type {string}
     * @memberof PublicKeyFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf1
 */
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     * @type {Set<string>}
     * @memberof PublicKeyFilterOneOf1
     */
    'tags': Set<string>;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'data': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyRequest
     */
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PublicKeyResponse
 */
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyResponse
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RecordSession422Response
 */
export interface RecordSession422Response {
    /**
     * Error\'s message.
     * @type {string}
     * @memberof RecordSession422Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RecordSessionRequest
 */
export interface RecordSessionRequest {
    /**
     * Session\'s UID.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'uid': string;
    /**
     * Session\'s Seat
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'seat': number;
    /**
     * Session\'s data.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'message': string;
    /**
     * Session\'s pty width.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'width': number;
    /**
     * Session\'s pty height.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecordedSessionResponseInner
 */
export interface RecordedSessionResponseInner {
    /**
     * Session\'s ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'uid': string;
    /**
     * Session\'s Seat
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'seat': number;
    /**
     * Session\'s Data
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'message': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'tenant_id': string;
    /**
     * Session\'s time
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'time': string;
    /**
     * Session\'s terminal width
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'width': number;
    /**
     * Session\'s terminal height
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecoverPasswordRequest
 */
export interface RecoverPasswordRequest {
    /**
     * 
     * @type {RecoverPasswordRequestUsername}
     * @memberof RecoverPasswordRequest
     */
    'username': RecoverPasswordRequestUsername;
}
/**
 * @type RecoverPasswordRequestUsername
 * @export
 */
export type RecoverPasswordRequestUsername = string;

/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * The full name of the user.
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'name': string;
    /**
     * The user\'s email address, which must be unique. This email will be used for login and for receiving important notifications, such as password reset emails. If `email_marketing` is set to `true`, promotional emails will also be sent to this address. 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * The username, which must be unique across the system. Users can log in using either their username or email. 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'username': string;
    /**
     * The password for the user account. Must follow the regex. 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
    /**
     * Indicates whether the user opts to receive marketing and promotional emails. 
     * @type {boolean}
     * @memberof RegisterUserRequest
     */
    'email_marketing': boolean;
    /**
     * **For standard registration processes, this field should be ignored.**   A unique signature included in an invitation email. This is used to automatically confirm the user\'s registration without requiring an additional confirmation email. 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'sig'?: string;
}
/**
 * 
 * @export
 * @interface RenameTagRequest
 */
export interface RenameTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof RenameTagRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface RequestResetMFARequest
 */
export interface RequestResetMFARequest {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     * @type {string}
     * @memberof RequestResetMFARequest
     */
    'identifier': string;
}
/**
 * 
 * @export
 * @interface ResendEmailRequest
 */
export interface ResendEmailRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof ResendEmailRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface RuleAddTagRequest
 */
export interface RuleAddTagRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleAddTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface RuleUpdateTagsRequest
 */
export interface RuleUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RuleUpdateTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session\'s UID
     * @type {string}
     * @memberof Session
     */
    'uid'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Session
     */
    'device_uid'?: string;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Session
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     * @type {string}
     * @memberof Session
     */
    'username'?: string;
    /**
     * Session\'s IP address
     * @type {string}
     * @memberof Session
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     * @type {string}
     * @memberof Session
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     * @type {string}
     * @memberof Session
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     * @type {boolean}
     * @memberof Session
     */
    'recorded'?: boolean;
    /**
     * Session\'s type
     * @type {string}
     * @memberof Session
     */
    'type'?: SessionTypeEnum;
    /**
     * Session\'s terminal
     * @type {string}
     * @memberof Session
     */
    'term'?: string;
    /**
     * 
     * @type {SessionPosition}
     * @memberof Session
     */
    'position'?: SessionPosition;
    /**
     * 
     * @type {SessionEvents}
     * @memberof Session
     */
    'events'?: SessionEvents;
}

export const SessionTypeEnum = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionTypeEnum = typeof SessionTypeEnum[keyof typeof SessionTypeEnum];

/**
 * Session\'s events
 * @export
 * @interface SessionEvents
 */
export interface SessionEvents {
    /**
     * Session\'s set of types
     * @type {Array<string>}
     * @memberof SessionEvents
     */
    'types'?: Array<string>;
    /**
     * Session\'s seats
     * @type {Array<number>}
     * @memberof SessionEvents
     */
    'seats'?: Array<number>;
    /**
     * Session\'s list of events
     * @type {Array<SessionEventsItemsInner>}
     * @memberof SessionEvents
     */
    'items'?: Array<SessionEventsItemsInner>;
}
/**
 * 
 * @export
 * @interface SessionEventsItemsInner
 */
export interface SessionEventsItemsInner {
    /**
     * The type of the event
     * @type {string}
     * @memberof SessionEventsItemsInner
     */
    'type'?: string;
    /**
     * The time the event occurred in ISO 8601 format
     * @type {string}
     * @memberof SessionEventsItemsInner
     */
    'timestamp'?: string;
    /**
     * Additional data related to the event
     * @type {object}
     * @memberof SessionEventsItemsInner
     */
    'data'?: object;
    /**
     * Seat where the event happened
     * @type {number}
     * @memberof SessionEventsItemsInner
     */
    'seat'?: number;
}
/**
 * Session\'s geolocation position
 * @export
 * @interface SessionPosition
 */
export interface SessionPosition {
    /**
     * Session\'s latitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'latitude'?: number;
    /**
     * Session\'s longitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface SetSessionAuthenticationStatusRequest
 */
export interface SetSessionAuthenticationStatusRequest {
    /**
     * Session\'s authentication status.
     * @type {boolean}
     * @memberof SetSessionAuthenticationStatusRequest
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SetSessionRecordRequest
 */
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     * @type {boolean}
     * @memberof SetSessionRecordRequest
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface SetupRequest
 */
export interface SetupRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof SetupRequest
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof SetupRequest
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof SetupRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof SetupRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Support
 */
export interface Support {
    /**
     * Support identifier.
     * @type {string}
     * @memberof Support
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface Tunnel
 */
export interface Tunnel {
    /**
     * Tunnel\'s unique address
     * @type {string}
     * @memberof Tunnel
     */
    'address'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Tunnel
     */
    'namespace'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Tunnel
     */
    'device'?: string;
    /**
     * Tunnel\'s agent host address
     * @type {string}
     * @memberof Tunnel
     */
    'host'?: string;
    /**
     * Tunnel\'s agent port number
     * @type {number}
     * @memberof Tunnel
     */
    'port'?: number;
    /**
     * Tunnel\'s time to live in seconds
     * @type {number}
     * @memberof Tunnel
     */
    'ttl'?: number;
    /**
     * Tunnel\'s expiration date
     * @type {string}
     * @memberof Tunnel
     */
    'expires_in'?: string;
    /**
     * Tunnel\'s creation date
     * @type {string}
     * @memberof Tunnel
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'name'?: string;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof UpdateDeviceRequest
     */
    'public_url'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateNamespaceMemberRequest
 */
export interface UpdateNamespaceMemberRequest {
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UpdateNamespaceMemberRequest
     */
    'role'?: NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s username.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'username': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof UpdatePublicKeyRequest
     */
    'filter': PublicKeyFilter;
}
/**
 * 
 * @export
 * @interface UpdateRecoverPasswordRequest
 */
export interface UpdateRecoverPasswordRequest {
    /**
     * User\'s password.
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'password': string;
    /**
     * User\'s recovery token.    It is the token from the email sent to user when the user request password reset. 
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UpdateTagsDeviceRequest
 */
export interface UpdateTagsDeviceRequest {
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof UpdateTagsDeviceRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTagsPublicKeyRequest
 */
export interface UpdateTagsPublicKeyRequest {
    /**
     * Public key\'s new tags.
     * @type {Set<string>}
     * @memberof UpdateTagsPublicKeyRequest
     */
    'tags'?: Set<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDataRequest
 */
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'name'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'username'?: string;
    /**
     * User\'s e-mail.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'email'?: string;
    /**
     * User\'s recovery e-mail. A recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'recovery_email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'current_password'?: string;
    /**
     * User new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * A recovery email serves as the user\'s final recourse to regain access to their account. It cannot be the same as the user\'s primary email. Once defined, it cannot be updated to an empty value. 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'recovery_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'password'?: string;
    /**
     * It\'s required when updating the user\'s password. 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'current_password'?: string;
}
/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * JWT Token
     * @type {string}
     * @memberof UserAuth
     */
    'token'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAuth
     */
    'id'?: string;
    /**
     * 
     * @type {UserOrigin}
     * @memberof UserAuth
     */
    'origin'?: UserOrigin;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAuth
     */
    'user'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAuth
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAuth
     */
    'email'?: string;
    /**
     * The recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UserAuth
     */
    'recovery_email'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof UserAuth
     */
    'tenant'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UserAuth
     */
    'role'?: NamespaceMemberRole;
    /**
     * Indicates whether the user has MFA enabled.
     * @type {boolean}
     * @memberof UserAuth
     */
    'mfa'?: boolean;
    /**
     * Indicates the maximum number of namespaces a user is allowed to create. If set to 0, the user is not permitted to create any namespaces. If set to -1, the user has no limit on the number of namespaces they can create.
     * @type {number}
     * @memberof UserAuth
     */
    'max_namespaces'?: number;
}
/**
 * Specifies the method the user employed to register with ShellHub.
 * @export
 * @enum {string}
 */

export const UserOrigin = {
    Local: 'local'
} as const;

export type UserOrigin = typeof UserOrigin[keyof typeof UserOrigin];



/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key?: string, apiKeyUpdate?: ApiKeyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: any): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyDelete(key?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} [key] 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: 'device_accept' | 'namespace_delete', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: any): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: any): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: any): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: 'device_accept' | 'namespace_delete', options?: any): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCustomer(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public evaluate(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomer(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {'device_accept' | 'namespace_delete'} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudApi - axios parameter creator
 * @export
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord: async (uid: string, seat: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('deleteSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (uid: string, seat: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('getSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('recordSession', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest?: RegisterUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: 'device_accept' | 'namespace_delete', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 * @export
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionRecord(uid, seat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(uid, seat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, seat, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest?: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudApi - factory interface
 * @export
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: any): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord(uid: string, seat: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: any): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: any): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: any): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(uid: string, seat: number, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, seat, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest?: RegisterUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: 'device_accept' | 'namespace_delete', options?: any): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 * @export
 * @class CloudApi
 * @extends {BaseAPI}
 */
export class CloudApi extends BaseAPI {
    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createCustomer(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a session record based on its seat.
     * @summary Delete session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteUser(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public evaluate(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public generateMFA(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getCustomer(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session record based on its seat.
     * @summary Get session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {number} seat 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recordSession(uid, seat, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterUserRequest} [registerUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public registerUser(registerUserRequest?: RegisterUserRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {'device_accept' | 'namespace_delete'} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createContainerTag', 'uid', uid)
            const localVarPath = `/api/containers/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainerTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteContainerTag', 'tag', tag)
            const localVarPath = `/api/containers/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainerStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateContainerStatus', 'status', status)
            const localVarPath = `/api/containers/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsContainer: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainers(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(uid, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainerStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsContainer(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createContainerTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateContainer(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateContainerStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsContainer(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainerTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a container.
     * @summary Delete container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public deleteContainer(uid: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).deleteContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from container.
     * @summary Delete a tag from container
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public deleteContainerTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).deleteContainerTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a container.
     * @summary Get container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainer(uid: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of containers.
     * @summary Get containers
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Container\&#39;s status
     * @param {string} [sortBy] Container\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s data.
     * @summary Update container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s status.
     * @summary Update container status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainerStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to container
     * @summary Update tags to container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateTagsContainer(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTunnel: async (uid: string, createTunnelRequest: CreateTunnelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createTunnel', 'uid', uid)
            // verify required parameter 'createTunnelRequest' is not null or undefined
            assertParamExists('createTunnel', 'createTunnelRequest', createTunnelRequest)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTunnelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunnel: async (uid: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteTunnel', 'uid', uid)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteTunnel', 'address', address)
            const localVarPath = `/api/devices/{uid}/tunnels/{address}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunnels: async (uid: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listTunnels', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tunnel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTunnel(uid, createTunnelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunnel(uid: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunnel(uid, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTunnels(uid: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tunnel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunnels(uid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(uid, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: any): AxiosPromise<Tunnel> {
            return localVarFp.createTunnel(uid, createTunnelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunnel(uid: string, address: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTunnel(uid, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: any): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunnels(uid: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Tunnel>> {
            return localVarFp.listTunnels(uid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDevice(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public acceptDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tunnel for a device.
     * @summary Create a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {CreateTunnelRequest} createTunnelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createTunnel(uid, createTunnelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tunnel for a specific device and port.
     * @summary Delete a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteTunnel(uid: string, address: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteTunnel(uid, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getStatusDevices(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tunnels per devices.
     * @summary List tunnels
     * @param {string} uid Device\&#39;s UID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public listTunnels(uid: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).listTunnels(uid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s data.
     * @summary Update device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDevice(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalApiFp(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateInvitationLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink: async (tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('generateInvitationLink', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/invites`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateInvitationLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus: async (tenant: string, id: string, sig: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('lookupUserStatus', 'tenant', tenant)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupUserStatus', 'id', id)
            // verify required parameter 'sig' is not null or undefined
            assertParamExists('lookupUserStatus', 'sig', sig)
            const localVarPath = `/api/namespaces/{tenant}/members/{id}/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sig !== undefined) {
                localVarQueryParameter['sig'] = sig;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, generateInvitationLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateInvitationLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInvitationLink(tenant, generateInvitationLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserStatus(tenant: string, id: string, sig: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LookupUserStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStatus(tenant, id, sig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, generateInvitationLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: any): AxiosPromise<GenerateInvitationLink200Response> {
            return localVarFp.generateInvitationLink(tenant, generateInvitationLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus(tenant: string, id: string, sig: string, options?: any): AxiosPromise<LookupUserStatus200Response> {
            return localVarFp.lookupUserStatus(tenant, id, sig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).addNamespaceMember(tenant, generateInvitationLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
     * @summary Generate an invitation link for a namespace member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).generateInvitationLink(tenant, generateInvitationLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public leaveNamespace(tenant: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
     * @summary Lookup User\'s Status
     * @param {string} tenant The tenant ID of the namespace.
     * @param {string} id The user\&#39;s ID.
     * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public lookupUserStatus(tenant: string, id: string, sig: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).lookupUserStatus(tenant, id, sig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MfaApi - axios parameter creator
 * @export
 */
export const MfaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MfaApi - functional programming interface
 * @export
 */
export const MfaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MfaApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MfaApi - factory interface
 * @export
 */
export const MfaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MfaApiFp(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: any): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MfaApi - object-oriented interface
 * @export
 * @class MfaApi
 * @extends {BaseAPI}
 */
export class MfaApi extends BaseAPI {
    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public generateMFA(options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespacesApi - axios parameter creator
 * @export
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateInvitationLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key?: string, apiKeyUpdate?: ApiKeyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate: async (connectorData: ConnectorData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorCreate', 'connectorData', connectorData)
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorDelete', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorGet', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorInfo', 'uid', uid)
            const localVarPath = `/api/connector/{uid}/info`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList: async (enable?: boolean, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (enable !== undefined) {
                localVarQueryParameter['enable'] = enable;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate: async (uid: string, connectorData: ConnectorData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorUpdate', 'uid', uid)
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorUpdate', 'connectorData', connectorData)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceRequest?: CreateNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, editNamespaceRequest?: EditNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink: async (tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('generateInvitationLink', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/invites`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateInvitationLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceSupport', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/support`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus: async (tenant: string, id: string, sig: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('lookupUserStatus', 'tenant', tenant)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupUserStatus', 'id', id)
            // verify required parameter 'sig' is not null or undefined
            assertParamExists('lookupUserStatus', 'sig', sig)
            const localVarPath = `/api/namespaces/{tenant}/members/{id}/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sig !== undefined) {
                localVarQueryParameter['sig'] = sig;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, generateInvitationLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorCreate(connectorData: ConnectorData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorCreate(connectorData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorDelete(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorDelete(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorGet(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorGet(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorInfo(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorInfo(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorList(enable?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorList(enable, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorUpdate(uid: string, connectorData: ConnectorData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorUpdate(uid, connectorData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, editNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateInvitationLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInvitationLink(tenant, generateInvitationLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceSupport(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Support>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceSupport(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserStatus(tenant: string, id: string, sig: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LookupUserStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStatus(tenant, id, sig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, generateInvitationLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: any): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate(connectorData: ConnectorData, options?: any): AxiosPromise<void> {
            return localVarFp.connectorCreate(connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.connectorDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet(uid: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.connectorGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo(uid: string, options?: any): AxiosPromise<ConnectorInfo200Response> {
            return localVarFp.connectorInfo(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList(enable?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Connector>> {
            return localVarFp.connectorList(enable, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate(uid: string, connectorData: ConnectorData, options?: any): AxiosPromise<void> {
            return localVarFp.connectorUpdate(uid, connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, editNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: any): AxiosPromise<GenerateInvitationLink200Response> {
            return localVarFp.generateInvitationLink(tenant, generateInvitationLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport(tenant: string, options?: any): AxiosPromise<Support> {
            return localVarFp.getNamespaceSupport(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus(tenant: string, id: string, sig: string, options?: any): AxiosPromise<LookupUserStatus200Response> {
            return localVarFp.lookupUserStatus(tenant, id, sig, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public addNamespaceMember(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, generateInvitationLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyDelete(key?: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} [key] 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new connector.
     * @summary Connector\'s create
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorCreate(connectorData: ConnectorData, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorCreate(connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a connector.
     * @summary Connector\'s delete
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorDelete(uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a connector.
     * @summary Connector\'s get
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorGet(uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the connector\'s connection docker info.
     * @summary Connector\'s get Docker info
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorInfo(uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorInfo(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connectors.
     * @summary Connector\'s list
     * @param {boolean} [enable] Enable status.
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorList(enable?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorList(enable, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a connector settings.
     * @summary Connector\'s setting update
     * @param {string} uid Connector UID
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public connectorUpdate(uid: string, connectorData: ConnectorData, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorUpdate(uid, connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {EditNamespaceRequest} [editNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, editNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
     * @summary Generate an invitation link for a namespace member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {GenerateInvitationLinkRequest} [generateInvitationLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public generateInvitationLink(tenant: string, generateInvitationLinkRequest?: GenerateInvitationLinkRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).generateInvitationLink(tenant, generateInvitationLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace support identifier.
     * @summary Get a namespace support identifier.
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceSupport(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceSupport(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceToken(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public leaveNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
     * @summary Lookup User\'s Status
     * @param {string} tenant The tenant ID of the namespace.
     * @param {string} id The user\&#39;s ID.
     * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public lookupUserStatus(tenant: string, id: string, sig: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).lookupUserStatus(tenant, id, sig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord: async (uid: string, seat: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('deleteSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (uid: string, seat: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('getSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('recordSession', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionRecord(uid, seat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(uid, seat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, seat, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord(uid: string, seat: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(uid: string, seat: number, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, seat, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public checkSessionRecord(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a session record based on its seat.
     * @summary Delete session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public deleteSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).deleteSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session record based on its seat.
     * @summary Get session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionRecord(uid: string, seat: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {number} seat 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).recordSession(uid, seat, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SshApi - axios parameter creator
 * @export
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 * @export
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SshApi - factory interface
 * @export
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 * @export
 * @class SshApi
 * @extends {BaseAPI}
 */
export class SshApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public deletePublicKey(fingerprint: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup: async (sign: string, setupRequest?: SetupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sign' is not null or undefined
            assertParamExists('setup', 'sign', sign)
            const localVarPath = `/api/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sign !== undefined) {
                localVarQueryParameter['sign'] = sign;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup(sign: string, setupRequest?: SetupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup(sign, setupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup(sign: string, setupRequest?: SetupRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setup(sign, setupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Get information about ShellHub instance like version, SSH and API addresses.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getInfo(agentVersion?: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an user and create namespace with the same name as username
     * @summary User setup
     * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
     * @param {SetupRequest} [setupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public setup(sign: string, setupRequest?: SetupRequest, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).setup(sign, setupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createContainerTag', 'uid', uid)
            const localVarPath = `/api/containers/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainerTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteContainerTag', 'tag', tag)
            const localVarPath = `/api/containers/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: async (tag: string, renameTagRequest?: RenameTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('renameTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsContainer: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameTag(tag, renameTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsContainer(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createContainerTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from container.
         * @summary Delete a tag from container
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.renameTag(tag, renameTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to container
         * @summary Update tags to container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsContainer(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createContainerTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createContainerTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from container.
     * @summary Delete a tag from container
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteContainerTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteContainerTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {RenameTagRequest} [renameTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).renameTag(tag, renameTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to container
     * @summary Update tags to container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsContainer(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsContainer(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TunnelsApi - axios parameter creator
 * @export
 */
export const TunnelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTunnel: async (uid: string, createTunnelRequest: CreateTunnelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createTunnel', 'uid', uid)
            // verify required parameter 'createTunnelRequest' is not null or undefined
            assertParamExists('createTunnel', 'createTunnelRequest', createTunnelRequest)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTunnelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunnel: async (uid: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteTunnel', 'uid', uid)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteTunnel', 'address', address)
            const localVarPath = `/api/devices/{uid}/tunnels/{address}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunnels: async (uid: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listTunnels', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TunnelsApi - functional programming interface
 * @export
 */
export const TunnelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TunnelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tunnel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTunnel(uid, createTunnelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunnel(uid: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunnel(uid, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTunnels(uid: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tunnel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunnels(uid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TunnelsApi - factory interface
 * @export
 */
export const TunnelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TunnelsApiFp(configuration)
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: any): AxiosPromise<Tunnel> {
            return localVarFp.createTunnel(uid, createTunnelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunnel(uid: string, address: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTunnel(uid, address, options).then((request) => request(axios, basePath));
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunnels(uid: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Tunnel>> {
            return localVarFp.listTunnels(uid, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TunnelsApi - object-oriented interface
 * @export
 * @class TunnelsApi
 * @extends {BaseAPI}
 */
export class TunnelsApi extends BaseAPI {
    /**
     * Creates a new tunnel for a device.
     * @summary Create a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {CreateTunnelRequest} createTunnelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelsApi
     */
    public createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: AxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).createTunnel(uid, createTunnelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tunnel for a specific device and port.
     * @summary Delete a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelsApi
     */
    public deleteTunnel(uid: string, address: string, options?: AxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).deleteTunnel(uid, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tunnels per devices.
     * @summary List tunnels
     * @param {string} uid Device\&#39;s UID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelsApi
     */
    public listTunnels(uid: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).listTunnels(uid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/saml/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest?: RegisterUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword: async (id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamlAuthUrl(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSamlAuthUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamlAuthUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest?: RegisterUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl(options?: any): AxiosPromise<GetSamlAuthUrl200Response> {
            return localVarFp.getSamlAuthUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest?: RegisterUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkSessionRecord(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
     * @summary Get SAML authentication URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSamlAuthUrl(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSamlAuthUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} [tenant] Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getToken(tenant?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterUserRequest} [registerUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerUser(registerUserRequest?: RegisterUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} [id] User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


