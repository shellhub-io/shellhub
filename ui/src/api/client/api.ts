/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub OpenAPI
 * > THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR.  This is the OpenAPI specification for ShellHub community version. It documents the parameters and bodies for performs HTTP requests to the ShellHub server endpoints related to users, namespaces, members, devices, tags, SSH, sessions, etc.  These endpoints require a JSON Web Token (JWT) as its security scheme, that means you need to send, to almost each request, an HTTP header called `Authorization` with the `bearer` token. To obtains this token, uses the `/api/login` route, fulfilling its request body to return that token with some essential information about the user whom logged  in. 
 *
 * The version of the OpenAPI document: 0.20.0
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AcceptInviteRequest {
    /**
     * The unique key included in the email link.
     */
    'sig': string;
}
export interface AddNamespaceMemberRequest {
    /**
     * The email of the member.
     */
    'email': string;
    'role': NamespaceMemberRole;
}


export interface AdminResetUserPassword200Response {
    /**
     * The newly generated password
     */
    'password'?: string;
}
/**
 * Announcement.
 */
export interface Announcement {
    /**
     * Announcement UUID.
     */
    'uuid'?: string;
    /**
     * Announcement title.
     */
    'title'?: string;
    /**
     * Announcement description.
     */
    'content'?: string;
    'date'?: string;
}
export interface AnnouncementShort {
    /**
     * Announcement UUID.
     */
    'uuid'?: string;
    /**
     * Announcement title.
     */
    'title'?: string;
    'date'?: string;
}
export interface ApiKey {
    /**
     * The tenant ID of the namespace with which the key is associated.
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     */
    'updated_at'?: string;
}
export interface ApiKeyCreate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     */
    'name': string;
    'expires_at': ApiKeyCreateExpiresAt;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. Leave it blank to use the user\'s role. 
     */
    'role'?: string;
    /**
     * An optional and unique value to be used as the API key\'s internal identifier. This value is the \"internal ID\" and will NEVER be returned to the client. Leave it blank for a random one to be generated. 
     */
    'key'?: string;
}


/**
 * Number of days until expiration. Use -1 for no expiration.
 */

export const ApiKeyCreateExpiresAt = {
    NUMBER_MINUS_1: -1,
    NUMBER_30: 30,
    NUMBER_60: 60,
    NUMBER_90: 90,
    NUMBER_365: 365
} as const;

export type ApiKeyCreateExpiresAt = typeof ApiKeyCreateExpiresAt[keyof typeof ApiKeyCreateExpiresAt];


/**
 * The list order.
 */

export const ApiKeyListOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ApiKeyListOrderByParameter = typeof ApiKeyListOrderByParameter[keyof typeof ApiKeyListOrderByParameter];


export interface ApiKeyUpdate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     */
    'name'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. 
     */
    'role'?: string;
}
export interface ApiKeyWithID {
    /**
     * The UUID of the API key. It is used only internally and, except for the create operation, is never returned to the client. 
     */
    'id'?: string;
    /**
     * The tenant ID of the namespace with which the key is associated.
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     */
    'updated_at'?: string;
}
export interface AttachPaymentMethodRequest {
    /**
     * Payment method\'s ID.
     */
    'id': string;
}
export interface AuthSSHPublicKey200Response {
    /**
     * Device\'s signature.
     */
    'signature'?: string;
}
export interface AuthSSHPublicKeyRequest {
    /**
     * Public key\'s fingerprint.
     */
    'fingerprint': string;
    /**
     * Public key\'s data in PEM format.
     */
    'data': string;
}
export interface ChoiceDevicesRequest {
    /**
     * Device\'s list.
     */
    'choices': Array<string>;
}
export interface ClsoeSessionRequest {
    /**
     * Device\'s UID
     */
    'device': string;
}
export interface ConfigureLocalAuthenticationRequest {
    /**
     * Specifies whether to activate (`true`) or deactivate (`false`) local authentication. 
     */
    'enable': boolean;
}
export interface ConfigureSAMLAuthenticationRequest {
    /**
     * Specifies whether to activate (`true`) or deactivate (`false`) SAML authentication. If set to `false`, all other attributes will be ignored. 
     */
    'enable': boolean;
    'idp': ConfigureSAMLAuthenticationRequestIdp;
    'sp': ConfigureSAMLAuthenticationRequestSp;
}
/**
 * Configuration for the Identity Provider (IdP) that ShellHub will use for authentication.  You can provide either a metadata URL to fetch all necessary information automatically  or specify the `SignOn URL`, `Entity ID`, and `X509 certificate` explicitly. 
 */
export interface ConfigureSAMLAuthenticationRequestIdp {
    /**
     * The URL to fetch IdP metadata. If provided, this will automatically retrieve all necessary configuration details and take precedence over manually specified values. 
     */
    'metadata_url'?: string;
    /**
     * The Entity ID of the IdP.
     */
    'entity_id'?: string;
    /**
     * The public X509 certificate of the IdP. It can be provided with or without  the PEM delimiters (`-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`). 
     */
    'certificate'?: string;
    'binding'?: ConfigureSAMLAuthenticationRequestIdpBinding;
    'mappings'?: ConfigureSAMLAuthenticationRequestIdpMappings;
}
/**
 * Configuration for SAML binding methods that define how authentication requests  and responses are transmitted between ShellHub and the IdP. SAML supports  different binding protocols for flexibility in deployment scenarios. 
 */
export interface ConfigureSAMLAuthenticationRequestIdpBinding {
    /**
     * The Single Sign-On URL for HTTP-POST binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-POST method, which  sends SAML data in the body of an HTTP POST request. This binding is more  secure as it doesn\'t expose SAML data in URL parameters. 
     */
    'post'?: string;
    /**
     * The Single Sign-On URL for HTTP-Redirect binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-Redirect method, which  sends SAML data as URL parameters. This binding is simpler but has URL length  limitations and exposes SAML data in browser history and server logs. 
     */
    'redirect'?: string;
    'preferred'?: ConfigureSAMLAuthenticationRequestIdpBindingPreferred;
}


/**
 * Specifies which binding method ShellHub should prefer when both POST and  Redirect bindings are available. If only one binding URL is provided,  that binding will be used regardless of this preference setting. If left blank or empty, POST binding is preferred by default. 
 */

export const ConfigureSAMLAuthenticationRequestIdpBindingPreferred = {
    Post: 'post',
    Redirect: 'redirect'
} as const;

export type ConfigureSAMLAuthenticationRequestIdpBindingPreferred = typeof ConfigureSAMLAuthenticationRequestIdpBindingPreferred[keyof typeof ConfigureSAMLAuthenticationRequestIdpBindingPreferred];


/**
 * Defines how SAML attributes from the IdP should be mapped to ShellHub user attributes. 
 */
export interface ConfigureSAMLAuthenticationRequestIdpMappings {
    /**
     * The name of the SAML attribute that contains the user\'s email address. This attribute will be used to identify and authenticate users in ShellHub. For example, if your IdP sends the email in a SAML attribute named \"mail\", set this value to \"mail\". 
     */
    'email'?: string;
    /**
     * The name of the SAML attribute that contains the user\'s display name. This attribute will be used as the user\'s name in ShellHub. For example, if your IdP sends the user\'s name in a SAML attribute  named \"displayName\", set this value to \"displayName\". 
     */
    'name'?: string;
}
/**
 * Configuration settings for how ShellHub will function as a Service Provider (SP).
 */
export interface ConfigureSAMLAuthenticationRequestSp {
    /**
     * Indicates whether ShellHub should sign authentication requests.  If `true`, ShellHub will generate a public X509 certificate that must be deployed on the IdP for validation.  The IdP-initiated workflow is not supported when this option is enabled. 
     */
    'sign_requests'?: boolean;
}
export interface Connector {
    /**
     * Connector\'s UID
     */
    'uid'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Connector\'s connection is enabled.
     */
    'enable'?: boolean;
    /**
     * Address to the Container Engine.
     */
    'address'?: string;
    /**
     * Port to the Container Engine.
     */
    'port'?: number;
    /**
     * onnector\'s connection is using HTTPS for authentication.
     */
    'secure'?: boolean;
    'status'?: ConnectorStatus;
    'tls'?: ConnectorTLS;
}
export interface ConnectorData {
    /**
     * Connector\'s connection is enabled.
     */
    'enable'?: boolean;
    /**
     * Address to the Container Engine.
     */
    'address'?: string;
    /**
     * Port to the Container Engine.
     */
    'port'?: number;
    /**
     * onnector\'s connection is using HTTPS for authentication.
     */
    'secure'?: boolean;
    'tls'?: ConnectorTLS;
}
export interface ConnectorInfo200Response {
    'ID'?: string;
    'Containers'?: number;
    'ContainersRunning'?: number;
    'ContainersPaused'?: number;
    'ContainersStopped'?: number;
    'Images'?: number;
    'Driver'?: string;
    'DriverStatus'?: Array<Array<string>>;
    'Plugins'?: ConnectorInfo200ResponsePlugins;
    'MemoryLimit'?: boolean;
    'SwapLimit'?: boolean;
    'CpuCfsPeriod'?: boolean;
    'CpuCfsQuota'?: boolean;
    'CPUShares'?: boolean;
    'CPUSet'?: boolean;
    'PidsLimit'?: boolean;
    'IPv4Forwarding'?: boolean;
    'BridgeNfIptables'?: boolean;
    'BridgeNfIp6tables'?: boolean;
    'Debug'?: boolean;
    'NFd'?: number;
    'OomKillDisable'?: boolean;
    'NGoroutines'?: number;
    'SystemTime'?: string;
    'LoggingDriver'?: string;
    'CgroupDriver'?: string;
    'CgroupVersion'?: string;
    'NEventsListener'?: number;
    'KernelVersion'?: string;
    'OperatingSystem'?: string;
    'OSVersion'?: string;
    'OSType'?: string;
    'Architecture'?: string;
    'IndexServerAddress'?: string;
    'RegistryConfig'?: ConnectorInfo200ResponseRegistryConfig;
    'NCPU'?: number;
    'MemTotal'?: number;
    'GenericResources'?: Array<string | null>;
    'DockerRootDir'?: string;
    'HttpProxy'?: string;
    'HttpsProxy'?: string;
    'NoProxy'?: string;
    'Name'?: string;
    'Labels'?: Array<string>;
    'ExperimentalBuild'?: boolean;
    'ServerVersion'?: string;
    'Runtimes'?: ConnectorInfo200ResponseRuntimes;
    'DefaultRuntime'?: string;
    'Swarm'?: ConnectorInfo200ResponseSwarm;
    'LiveRestoreEnabled'?: boolean;
    'Isolation'?: string;
    'InitBinary'?: string;
    'ContainerdCommit'?: ConnectorInfo200ResponseContainerdCommit;
    'RuncCommit'?: ConnectorInfo200ResponseContainerdCommit;
    'InitCommit'?: ConnectorInfo200ResponseContainerdCommit;
    'SecurityOptions'?: Array<string>;
    'CDISpecDirs'?: Array<string>;
    'Warnings'?: Array<string>;
}
export interface ConnectorInfo200ResponseContainerdCommit {
    'ID'?: string;
    'Expected'?: string;
}
export interface ConnectorInfo200ResponsePlugins {
    'Volume'?: Array<string>;
    'Network'?: Array<string>;
    'Authorization'?: Array<string | null>;
    'Log'?: Array<string>;
}
export interface ConnectorInfo200ResponseRegistryConfig {
    'AllowNondistributableArtifactsCIDRs'?: Array<string | null>;
    'AllowNondistributableArtifactsHostnames'?: Array<string | null>;
    'InsecureRegistryCIDRs'?: Array<string>;
    'IndexConfigs'?: ConnectorInfo200ResponseRegistryConfigIndexConfigs;
    'Mirrors'?: Array<string>;
}
export interface ConnectorInfo200ResponseRegistryConfigIndexConfigs {
    'docker.io'?: ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo;
}
export interface ConnectorInfo200ResponseRegistryConfigIndexConfigsDockerIo {
    'Name'?: string;
    'Mirrors'?: Array<string>;
    'Secure'?: boolean;
    'Official'?: boolean;
}
export interface ConnectorInfo200ResponseRuntimes {
    'io.containerd.runc.v2'?: ConnectorInfo200ResponseRuntimesIoContainerdRuncV2;
    'runc'?: ConnectorInfo200ResponseRuntimesIoContainerdRuncV2;
}
export interface ConnectorInfo200ResponseRuntimesIoContainerdRuncV2 {
    'path'?: string;
    'status'?: { [key: string]: string; };
}
export interface ConnectorInfo200ResponseSwarm {
    'NodeID'?: string;
    'NodeAddr'?: string;
    'LocalNodeState'?: string;
    'ControlAvailable'?: boolean;
    'Error'?: string;
    'RemoteManagers'?: Array<string | null>;
}
export interface ConnectorStatus {
    /**
     * Connector\'s connetion state type.
     */
    'State'?: boolean;
    /**
     * Connector\'s connetion status message.
     */
    'Message'?: string;
}
export interface ConnectorTLS {
    /**
     * Certificate Authority used to generate the Cert for the server and the client.
     */
    'ca': string;
    /**
     * Certificate generated from the CA certificate and used by the client to authorize the connection to the Docker Engine.
     */
    'cert': string;
    /**
     * Private key for the certificate on the Cert field.
     */
    'key': string;
}
export interface CreateAnnouncementRequest {
    /**
     * Announcement title.
     */
    'title'?: string;
    /**
     * Announcement description.
     */
    'content'?: string;
}
export interface CreateNamespaceRequest {
    /**
     * Namespace\'s name
     */
    'name': string;
}
export interface CreatePublicKey200Response {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     */
    'fingerprint'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     */
    'name'?: string;
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     */
    'username'?: string;
}
export interface CreateTagRequest {
    'name': string;
}
export interface CreateTunnelRequest {
    /**
     * Tunnel\'s agent host address
     */
    'host': string;
    /**
     * Tunnel\'s agent port number
     */
    'port': number;
    /**
     * Tunnel\'s time to live in seconds
     */
    'ttl': number;
}
export interface CreateWebEndpointRequest {
    /**
     * Device\'s UID
     */
    'uid': string;
    /**
     * Web endpoint\'s agent host address
     */
    'host': string;
    /**
     * Web endpoint\'s agent port number
     */
    'port': number;
    /**
     * Web endpoint\'s time to live in seconds
     */
    'ttl': number;
}
export interface Device {
    /**
     * Device\'s UID
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     */
    'name'?: string;
    'identity'?: DeviceIdentity;
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     */
    'namespace'?: string;
    'status'?: DeviceStatus;
    /**
     * Device\'s status update date
     */
    'status_update_at'?: string;
    /**
     * Device\'s creation date
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     */
    'remote_addr'?: string;
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     */
    'tags'?: Array<Tag>;
    /**
     * Device\'s public URL status.
     */
    'public_url'?: boolean;
    /**
     * Device\'s acceptable  The value \"acceptable\" is based on the number of devices removed and already accepted into a namespace. All devices are \"acceptable\" unless the \"namespace.max_devices\" is reached. This limit is set based on the sum up of accepted and removed devices into the namespace. When this limit is reached, only removed devices between 720 hours or 30 days are set to \"acceptable\". 
     */
    'acceptable'?: boolean;
}


/**
 * Device\'s identity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     */
    'mac'?: string;
}
/**
 * Device\'s info
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     */
    'arch'?: string;
    'platform'?: DeviceInfoPlatform;
}


/**
 * Device\'s OS platform
 */

export const DeviceInfoPlatform = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatform = typeof DeviceInfoPlatform[keyof typeof DeviceInfoPlatform];


/**
 * Device\'s geolocation position
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Removed: 'removed',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


export interface EditNamespaceRequest {
    /**
     * Namespace\'s name
     */
    'name'?: string;
    'settings'?: NamespaceSettings;
}
export interface Evaluate200Response {
    /**
     * Namespaces\'s acceptance status.
     */
    'can_accept'?: boolean;
    /**
     * Namespace\'s connection status.
     */
    'can_connect'?: boolean;
}
export interface FirewallRulesRequest {
    'action': FirewallRulesResponseAction;
    /**
     * Firewall rule active\'s status
     */
    'active': boolean;
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     */
    'username': string;
}


export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id': string;
    'action': FirewallRulesResponseAction;
    /**
     * Firewall rule active\'s status
     */
    'active': boolean;
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     */
    'username': string;
}


/**
 * Firewall rule\'s action
 */

export const FirewallRulesResponseAction = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseAction = typeof FirewallRulesResponseAction[keyof typeof FirewallRulesResponseAction];


/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     */
    'hostname': string;
}
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     */
    'tags': Array<Tag>;
}
export interface GenerateInvitationLink200Response {
    /**
     * The invitation link.
     */
    'link'?: string;
}
export interface GetAuthenticationSettings200Response {
    'local'?: GetAuthenticationSettings200ResponseLocal;
    'saml'?: GetAuthenticationSettings200ResponseSaml;
}
export interface GetAuthenticationSettings200ResponseLocal {
    /**
     * Indicates whether local authentication is active.
     */
    'enabled'?: boolean;
}
export interface GetAuthenticationSettings200ResponseSaml {
    /**
     * Indicates whether SAML authentication is active.
     */
    'enabled'?: boolean;
    /**
     * The URL used to authenticate the SAML user.
     */
    'auth_url'?: string;
    /**
     * The URL where the IdP must permit redirects.
     */
    'assertion_url'?: string;
    'idp'?: GetAuthenticationSettings200ResponseSamlIdp;
    'sp'?: GetAuthenticationSettings200ResponseSamlSp;
}
export interface GetAuthenticationSettings200ResponseSamlIdp {
    /**
     * The Entity ID of the IdP.
     */
    'entity_id'?: string;
    /**
     * The list of public X509 certificates of the IdP.
     */
    'certificates'?: Array<string>;
    'binding'?: GetAuthenticationSettings200ResponseSamlIdpBinding;
    'mappings'?: GetAuthenticationSettings200ResponseSamlIdpMappings;
}
/**
 * Configuration for SAML binding methods that define how authentication requests  and responses are transmitted between ShellHub and the IdP. 
 */
export interface GetAuthenticationSettings200ResponseSamlIdpBinding {
    /**
     * The Single Sign-On URL for HTTP-POST binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-POST method. 
     */
    'post'?: string;
    /**
     * The Single Sign-On URL for HTTP-Redirect binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-Redirect method. 
     */
    'redirect'?: string;
    'preferred'?: GetAuthenticationSettings200ResponseSamlIdpBindingPreferred;
}


/**
 * Specifies which binding method ShellHub prefers when both POST and  Redirect bindings are available. If left blank or empty, POST binding is preferred. 
 */

export const GetAuthenticationSettings200ResponseSamlIdpBindingPreferred = {
    Post: 'post',
    Redirect: 'redirect'
} as const;

export type GetAuthenticationSettings200ResponseSamlIdpBindingPreferred = typeof GetAuthenticationSettings200ResponseSamlIdpBindingPreferred[keyof typeof GetAuthenticationSettings200ResponseSamlIdpBindingPreferred];


export interface GetAuthenticationSettings200ResponseSamlIdpMappings {
    'email'?: string;
    'name'?: string;
}
export interface GetAuthenticationSettings200ResponseSamlSp {
    /**
     * Indicates whether ShellHub signs authentication requests.
     */
    'sign_requests'?: boolean;
}
/**
 * Container\'s list order
 */

export const GetContainersOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type GetContainersOrderByParameter = typeof GetContainersOrderByParameter[keyof typeof GetContainersOrderByParameter];


export interface GetCustomer200Response {
    /**
     * Customer\'s ID.
     */
    'id'?: string;
    /**
     * Customer\'s name.
     */
    'name'?: string;
    /**
     * Customer\'s e-mail.
     */
    'email'?: string;
    /**
     * Customer\'s payment methods.
     */
    'payment_methods'?: Array<GetCustomer200ResponsePaymentMethodsInner>;
}
export interface GetCustomer200ResponsePaymentMethodsInner {
    /**
     * Payment method\'s ID.
     */
    'id'?: string;
    /**
     * Payment method card\'s number.
     */
    'number'?: string;
    /**
     * Payment method card\'s brand.
     */
    'brand'?: string;
    /**
     * Payment method card\'s expiration month.
     */
    'exp_month'?: number;
    /**
     * Payment method card\'s expiration year.
     */
    'exp_year'?: number;
    /**
     * Payment method card\'s CVC.
     */
    'cvc'?: string;
    /**
     * Payment method default status.
     */
    'default'?: boolean;
}
/**
 * @type GetCustomer400Response
 */
export type GetCustomer400Response = GetCustomer400ResponseOneOf | RecordSession422Response;

export interface GetCustomer400ResponseOneOf {
    /**
     * Error\'s message.
     */
    'message'?: string;
    /**
     * Error\'s code.
     */
    'code'?: string;
}
/**
 * Device\'s list order
 */

export const GetDevicesAdminOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type GetDevicesAdminOrderByParameter = typeof GetDevicesAdminOrderByParameter[keyof typeof GetDevicesAdminOrderByParameter];


/**
 * Device\'s list order
 */

export const GetDevicesOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type GetDevicesOrderByParameter = typeof GetDevicesOrderByParameter[keyof typeof GetDevicesOrderByParameter];


export interface GetInfo500Response {
    /**
     * Error message.
     */
    'message'?: string;
}
export interface GetLicense200Response {
    /**
     * License\'s ID
     */
    'id': string;
    /**
     * License\'s expired status
     */
    'expired': boolean;
    /**
     * License\'s about to expire status
     */
    'about_to_expire': boolean;
    /**
     * License\'s grace period status
     */
    'grace_period': boolean;
    /**
     * License\'s issued at  It is the number of seconds elapsed since January 1, 1970 UTC.
     */
    'issued_at': number;
    /**
     * License\'s started at  It is the number of seconds elapsed since January 1, 1970 UTC.
     */
    'starts_at': number;
    /**
     * License\'s expired at  It is the number of seconds elapsed since January 1, 1970 UTC.  `-1` means license does not expire
     */
    'expires_at': number;
    /**
     * License\'s allowed regions  It is a list of regions in `ISO 3166-1 alpha-2` format.
     */
    'allowed_regions': Array<GetLicense200ResponseAllowedRegionsInner>;
    'customer': GetLicense200ResponseCustomer;
    'features': GetLicense200ResponseFeatures;
}
/**
 * License\'s allowed regions
 */

export const GetLicense200ResponseAllowedRegionsInner = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    Ao: 'AO',
    Aq: 'AQ',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Ax: 'AX',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bl: 'BL',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Bq: 'BQ',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bv: 'BV',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cc: 'CC',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cw: 'CW',
    Cx: 'CX',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Eh: 'EH',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gs: 'GS',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hm: 'HM',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    Im: 'IM',
    In: 'IN',
    Io: 'IO',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mf: 'MF',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Nf: 'NF',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pm: 'PM',
    Pn: 'PN',
    Pr: 'PR',
    Ps: 'PS',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sj: 'SJ',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sx: 'SX',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tf: 'TF',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tk: 'TK',
    Tm: 'TM',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Um: 'UM',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Wf: 'WF',
    Ws: 'WS',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type GetLicense200ResponseAllowedRegionsInner = typeof GetLicense200ResponseAllowedRegionsInner[keyof typeof GetLicense200ResponseAllowedRegionsInner];


/**
 * License\'s customer
 */
export interface GetLicense200ResponseCustomer {
    /**
     * Customer\'s ID
     */
    'id'?: string;
    /**
     * Customer\'s name
     */
    'name'?: string;
    /**
     * Customer\'s email
     */
    'email'?: string;
    /**
     * Customer\'s company
     */
    'company'?: string;
}
/**
 * License\'s features
 */
export interface GetLicense200ResponseFeatures {
    /**
     * Number of devices allowed   `-1` means unlimited number of devices and any other number means the number of devices allowed 
     */
    'devices': number;
    /**
     * Session recording status
     */
    'session_recording': boolean;
    /**
     * Firewall rules status
     */
    'firewall_rules': boolean;
    /**
     * Reports status
     */
    'reports': boolean;
    /**
     * Login link status
     */
    'login_link': boolean;
    /**
     * Billing status
     */
    'billing': boolean;
}
export interface GetSamlAuthUrl200Response {
    /**
     * The complete URL to the Identity Provider\'s login page
     */
    'url': string;
}
export interface GetStats200Response {
    /**
     * Number of registered users.
     */
    'registered_users'?: number;
    /**
     * Number of registered devices.
     */
    'registered_devices'?: number;
    /**
     * Number of online devices.
     */
    'online_devices'?: number;
    /**
     * Number of active sessions.
     */
    'active_sessions'?: number;
    /**
     * Number of pending devices.
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices.
     */
    'rejected_devices'?: number;
}
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     */
    'active_sessions'?: number;
}
export interface GetSubscription200Response {
    /**
     * Subscription\'s ID.
     */
    'id'?: string;
    /**
     * Subscription\'s active.
     */
    'active'?: boolean;
    'status'?: GetSubscription200ResponseStatus;
    /**
     * Subscription\'s current period end.
     */
    'end_at'?: number;
    /**
     * Subscription\'s invoices.
     */
    'invoices'?: Array<GetSubscription200ResponseInvoicesInner>;
}


export interface GetSubscription200ResponseInvoicesInner {
    /**
     * Invoice\'s ID.
     */
    'id'?: string;
    'status'?: GetSubscription200ResponseInvoicesInnerStatus;
    'currency'?: GetSubscription200ResponseInvoicesInnerCurrency;
    /**
     * Invoice\'s amount in cents.
     */
    'amount'?: number;
}


/**
 * Invoice\'s currency.
 */

export const GetSubscription200ResponseInvoicesInnerCurrency = {
    Usd: 'usd',
    Brl: 'brl'
} as const;

export type GetSubscription200ResponseInvoicesInnerCurrency = typeof GetSubscription200ResponseInvoicesInnerCurrency[keyof typeof GetSubscription200ResponseInvoicesInnerCurrency];


/**
 * Invoice\'s status.
 */

export const GetSubscription200ResponseInvoicesInnerStatus = {
    Draft: 'draft',
    Open: 'open',
    Paid: 'paid',
    Uncollectible: 'uncollectible',
    Voided: 'voided'
} as const;

export type GetSubscription200ResponseInvoicesInnerStatus = typeof GetSubscription200ResponseInvoicesInnerStatus[keyof typeof GetSubscription200ResponseInvoicesInnerStatus];


/**
 * Subscription\'s status.
 */

export const GetSubscription200ResponseStatus = {
    Inactive: 'inactive',
    Active: 'active',
    Trialing: 'trialing',
    Incomplete: 'incomplete',
    IncompleteExpired: 'incomplete_expired',
    PastDue: 'past_due',
    Canceled: 'canceled',
    Unpaid: 'unpaid',
    Paused: 'paused',
    ToCancelAtEndOfPeriod: 'to_cancel_at_end_of_period'
} as const;

export type GetSubscription200ResponseStatus = typeof GetSubscription200ResponseStatus[keyof typeof GetSubscription200ResponseStatus];


export interface GetUser200Response {
    'user'?: UserAdminResponse;
    /**
     * User\'s integer of owned namespaces
     */
    'namespacesOwned'?: number;
}
export interface GetUserInfo401Response {
    /**
     * Error message
     */
    'message'?: string;
}
export interface GetUserTokenAdmin200Response {
    /**
     * JWT Token
     */
    'token'?: string;
}
export interface Info {
    /**
     * The current version of ShellHub.
     */
    'version'?: string;
    'endpoints'?: InfoEndpoints;
    /**
     * Indicates whether the instance setup is complete.
     */
    'setup'?: boolean;
    'authentication'?: InfoAuthentication;
}
/**
 * Authentication methods available for the ShellHub instance.
 */
export interface InfoAuthentication {
    /**
     * Indicates if local authentication using email and password is enabled.
     */
    'local'?: boolean;
    /**
     * Indicates if SAML-based single sign-on (SSO) is enabled.
     */
    'saml'?: boolean;
}
/**
 * Network endpoints for the ShellHub instance.
 */
export interface InfoEndpoints {
    /**
     * The SSH endpoint where devices connect.
     */
    'ssh'?: string;
    /**
     * The API endpoint for managing ShellHub configurations.
     */
    'api'?: string;
}
/**
 * Announcements\' list order.
 */

export const ListAnnouncementsOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ListAnnouncementsOrderByParameter = typeof ListAnnouncementsOrderByParameter[keyof typeof ListAnnouncementsOrderByParameter];



export const ListWebEndpointsOrderByParameter = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ListWebEndpointsOrderByParameter = typeof ListWebEndpointsOrderByParameter[keyof typeof ListWebEndpointsOrderByParameter];



export const ListWebEndpointsSortByParameter = {
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at',
    Address: 'address',
    Uid: 'uid'
} as const;

export type ListWebEndpointsSortByParameter = typeof ListWebEndpointsSortByParameter[keyof typeof ListWebEndpointsSortByParameter];


export interface LoginAdmin200Response {
    /**
     * JWT token
     */
    'token'?: string;
    /**
     * username
     */
    'user'?: string;
}
export interface LoginAdminRequest {
    /**
     * Admin\'s username
     */
    'username': string;
    /**
     * Admin\'s password
     */
    'password': string;
}
export interface LoginRequest {
    /**
     * User\'s username.
     */
    'username': string;
    /**
     * User\'s password.
     */
    'password': string;
}
export interface LookupUserStatus200Response {
    'status'?: string;
}
export interface MfaAuth {
    /**
     * The `X-MFA-Token` header returned by the authUser endpoint.
     */
    'token': string;
    /**
     * The current code from the MFA authenticator.
     */
    'code': string;
}
export interface MfaDisable {
    /**
     * The code generated by the MFA app.
     */
    'code'?: string;
    /**
     * User\'s recovery code.
     */
    'recovery_code'?: string;
}
export interface MfaEnable {
    /**
     * The code generated by the MFA app.
     */
    'code': string;
    /**
     * The secret generated by generateMFA endpoint.
     */
    'secret': string;
    /**
     * A list of codes generated by generateMFA endpoint. These codes can be used when a user loses their MFA app. 
     */
    'recovery_codes': Array<string>;
}
export interface MfaGenerate {
    /**
     * The link to establish a connection with the OTP server.
     */
    'link'?: string;
    /**
     * A secret key to authenticate with the OTP server.
     */
    'secret'?: string;
    /**
     * A list of recovery codes to use when the user loses access to their MFA app.
     */
    'recovery_codes'?: Array<string>;
}
export interface MfaRecover {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     */
    'identifier': string;
    /**
     * One of the user\'s recovery codes.
     */
    'recovery_code': string;
}
export interface MfaReset {
    /**
     * The code sent to the main email address.
     */
    'main_email_code': string;
    /**
     * The code sent to the recovery email address.
     */
    'recovery_email_code': string;
}
export interface Namespace {
    /**
     * Namespace\'s name
     */
    'name'?: string;
    /**
     * User\'s ID.
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     */
    'members'?: Array<NamespaceMembersInner>;
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     */
    'billing'?: object;
    /**
     * Number of devices currently in pending status awaiting approval
     */
    'devices_pending_count'?: number;
    /**
     * Number of devices that have been accepted and are active in the namespace
     */
    'devices_accepted_count'?: number;
    /**
     * Number of devices that have been explicitly rejected from the namespace
     */
    'devices_rejected_count'?: number;
}
/**
 * Namespace\'s member role
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     */
    'id'?: string;
    /**
     * The time when the member was invited.
     */
    'added_at'?: string;
    /**
     * **NOTE: ONLY USED IN CLOUD INSTANCE.**  The time when the invite expires. If the member is not in `pending` status, this will be set to the zero UTC time. 
     */
    'expires_at'?: string;
    'role'?: NamespaceMemberRole;
    'type'?: NamespaceMembersInnerType;
    'status'?: NamespaceMembersInnerStatus;
    /**
     * Member\'s email.
     */
    'email'?: string;
}



export const NamespaceMembersInnerStatus = {
    Accepted: 'accepted',
    Pending: 'pending'
} as const;

export type NamespaceMembersInnerStatus = typeof NamespaceMembersInnerStatus[keyof typeof NamespaceMembersInnerStatus];


/**
 * this field, on majority of cases is default \'personal\', if the running instance of shellhub is cloud, the default value is \'team\'.  This field requires a valid input of either \'personal\' or \'team\'. the default will match the current Shellhub instance type. When a \"type\" field value is specified, it will override the default, but must be either \'personal\' or \'team\'. Any other input will be rejected. 
 */

export const NamespaceMembersInnerType = {
    Personal: 'personal',
    Team: 'team'
} as const;

export type NamespaceMembersInnerType = typeof NamespaceMembersInnerType[keyof typeof NamespaceMembersInnerType];


/**
 * Namespace\'s settings.
 */
export interface NamespaceSettings {
    /**
     * The session records define when the namespace should save or not record a session. This can be used to check logged activity when connecting to a device.
     */
    'session_record'?: boolean;
    /**
     * A connection announcement is a custom string written during a session when a connection is established on a device within the namespace.
     */
    'connection_announcement'?: string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags. 
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     */
    'hostname': string;
}
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     */
    'tags': Set<Tag>;
}
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     */
    'data': string;
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     */
    'username': string;
}
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     */
    'name'?: string;
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     */
    'username'?: string;
}
export interface RecordSession422Response {
    /**
     * Error\'s message.
     */
    'message'?: string;
}
export interface RecordSessionRequest {
    /**
     * Session\'s UID.
     */
    'uid': string;
    /**
     * Session\'s Seat
     */
    'seat': number;
    /**
     * Session\'s data.
     */
    'message': string;
    /**
     * Session\'s pty width.
     */
    'width': number;
    /**
     * Session\'s pty height.
     */
    'height': number;
}
export interface RecordedSessionResponseInner {
    /**
     * Session\'s ID
     */
    'uid': string;
    /**
     * Session\'s Seat
     */
    'seat': number;
    /**
     * Session\'s Data
     */
    'message': string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id': string;
    /**
     * Session\'s time
     */
    'time': string;
    /**
     * Session\'s terminal width
     */
    'width': number;
    /**
     * Session\'s terminal height
     */
    'height': number;
}
export interface RecoverPasswordRequest {
    'username': RecoverPasswordRequestUsername;
}
/**
 * @type RecoverPasswordRequestUsername
 */
export type RecoverPasswordRequestUsername = string;

export interface RegisterUserRequest {
    /**
     * The full name of the user.
     */
    'name': string;
    /**
     * The user\'s email address, which must be unique. This email will be used for login and for receiving important notifications, such as password reset emails. If `email_marketing` is set to `true`, promotional emails will also be sent to this address. 
     */
    'email': string;
    /**
     * The username, which must be unique across the system. Users can log in using either their username or email. 
     */
    'username': string;
    /**
     * The password for the user account. Must follow the regex. 
     */
    'password': string;
    /**
     * Indicates whether the user opts to receive marketing and promotional emails. 
     */
    'email_marketing': boolean;
    /**
     * **For standard registration processes, this field should be ignored.**   A unique signature included in an invitation email. This is used to automatically confirm the user\'s registration without requiring an additional confirmation email. 
     */
    'sig'?: string;
}

export const ReportActionParameter = {
    DeviceAccept: 'device_accept',
    NamespaceDelete: 'namespace_delete'
} as const;

export type ReportActionParameter = typeof ReportActionParameter[keyof typeof ReportActionParameter];


export interface RequestResetMFARequest {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     */
    'identifier': string;
}
export interface ResendEmailRequest {
    /**
     * User\'s username.
     */
    'username': string;
}
export interface ResolveDevice404Response {
    'message'?: string;
}
export interface Session {
    /**
     * Session\'s UID
     */
    'uid'?: string;
    /**
     * Device\'s UID
     */
    'device_uid'?: string;
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     */
    'username'?: string;
    /**
     * Session\'s IP address
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     */
    'recorded'?: boolean;
    'type'?: SessionType;
    /**
     * Session\'s terminal
     */
    'term'?: string;
    'position'?: SessionPosition;
    'events'?: SessionEvents;
}


/**
 * Session\'s events
 */
export interface SessionEvents {
    /**
     * Session\'s set of types
     */
    'types'?: Array<string>;
    /**
     * Session\'s seats
     */
    'seats'?: Array<number>;
    /**
     * Session\'s list of events
     */
    'items'?: Array<SessionEventsItemsInner>;
}
export interface SessionEventsItemsInner {
    /**
     * The type of the event
     */
    'type'?: string;
    /**
     * The time the event occurred in ISO 8601 format
     */
    'timestamp'?: string;
    /**
     * Additional data related to the event
     */
    'data'?: object;
    /**
     * Seat where the event happened
     */
    'seat'?: number;
}
/**
 * Session\'s geolocation position
 */
export interface SessionPosition {
    /**
     * Session\'s latitude position
     */
    'latitude'?: number;
    /**
     * Session\'s longitude position
     */
    'longitude'?: number;
}
/**
 * Session\'s type
 */

export const SessionType = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionType = typeof SessionType[keyof typeof SessionType];


export interface SetSessionAuthenticationStatusRequest {
    /**
     * Session\'s authentication status.
     */
    'authenticated'?: boolean;
}
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     */
    'session_record'?: boolean;
}
export interface SetupRequest {
    /**
     * User\'s name.
     */
    'name': string;
    /**
     * User\'s E-mail.
     */
    'email': string;
    /**
     * User\'s username.
     */
    'username': string;
    /**
     * User\'s password.
     */
    'password': string;
}
export interface Support {
    /**
     * Support identifier.
     */
    'identifier'?: string;
}
/**
 * A tag represents a label or category that can be attached to devices, firewall rules and public keys for organization and filtering purposes. 
 */
export interface Tag {
    /**
     * The display name of the tag
     */
    'name'?: string;
}
export interface Tunnel {
    /**
     * Tunnel\'s unique address
     */
    'address'?: string;
    /**
     * Full tunnel address including domain
     */
    'full_address'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'namespace'?: string;
    /**
     * Device\'s UID
     */
    'device'?: string;
    /**
     * Tunnel\'s agent host address
     */
    'host'?: string;
    /**
     * Tunnel\'s agent port number
     */
    'port'?: number;
    /**
     * Tunnel\'s time to live in seconds
     */
    'ttl'?: number;
    /**
     * Tunnel\'s expiration date
     */
    'expires_in'?: string;
    /**
     * Tunnel\'s creation date
     */
    'created_at'?: string;
}
export interface UpdateDeviceNameAdminRequest {
    /**
     * Device\'s new name.
     */
    'name': string;
}
export interface UpdateDeviceRequest {
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     */
    'name'?: string;
    /**
     * Device\'s public URL status.
     */
    'public_url'?: boolean;
}

export const UpdateDeviceStatusStatusParameter = {
    Accept: 'accept',
    Reject: 'reject',
    Pending: 'pending',
    Unused: 'unused'
} as const;

export type UpdateDeviceStatusStatusParameter = typeof UpdateDeviceStatusStatusParameter[keyof typeof UpdateDeviceStatusStatusParameter];


export interface UpdateNamespaceMemberRequest {
    'role'?: NamespaceMemberRole;
}


export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     */
    'name': string;
    /**
     * Public key\'s username.
     */
    'username': string;
    'filter': PublicKeyFilter;
}
export interface UpdateRecoverPasswordRequest {
    /**
     * User\'s password.
     */
    'password': string;
    /**
     * User\'s recovery token.    It is the token from the email sent to user when the user request password reset. 
     */
    'token': string;
}
export interface UpdateTagRequest {
    /**
     * New tag name
     */
    'name': string;
}
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     */
    'name'?: string;
    /**
     * User\'s username.
     */
    'username'?: string;
    /**
     * User\'s e-mail.
     */
    'email'?: string;
    /**
     * User\'s recovery e-mail. A recovery email serves as the user\'s final recourse to regain access to their account. 
     */
    'recovery_email'?: string;
}
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     */
    'current_password'?: string;
    /**
     * User new password
     */
    'new_password'?: string;
}
export interface UpdateUserRequest {
    'name'?: string;
    'username'?: string;
    'email'?: string;
    /**
     * A recovery email serves as the user\'s final recourse to regain access to their account. It cannot be the same as the user\'s primary email. Once defined, it cannot be updated to an empty value. 
     */
    'recovery_email'?: string;
    'password'?: string;
    /**
     * It\'s required when updating the user\'s password. 
     */
    'current_password'?: string;
}
export interface UserAdminRequest {
    /**
     * User\'s name.
     */
    'name': string;
    /**
     * User\'s E-mail.
     */
    'email': string;
    /**
     * User\'s username.
     */
    'username': string;
    /**
     * User\'s password.
     */
    'password': string;
    /**
     * User\'s email confirmed.
     */
    'confirmed'?: boolean;
    /**
     * Indicates the maximum number of namespaces a user is allowed to create. If set to 0, the user is not permitted to create any namespaces. If set to -1, the user has no limit on the number of namespaces they can create.
     */
    'max_namespaces'?: number;
}
export interface UserAdminResponse {
    /**
     * User\'s ID.
     */
    'id'?: string;
    /**
     * User\'s integer of owned namespaces.
     */
    'namespaces'?: number;
    /**
     * User\'s confirmation.
     */
    'confirmed'?: boolean;
    /**
     * User\'s creating date.
     */
    'created_at'?: string;
    /**
     * User\'s last login date.
     */
    'last_login'?: string;
    /**
     * User\'s name.
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     */
    'email'?: string;
    /**
     * User\'s username.
     */
    'username'?: string;
    /**
     * User\'s hashed password.
     */
    'password'?: string;
}
export interface UserAuth {
    /**
     * JWT Token
     */
    'token'?: string;
    /**
     * User\'s ID.
     */
    'id'?: string;
    'origin'?: UserOrigin;
    /**
     * User\'s username.
     */
    'user'?: string;
    /**
     * User\'s name.
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     */
    'email'?: string;
    /**
     * The recovery email serves as the user\'s final recourse to regain access to their account. 
     */
    'recovery_email'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'tenant'?: string;
    'role'?: NamespaceMemberRole;
    /**
     * Indicates whether the user has MFA enabled.
     */
    'mfa'?: boolean;
    /**
     * Indicates the maximum number of namespaces a user is allowed to create. If set to 0, the user is not permitted to create any namespaces. If set to -1, the user has no limit on the number of namespaces they can create.
     */
    'max_namespaces'?: number;
}


/**
 * Specifies the method the user employed to register with ShellHub.
 */

export const UserOrigin = {
    Local: 'local'
} as const;

export type UserOrigin = typeof UserOrigin[keyof typeof UserOrigin];


export interface Webendpoint {
    /**
     * Web endpoint\'s unique address
     */
    'address'?: string;
    /**
     * Full webendpoint address including domain
     */
    'full_address'?: string;
    /**
     * Namespace\'s tenant ID
     */
    'namespace'?: string;
    /**
     * Device\'s UID
     */
    'device_uid'?: string;
    'device'?: Device;
    /**
     * Web endpoint\'s agent host address
     */
    'host'?: string;
    /**
     * Web endpoint\'s agent port number
     */
    'port'?: number;
    /**
     * Web endpoint\'s time to live in seconds
     */
    'ttl'?: number;
    /**
     * Web endpoint\'s expiration date
     */
    'expires_in'?: string;
    /**
     * Web endpoint\'s creation date
     */
    'created_at'?: string;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminResetUserPassword', 'id', id)
            const localVarPath = `/admin/api/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication: async (configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureLocalAuthenticationRequest' is not null or undefined
            assertParamExists('configureLocalAuthentication', 'configureLocalAuthenticationRequest', configureLocalAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureLocalAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication: async (configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureSAMLAuthenticationRequest' is not null or undefined
            assertParamExists('configureSAMLAuthentication', 'configureSAMLAuthenticationRequest', configureSAMLAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureSAMLAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncementAdmin', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin: async (page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin: async (loginAdminRequest?: LoginAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminResetUserPassword(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminResetUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(id, userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLocalAuthentication(configureLocalAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.configureLocalAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.configureSAMLAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.editNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.exportNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.exportUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementAdmin(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getAnnouncementAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticationSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticationSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getAuthenticationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getDevicesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getFirewallRulesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getNamespacesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getSessionAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getSessionsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUserTokenAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncementsAdmin(page, perPage, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listAnnouncementsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAdmin(loginAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.loginAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.sendLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.setSessionAuthenticationStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(uuid, createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateDeviceNameAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateDeviceStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminDeleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminResetUserPassword200Response> {
            return localVarFp.adminResetUserPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminUpdateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.deleteAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncementAdmin(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings(options?: RawAxiosRequestConfig): AxiosPromise<GetAuthenticationSettings200Response> {
            return localVarFp.getAuthenticationSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: RawAxiosRequestConfig): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: RawAxiosRequestConfig): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginAdmin200Response> {
            return localVarFp.loginAdmin(loginAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDeleteUser(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
     * @summary Reset user password
     * @param {string} id The ID of the user whose password needs to be reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminResetUserPassword(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminResetUserPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure local authentication settings for the ShellHub instance.
     * @summary Configure Local Authentication
     * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
     * @summary Configure SAML Authentication
     * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an announcement.
     * @summary Create an announcement
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createAnnouncement(createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an announcement.
     * @summary Delete an announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAnnouncementAdmin(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current authentication settings.
     * @summary Get Authentication Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthenticationSettings(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAuthenticationSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {GetDevicesAdminOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicense(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListAnnouncementsOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login on Admin
     * @summary Login on Admin
     * @param {LoginAdminRequest} [loginAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).loginAdmin(loginAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {File} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendLicense(file?: File, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an announcement.
     * @summary Update an announcement
     * @param {string} uuid 
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnnouncementsApi - axios parameter creator
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.getAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.listAnnouncements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnouncement(uuid: string, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListAnnouncementsOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeysApi - axios parameter creator
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyDelete', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key: string, apiKeyUpdate?: ApiKeyUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyUpdate', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.apiKeyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.apiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.apiKeyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.apiKeyUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyDelete(key: string, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ApiKeyListOrderByParameter} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} key 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationSettingsApi - axios parameter creator
 */
export const AuthenticationSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication: async (configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureLocalAuthenticationRequest' is not null or undefined
            assertParamExists('configureLocalAuthentication', 'configureLocalAuthenticationRequest', configureLocalAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureLocalAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication: async (configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureSAMLAuthenticationRequest' is not null or undefined
            assertParamExists('configureSAMLAuthentication', 'configureSAMLAuthenticationRequest', configureSAMLAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureSAMLAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationSettingsApi - functional programming interface
 */
export const AuthenticationSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLocalAuthentication(configureLocalAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationSettingsApi.configureLocalAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationSettingsApi.configureSAMLAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticationSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticationSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationSettingsApi.getAuthenticationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationSettingsApi - factory interface
 */
export const AuthenticationSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationSettingsApiFp(configuration)
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings(options?: RawAxiosRequestConfig): AxiosPromise<GetAuthenticationSettings200Response> {
            return localVarFp.getAuthenticationSettings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationSettingsApi - object-oriented interface
 */
export class AuthenticationSettingsApi extends BaseAPI {
    /**
     * Configure local authentication settings for the ShellHub instance.
     * @summary Configure Local Authentication
     * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
     * @summary Configure SAML Authentication
     * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current authentication settings.
     * @summary Get Authentication Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthenticationSettings(options?: RawAxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).getAuthenticationSettings(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: ReportActionParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.attachPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.choiceDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.detachPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.evaluate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getDevicesMostUsed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: ReportActionParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.report']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.setDefaultPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: RawAxiosRequestConfig): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: RawAxiosRequestConfig): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: RawAxiosRequestConfig): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: ReportActionParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 */
export class BillingApi extends BaseAPI {
    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustomer(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSubscription(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluate(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomer(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevicesMostUsed(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSubscription(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {ReportActionParameter} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public report(action: ReportActionParameter, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudApi - axios parameter creator
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate: async (connectorData: ConnectorData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorCreate', 'connectorData', connectorData)
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorDelete', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorGet', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorInfo', 'uid', uid)
            const localVarPath = `/api/connector/{uid}/info`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList: async (enable?: boolean, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (enable !== undefined) {
                localVarQueryParameter['enable'] = enable;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate: async (uid: string, connectorData: ConnectorData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorUpdate', 'uid', uid)
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorUpdate', 'connectorData', connectorData)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel: async (uid: string, createTunnelRequest: CreateTunnelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createTunnel', 'uid', uid)
            // verify required parameter 'createTunnelRequest' is not null or undefined
            assertParamExists('createTunnel', 'createTunnelRequest', createTunnelRequest)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTunnelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebEndpoint: async (createWebEndpointRequest: CreateWebEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebEndpointRequest' is not null or undefined
            assertParamExists('createWebEndpoint', 'createWebEndpointRequest', createWebEndpointRequest)
            const localVarPath = `/api/web-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebEndpointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord: async (uid: string, seat: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('deleteSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel: async (uid: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteTunnel', 'uid', uid)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteTunnel', 'address', address)
            const localVarPath = `/api/devices/{uid}/tunnels/{address}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebEndpoint: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteWebEndpoint', 'address', address)
            const localVarPath = `/api/web-endpoints/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('generateInvitationLink', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/invites`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncementAdmin', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceSupport', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/support`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/saml/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (uid: string, seat: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('getSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin: async (page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels: async (uid: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listTunnels', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebEndpoints: async (filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/web-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('recordSession', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest?: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: ReportActionParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.attachPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.authMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.choiceDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.clsoeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorCreate(connectorData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorInfo(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorInfo(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorList(enable, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorUpdate(uid, connectorData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.connectorUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tunnel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTunnel(uid, createTunnelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webendpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebEndpoint(createWebEndpointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createWebEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionRecord(uid, seat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunnel(uid, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebEndpoint(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.deleteWebEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.detachPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.disableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.enableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.evaluate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateInvitationLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInvitationLink(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.generateInvitationLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.generateMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementAdmin(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getAnnouncementAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getDevicesMostUsed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getFirewallRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Support>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceSupport(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getNamespaceSupport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamlAuthUrl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSamlAuthUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamlAuthUrl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getSamlAuthUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(uid, seat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getValidateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncementsAdmin(page, perPage, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listAnnouncementsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tunnel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunnels(uid, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listTunnels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webendpoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebEndpoints(filter, page, perPage, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listWebEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.mfaRecover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, seat, recordSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.recordSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.recoverPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: ReportActionParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.report']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.requestResetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.resendEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.resetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.setDefaultPaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(uuid, createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.updateAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.updateFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.updateRecoverPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudApi - factory interface
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorCreate(connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.connectorGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorInfo200Response> {
            return localVarFp.connectorInfo(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connector>> {
            return localVarFp.connectorList(enable, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorUpdate(uid, connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tunnel> {
            return localVarFp.createTunnel(uid, createTunnelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webendpoint> {
            return localVarFp.createWebEndpoint(createWebEndpointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.deleteAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTunnel(uid, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebEndpoint(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: RawAxiosRequestConfig): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateInvitationLink200Response> {
            return localVarFp.generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: RawAxiosRequestConfig): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncementAdmin(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: RawAxiosRequestConfig): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Support> {
            return localVarFp.getNamespaceSupport(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl(options?: RawAxiosRequestConfig): AxiosPromise<GetSamlAuthUrl200Response> {
            return localVarFp.getSamlAuthUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: RawAxiosRequestConfig): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tunnel>> {
            return localVarFp.listTunnels(uid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Webendpoint>> {
            return localVarFp.listWebEndpoints(filter, page, perPage, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.recordSession(uid, seat, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {ReportActionParameter} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: ReportActionParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 */
export class CloudApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new connector.
     * @summary Connector\'s create
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorCreate(connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a connector.
     * @summary Connector\'s delete
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorDelete(uid: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a connector.
     * @summary Connector\'s get
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorGet(uid: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the connector\'s connection docker info.
     * @summary Connector\'s get Docker info
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorInfo(uid: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorInfo(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connectors.
     * @summary Connector\'s list
     * @param {boolean} [enable] Enable status.
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorList(enable, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a connector settings.
     * @summary Connector\'s setting update
     * @param {string} uid Connector UID
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).connectorUpdate(uid, connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an announcement.
     * @summary Create an announcement
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createAnnouncement(createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustomer(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSubscription(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tunnel for a device.
     * @summary Create a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {CreateTunnelRequest} createTunnelRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createTunnel(uid, createTunnelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new web-endpoint for a device.
     * @summary Create a web-endpoint
     * @param {CreateWebEndpointRequest} createWebEndpointRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createWebEndpoint(createWebEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an announcement.
     * @summary Delete an announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFirewallRule(id: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a session record based on its seat.
     * @summary Delete session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tunnel for a specific device and port.
     * @summary Delete a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteTunnel(uid, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a web-endpoint by address.
     * @summary Delete a web-endpoint
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteWebEndpoint(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluate(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
     * @summary Generate an invitation link for a namespace member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateMFA(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getAnnouncementAdmin(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomer(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevicesMostUsed(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRule(id: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace support identifier.
     * @summary Get a namespace support identifier.
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getNamespaceSupport(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
     * @summary Get SAML authentication URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSamlAuthUrl(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSamlAuthUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session record based on its seat.
     * @summary Get session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSubscription(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListAnnouncementsOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tunnels per devices.
     * @summary List tunnels
     * @param {string} uid Device\&#39;s UID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listTunnels(uid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all web-endpoints in the namespace.
     * @summary List web-endpoints
     * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
     * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listWebEndpoints(filter, page, perPage, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {number} seat 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).recordSession(uid, seat, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterUserRequest} [registerUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {ReportActionParameter} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public report(action: ReportActionParameter, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an announcement.
     * @summary Update an announcement
     * @param {string} uuid 
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommunityApi - axios parameter creator
 */
export const CommunityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyDelete', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key: string, apiKeyUpdate?: ApiKeyUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyUpdate', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceRequest?: CreateNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (tenant: string, createTagRequest: CreateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createTag', 'tenant', tenant)
            // verify required parameter 'createTagRequest' is not null or undefined
            assertParamExists('createTag', 'createTagRequest', createTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tenant: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteTag', 'tenant', tenant)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteTag', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, editNamespaceRequest?: EditNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (tenant: string, filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getTags', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getToken', 'tenant', tenant)
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice: async (hostname?: string, uid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup: async (sign: string, setupRequest?: SetupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sign' is not null or undefined
            assertParamExists('setup', 'sign', sign)
            const localVarPath = `/api/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sign !== undefined) {
                localVarQueryParameter['sign'] = sign;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus: async (uid: string, status: UpdateDeviceStatusStatusParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainerStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateContainerStatus', 'status', status)
            const localVarPath = `/api/containers/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: UpdateDeviceStatusStatusParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tenant: string, name: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateTag', 'tenant', tenant)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateTag', 'name', name)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('updateTag', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword: async (id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPassword', 'id', id)
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunityApi - functional programming interface
 */
export const CommunityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommunityApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.acceptDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.addNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.apiKeyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.apiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.apiKeyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.apiKeyUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.authSSHPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.authUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.checkSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.createNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.createPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(tenant, createTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.deleteContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.deleteDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.deleteNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.deletePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tenant, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, editNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.editNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainers(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getContainers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getNamespaceToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getStatusDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(tenant, filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.getUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.leaveNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.listAnnouncements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromContainer(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.pullTagFromContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromDevice(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.pullTagFromDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToContainer(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.pushTagToContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToDevice(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.pushTagToDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.removeNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveDevice(hostname, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.resolveDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.setSessionAuthenticationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.setSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup(sign, setupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.setup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(uid, updateDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainerStatus(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateContainerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(uid, updateDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateDeviceStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateDeviceStatusOffline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updatePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tenant, name, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateUserData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunityApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommunityApi - factory interface
 */
export const CommunityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommunityApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTag(tenant, createTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(tenant, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, editNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: RawAxiosRequestConfig): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: RawAxiosRequestConfig): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.getTags(tenant, filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pullTagFromContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pullTagFromDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushTagToContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushTagToDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.resolveDevice(hostname, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setup(sign, setupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContainer(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContainerStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDevice(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.updateTag(tenant, name, updateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommunityApi - object-oriented interface
 */
export class CommunityApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptDevice(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyDelete(key: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ApiKeyListOrderByParameter} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} key 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkSessionRecord(options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).createNamespace(createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
     * @summary Create a new tag in the namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateTagRequest} createTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).createTag(tenant, createTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a container.
     * @summary Delete container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteContainer(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).deleteContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDevice(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a tag and all its associations
     * @summary Delete a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} name Tag name to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).deleteTag(tenant, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {EditNamespaceRequest} [editNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).editNamespace(tenant, editNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnouncement(uuid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a container.
     * @summary Get container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContainer(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of containers.
     * @summary Get containers
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Container\&#39;s status
     * @param {string} [sortBy] Container\&#39;s property to sort of
     * @param {GetContainersOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevice(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {GetDevicesOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about ShellHub instance like version, SSH and API addresses.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getInfo(agentVersion?: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSession(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusDevices(options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all tags associated with a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getTags(tenant, filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} tenant Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getToken(tenant: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserInfo(options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaveNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListAnnouncementsOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).pullTagFromContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).pullTagFromDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).pushTagToContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).pushTagToDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
     * @summary Resolve Device
     * @param {string} [hostname] The UID of the device
     * @param {string} [uid] The hostname of the device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).resolveDevice(hostname, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an user and create namespace with the same name as username
     * @summary User setup
     * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
     * @param {SetupRequest} [setupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).setup(sign, setupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s data.
     * @summary Update container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateContainer(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s status.
     * @summary Update container status
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateContainerStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s data.
     * @summary Update device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateDevice(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} name Current tag name
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateTag(tenant, name, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} id User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return CommunityApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus: async (uid: string, status: UpdateDeviceStatusStatusParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainerStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateContainerStatus', 'status', status)
            const localVarPath = `/api/containers/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.deleteContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.getContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainers(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.getContainers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(uid, updateDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.updateContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainerStatus(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.updateContainerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainersApi - factory interface
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {GetContainersOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContainer(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContainerStatus(uid, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 */
export class ContainersApi extends BaseAPI {
    /**
     * Delete a container.
     * @summary Delete container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteContainer(uid: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).deleteContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a container.
     * @summary Get container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContainer(uid: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of containers.
     * @summary Get containers
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Container\&#39;s status
     * @param {string} [sortBy] Container\&#39;s property to sort of
     * @param {GetContainersOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetContainersOrderByParameter, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s data.
     * @summary Update container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s status.
     * @summary Update container status
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceStatusStatusParameter} status Container\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateContainerStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainerStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel: async (uid: string, createTunnelRequest: CreateTunnelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createTunnel', 'uid', uid)
            // verify required parameter 'createTunnelRequest' is not null or undefined
            assertParamExists('createTunnel', 'createTunnelRequest', createTunnelRequest)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTunnelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel: async (uid: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteTunnel', 'uid', uid)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteTunnel', 'address', address)
            const localVarPath = `/api/devices/{uid}/tunnels/{address}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels: async (uid: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listTunnels', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice: async (hostname?: string, uid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: UpdateDeviceStatusStatusParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.acceptDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tunnel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTunnel(uid, createTunnelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.createTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.deleteDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.deleteDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunnel(uid, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.deleteTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.getDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.getDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.getDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.getDevicesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.getStatusDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tunnel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunnels(uid, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.listTunnels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveDevice(hostname, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.resolveDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(uid, updateDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDeviceNameAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDeviceStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDeviceStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.updateDeviceStatusOffline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tunnel> {
            return localVarFp.createTunnel(uid, createTunnelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTunnel(uid, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: RawAxiosRequestConfig): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tunnel>> {
            return localVarFp.listTunnels(uid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.resolveDevice(hostname, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDevice(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptDevice(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tunnel for a device.
     * @summary Create a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {CreateTunnelRequest} createTunnelRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createTunnel(uid, createTunnelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDevice(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tunnel for a specific device and port.
     * @summary Delete a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteTunnel(uid, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevice(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {GetDevicesOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesOrderByParameter, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {GetDevicesAdminOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusDevices(options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tunnels per devices.
     * @summary List tunnels
     * @param {string} uid Device\&#39;s UID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).listTunnels(uid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
     * @summary Resolve Device
     * @param {string} [hostname] The UID of the device
     * @param {string} [uid] The hostname of the device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resolveDevice(hostname?: string, uid?: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).resolveDevice(hostname, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s data.
     * @summary Update device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDevice(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceStatusStatusParameter} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatus(uid: string, status: UpdateDeviceStatusStatusParameter, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnterpriseApi - axios parameter creator
 */
export const EnterpriseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminResetUserPassword', 'id', id)
            const localVarPath = `/admin/api/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication: async (configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureLocalAuthenticationRequest' is not null or undefined
            assertParamExists('configureLocalAuthentication', 'configureLocalAuthenticationRequest', configureLocalAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureLocalAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication: async (configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureSAMLAuthenticationRequest' is not null or undefined
            assertParamExists('configureSAMLAuthentication', 'configureSAMLAuthenticationRequest', configureSAMLAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureSAMLAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin: async (publicKeyRequest?: PublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncementAdmin', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin: async (page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin: async (loginAdminRequest?: LoginAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnterpriseApi - functional programming interface
 */
export const EnterpriseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnterpriseApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.adminDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminResetUserPassword(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.adminResetUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(id, userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLocalAuthentication(configureLocalAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.configureLocalAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.configureSAMLAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKeyAdmin(publicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createPublicKeyAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.editNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.exportNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.exportUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementAdmin(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getAnnouncementAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticationSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticationSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getAuthenticationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getDeviceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getDevicesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getFirewallRulesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getNamespacesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeysAdmin(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getPublicKeysAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSessionAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSessionsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getUserTokenAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncementsAdmin(page, perPage, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listAnnouncementsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAdmin(loginAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.loginAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.sendLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.setSessionAuthenticationStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(uuid, createAnnouncementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateDeviceNameAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateDeviceStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnterpriseApi - factory interface
 */
export const EnterpriseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnterpriseApiFp(configuration)
    return {
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminDeleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminResetUserPassword200Response> {
            return localVarFp.adminResetUserPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminUpdateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.deleteAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncementAdmin(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings(options?: RawAxiosRequestConfig): AxiosPromise<GetAuthenticationSettings200Response> {
            return localVarFp.getAuthenticationSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {GetDevicesAdminOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: RawAxiosRequestConfig): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: RawAxiosRequestConfig): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListAnnouncementsOrderByParameter} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginAdmin200Response> {
            return localVarFp.loginAdmin(loginAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnterpriseApi - object-oriented interface
 */
export class EnterpriseApi extends BaseAPI {
    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDeleteUser(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).adminDeleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
     * @summary Reset user password
     * @param {string} id The ID of the user whose password needs to be reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminResetUserPassword(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).adminResetUserPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).adminUpdateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure local authentication settings for the ShellHub instance.
     * @summary Configure Local Authentication
     * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
     * @summary Configure SAML Authentication
     * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an announcement.
     * @summary Create an announcement
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createAnnouncement(createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key admin
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an announcement.
     * @summary Delete an announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAnnouncement(uuid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnnouncementAdmin(uuid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getAnnouncementAdmin(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current authentication settings.
     * @summary Get Authentication Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthenticationSettings(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getAuthenticationSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeviceAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {GetDevicesAdminOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: GetDevicesAdminOrderByParameter, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicense(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys admin
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListAnnouncementsOrderByParameter} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: ListAnnouncementsOrderByParameter, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login on Admin
     * @summary Login on Admin
     * @param {LoginAdminRequest} [loginAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).loginAdmin(loginAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {File} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendLicense(file?: File, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an announcement.
     * @summary Update an announcement
     * @param {string} uuid 
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExternalApi - axios parameter creator
 */
export const ExternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalApi - functional programming interface
 */
export const ExternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalApi.authUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalApi - factory interface
 */
export const ExternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalApiFp(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalApi - object-oriented interface
 */
export class ExternalApi extends BaseAPI {
    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return ExternalApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return ExternalApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.authSSHPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.updateDeviceStatusOffline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 */
export class InternalApi extends BaseAPI {
    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDeviceStatusOffline(uid: string, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseApi - axios parameter creator
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.getLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.sendLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseApi - factory interface
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: RawAxiosRequestConfig): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {File} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - object-oriented interface
 */
export class LicenseApi extends BaseAPI {
    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicense(options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {File} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendLicense(file?: File, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('generateInvitationLink', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/invites`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus: async (tenant: string, id: string, sig: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('lookupUserStatus', 'tenant', tenant)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupUserStatus', 'id', id)
            // verify required parameter 'sig' is not null or undefined
            assertParamExists('lookupUserStatus', 'sig', sig)
            const localVarPath = `/api/namespaces/{tenant}/members/{id}/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sig !== undefined) {
                localVarQueryParameter['sig'] = sig;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.addNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateInvitationLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInvitationLink(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.generateInvitationLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.leaveNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LookupUserStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStatus(tenant, id, sig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.lookupUserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateInvitationLink200Response> {
            return localVarFp.generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): AxiosPromise<LookupUserStatus200Response> {
            return localVarFp.lookupUserStatus(tenant, id, sig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 */
export class MembersApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
     * @summary Generate an invitation link for a namespace member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaveNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
     * @summary Lookup User\'s Status
     * @param {string} tenant The tenant ID of the namespace.
     * @param {string} id The user\&#39;s ID.
     * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).lookupUserStatus(tenant, id, sig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MfaApi - axios parameter creator
 */
export const MfaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MfaApi - functional programming interface
 */
export const MfaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MfaApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.authMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.disableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.enableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.generateMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.mfaRecover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.requestResetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MfaApi.resetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MfaApi - factory interface
 */
export const MfaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MfaApiFp(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: RawAxiosRequestConfig): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MfaApi - object-oriented interface
 */
export class MfaApi extends BaseAPI {
    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateMFA(options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig) {
        return MfaApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NamespacesApi - axios parameter creator
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyDelete', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key: string, apiKeyUpdate?: ApiKeyUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiKeyUpdate', 'key', key)
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate: async (connectorData: ConnectorData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorCreate', 'connectorData', connectorData)
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorDelete', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorGet', 'uid', uid)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorInfo', 'uid', uid)
            const localVarPath = `/api/connector/{uid}/info`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList: async (enable?: boolean, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (enable !== undefined) {
                localVarQueryParameter['enable'] = enable;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate: async (uid: string, connectorData: ConnectorData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('connectorUpdate', 'uid', uid)
            // verify required parameter 'connectorData' is not null or undefined
            assertParamExists('connectorUpdate', 'connectorData', connectorData)
            const localVarPath = `/api/connector/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceRequest?: CreateNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, editNamespaceRequest?: EditNamespaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('generateInvitationLink', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/invites`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceSupport', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/support`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus: async (tenant: string, id: string, sig: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('lookupUserStatus', 'tenant', tenant)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupUserStatus', 'id', id)
            // verify required parameter 'sig' is not null or undefined
            assertParamExists('lookupUserStatus', 'sig', sig)
            const localVarPath = `/api/namespaces/{tenant}/members/{id}/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sig !== undefined) {
                localVarQueryParameter['sig'] = sig;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus_1: async (tenant: string, id: string, sig: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('lookupUserStatus_1', 'tenant', tenant)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lookupUserStatus_1', 'id', id)
            // verify required parameter 'sig' is not null or undefined
            assertParamExists('lookupUserStatus_1', 'sig', sig)
            const localVarPath = `/api/namespaces/{tenant}/members/{id}/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sig !== undefined) {
                localVarQueryParameter['sig'] = sig;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.addNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.apiKeyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.apiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.apiKeyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.apiKeyUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorCreate(connectorData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorInfo(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorInfo(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorList(enable, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorUpdate(uid, connectorData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.connectorUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.createNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.createNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.deleteNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.deleteNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, editNamespaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.editNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.editNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.exportNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateInvitationLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInvitationLink(tenant, addNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.generateInvitationLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespaceAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Support>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceSupport(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespaceSupport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespaceToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.getNamespacesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.leaveNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LookupUserStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStatus(tenant, id, sig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.lookupUserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserStatus_1(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LookupUserStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStatus_1(tenant, id, sig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.lookupUserStatus_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.removeNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NamespacesApi.updateNamespaceMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NamespacesApi - factory interface
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ApiKeyListOrderByParameter} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} key 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new connector.
         * @summary Connector\'s create
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorCreate(connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a connector.
         * @summary Connector\'s delete
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a connector.
         * @summary Connector\'s get
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.connectorGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the connector\'s connection docker info.
         * @summary Connector\'s get Docker info
         * @param {string} uid Connector UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorInfo(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorInfo200Response> {
            return localVarFp.connectorInfo(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * List connectors.
         * @summary Connector\'s list
         * @param {boolean} [enable] Enable status.
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connector>> {
            return localVarFp.connectorList(enable, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a connector settings.
         * @summary Connector\'s setting update
         * @param {string} uid Connector UID
         * @param {ConnectorData} connectorData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorUpdate(uid, connectorData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, editNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
         * @summary Generate an invitation link for a namespace member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateInvitationLink200Response> {
            return localVarFp.generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace support identifier.
         * @summary Get a namespace support identifier.
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<Support> {
            return localVarFp.getNamespaceSupport(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): AxiosPromise<LookupUserStatus200Response> {
            return localVarFp.lookupUserStatus(tenant, id, sig, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
         * @summary Lookup User\'s Status
         * @param {string} tenant The tenant ID of the namespace.
         * @param {string} id The user\&#39;s ID.
         * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserStatus_1(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig): AxiosPromise<LookupUserStatus200Response> {
            return localVarFp.lookupUserStatus_1(tenant, id, sig, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 */
export class NamespacesApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyDelete(key: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ApiKeyListOrderByParameter} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: ApiKeyListOrderByParameter, sortBy?: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} key 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiKeyUpdate(key: string, apiKeyUpdate?: ApiKeyUpdate, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new connector.
     * @summary Connector\'s create
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorCreate(connectorData: ConnectorData, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorCreate(connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a connector.
     * @summary Connector\'s delete
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorDelete(uid: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a connector.
     * @summary Connector\'s get
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorGet(uid: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the connector\'s connection docker info.
     * @summary Connector\'s get Docker info
     * @param {string} uid Connector UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorInfo(uid: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorInfo(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connectors.
     * @summary Connector\'s list
     * @param {boolean} [enable] Enable status.
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorList(enable?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorList(enable, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a connector settings.
     * @summary Connector\'s setting update
     * @param {string} uid Connector UID
     * @param {ConnectorData} connectorData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectorUpdate(uid: string, connectorData: ConnectorData, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).connectorUpdate(uid, connectorData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createNamespaceAdmin(tenant: string, createNamespaceRequest?: CreateNamespaceRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {EditNamespaceRequest} [editNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, editNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a unique invitation link to invite a member to a namespace using their email. Each invitation link is unique and tied to the provided email. Upon accepting the invitation, the user\'s status will automatically be set to `accepted`. If the user associated with the email does not exist, the invitation link will redirect them to the signup page.  The invitation remains valid for **7 days**. 
     * @summary Generate an invitation link for a namespace member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateInvitationLink(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).generateInvitationLink(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceAdmin(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace support identifier.
     * @summary Get a namespace support identifier.
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceSupport(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceSupport(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaceToken(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaveNamespace(tenant: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
     * @summary Lookup User\'s Status
     * @param {string} tenant The tenant ID of the namespace.
     * @param {string} id The user\&#39;s ID.
     * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lookupUserStatus(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).lookupUserStatus(tenant, id, sig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients may need to check a user\'s status before deciding whether to redirect to the accept-invite workflow or to the signup process. It is intended for use exclusively by clients in the `invite-member` pipeline. 
     * @summary Lookup User\'s Status
     * @param {string} tenant The tenant ID of the namespace.
     * @param {string} id The user\&#39;s ID.
     * @param {string} sig The signature included in the email. This is used instead of the user\&#39;s token to authenticate the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lookupUserStatus_1(tenant: string, id: string, sig: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).lookupUserStatus_1(tenant, id, sig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: RawAxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.createFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.createFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.deleteFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.deleteFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getFirewallRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getFirewallRulesAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.updateFirewallRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.updateFirewallRuleAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFirewallRule(id: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRule(id: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRuleAdmin(id: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRules(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFirewallRule(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord: async (uid: string, seat: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('deleteSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (uid: string, seat: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionRecord', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('getSessionRecord', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            // verify required parameter 'seat' is not null or undefined
            assertParamExists('recordSession', 'seat', seat)
            const localVarPath = `/api/sessions/{uid}/records/{seat}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"seat"}}`, encodeURIComponent(String(seat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.checkSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.clsoeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionRecord(uid, seat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.deleteSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.getSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.getSessionAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(uid, seat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.getSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.getSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.getSessionsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, seat, recordSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.recordSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.setSessionAuthenticationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.setSessionAuthenticationStatusAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.setSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a session record based on its seat.
         * @summary Delete session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session record based on its seat.
         * @summary Get session record
         * @param {string} uid 
         * @param {number} seat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionRecord(uid, seat, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {number} seat 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.recordSession(uid, seat, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 */
export class SessionsApi extends BaseAPI {
    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkSessionRecord(options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a session record based on its seat.
     * @summary Delete session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).deleteSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSession(uid: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionAdmin(uid: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session record based on its seat.
     * @summary Get session record
     * @param {string} uid 
     * @param {number} seat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionRecord(uid: string, seat: number, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionRecord(uid, seat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessions(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {number} seat 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordSession(uid: string, seat: number, recordSessionRequest?: RecordSessionRequest, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).recordSession(uid, seat, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SshApi - axios parameter creator
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin: async (publicKeyRequest?: PublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.authSSHPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.createPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKeyAdmin(publicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.createPublicKeyAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.deletePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.getPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeysAdmin(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.getPublicKeysAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SshApi.updatePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SshApi - factory interface
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 */
export class SshApi extends BaseAPI {
    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key admin
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePublicKey(fingerprint: string, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys admin
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsApi - axios parameter creator
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsApi - factory interface
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: RawAxiosRequestConfig): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 */
export class StatsApi extends BaseAPI {
    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup: async (sign: string, setupRequest?: SetupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sign' is not null or undefined
            assertParamExists('setup', 'sign', sign)
            const localVarPath = `/api/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sign !== undefined) {
                localVarQueryParameter['sign'] = sign;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup(sign, setupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.setup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: RawAxiosRequestConfig): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setup(sign, setupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 */
export class SystemApi extends BaseAPI {
    /**
     * Get information about ShellHub instance like version, SSH and API addresses.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version. This parameter is used to filter instance information based on the requesting agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getInfo(agentVersion?: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an user and create namespace with the same name as username
     * @summary User setup
     * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
     * @param {SetupRequest} [setupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setup(sign: string, setupRequest?: SetupRequest, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).setup(sign, setupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (tenant: string, createTagRequest: CreateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createTag', 'tenant', tenant)
            // verify required parameter 'createTagRequest' is not null or undefined
            assertParamExists('createTag', 'createTagRequest', createTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tenant: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteTag', 'tenant', tenant)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteTag', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (tenant: string, filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getTags', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice: async (tenant: string, uid: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tenant: string, name: string, updateTagRequest: UpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateTag', 'tenant', tenant)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateTag', 'name', name)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('updateTag', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(tenant, createTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tenant, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(tenant, filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromContainer(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.pullTagFromContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromDevice(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.pullTagFromDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToContainer(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.pushTagToContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToDevice(tenant, uid, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.pushTagToDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tenant, name, updateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.updateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTag(tenant, createTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(tenant, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.getTags(tenant, filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pullTagFromContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pullTagFromDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushTagToContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushTagToDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} name Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.updateTag(tenant, name, updateTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 */
export class TagsApi extends BaseAPI {
    /**
     * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
     * @summary Create a new tag in the namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateTagRequest} createTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTag(tenant: string, createTagRequest: CreateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(tenant, createTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a tag and all its associations
     * @summary Delete a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} name Tag name to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTag(tenant: string, name: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tenant, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all tags associated with a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(tenant, filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pullTagFromContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).pullTagFromContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pullTagFromDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).pullTagFromDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pushTagToContainer(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).pushTagToContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pushTagToDevice(tenant: string, uid: string, name: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).pushTagToDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} name Current tag name
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTag(tenant: string, name: string, updateTagRequest: UpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(tenant, name, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TunnelsApi - axios parameter creator
 */
export const TunnelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel: async (uid: string, createTunnelRequest: CreateTunnelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createTunnel', 'uid', uid)
            // verify required parameter 'createTunnelRequest' is not null or undefined
            assertParamExists('createTunnel', 'createTunnelRequest', createTunnelRequest)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTunnelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel: async (uid: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteTunnel', 'uid', uid)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteTunnel', 'address', address)
            const localVarPath = `/api/devices/{uid}/tunnels/{address}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels: async (uid: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listTunnels', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tunnels`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TunnelsApi - functional programming interface
 */
export const TunnelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TunnelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tunnel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTunnel(uid, createTunnelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TunnelsApi.createTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunnel(uid, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TunnelsApi.deleteTunnel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tunnel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunnels(uid, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TunnelsApi.listTunnels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TunnelsApi - factory interface
 */
export const TunnelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TunnelsApiFp(configuration)
    return {
        /**
         * Creates a new tunnel for a device.
         * @summary Create a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {CreateTunnelRequest} createTunnelRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tunnel> {
            return localVarFp.createTunnel(uid, createTunnelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tunnel for a specific device and port.
         * @summary Delete a tunnel
         * @param {string} uid Device\&#39;s UID
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTunnel(uid, address, options).then((request) => request(axios, basePath));
        },
        /**
         * List the tunnels per devices.
         * @summary List tunnels
         * @param {string} uid Device\&#39;s UID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tunnel>> {
            return localVarFp.listTunnels(uid, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TunnelsApi - object-oriented interface
 */
export class TunnelsApi extends BaseAPI {
    /**
     * Creates a new tunnel for a device.
     * @summary Create a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {CreateTunnelRequest} createTunnelRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public createTunnel(uid: string, createTunnelRequest: CreateTunnelRequest, options?: RawAxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).createTunnel(uid, createTunnelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tunnel for a specific device and port.
     * @summary Delete a tunnel
     * @param {string} uid Device\&#39;s UID
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deleteTunnel(uid: string, address: string, options?: RawAxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).deleteTunnel(uid, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the tunnels per devices.
     * @summary List tunnels
     * @param {string} uid Device\&#39;s UID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public listTunnels(uid: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TunnelsApiFp(this.configuration).listTunnels(uid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (tenant: string, acceptInviteRequest?: AcceptInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('acceptInvite', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members/accept-invite`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminResetUserPassword', 'id', id)
            const localVarPath = `/admin/api/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/saml/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getToken', 'tenant', tenant)
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest?: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword: async (id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPassword', 'id', id)
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(tenant, acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.adminDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminResetUserPassword(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.adminResetUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(id, userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.authMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.authUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.disableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.enableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.exportUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamlAuthUrl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSamlAuthUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamlAuthUrl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getSamlAuthUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserTokenAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getValidateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.mfaRecover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.recoverPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestResetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.resendEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.resetMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setSessionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateRecoverPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
         * @summary Accept a membership invite
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AcceptInviteRequest} [acceptInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminDeleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminResetUserPassword200Response> {
            return localVarFp.adminResetUserPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminUpdateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
         * @summary Get SAML authentication URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamlAuthUrl(options?: RawAxiosRequestConfig): AxiosPromise<GetSamlAuthUrl200Response> {
            return localVarFp.getSamlAuthUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} tenant Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterUserRequest} [registerUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} id User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * This route is intended to be accessed directly through the link sent in the invitation email. The user must be logged into the account that was invited. 
     * @summary Accept a membership invite
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AcceptInviteRequest} [acceptInviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptInvite(tenant: string, acceptInviteRequest?: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptInvite(tenant, acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDeleteUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminDeleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
     * @summary Reset user password
     * @param {string} id The ID of the user whose password needs to be reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminResetUserPassword(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminResetUserPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminUpdateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMFA(mfaAuth?: MfaAuth, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authUser(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkSessionRecord(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the authenticated user. The user will be removed from any namespaces they are a member of. Users who are owners of namespaces cannot be deleted. In such cases, the user must delete the namespace(s) first.  > NOTE: This route is available only for **cloud** instances. Enterprise users must use the admin console, and community users must use the CLI. 
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Identity Provider (IdP) URL for authentication within ShellHub. After successful authentication, users are automatically redirected to the ShellHub dashboard.  To access this endpoint, SAML authentication must be enabled and the instance must be running the Enterprise edition. If not, the endpoint returns a `501 Not Implemented` status code. 
     * @summary Get SAML authentication URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSamlAuthUrl(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSamlAuthUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} tenant Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getToken(tenant: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserInfo(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserTokenAdmin(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getValidateAccount(email: string, token: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterUserRequest} [registerUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} id User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public updateUserPassword(id: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebEndpointsApi - axios parameter creator
 */
export const WebEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebEndpoint: async (createWebEndpointRequest: CreateWebEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebEndpointRequest' is not null or undefined
            assertParamExists('createWebEndpoint', 'createWebEndpointRequest', createWebEndpointRequest)
            const localVarPath = `/api/web-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebEndpointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebEndpoint: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('deleteWebEndpoint', 'address', address)
            const localVarPath = `/api/web-endpoints/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebEndpoints: async (filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/web-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebEndpointsApi - functional programming interface
 */
export const WebEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webendpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebEndpoint(createWebEndpointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebEndpointsApi.createWebEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebEndpoint(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebEndpointsApi.deleteWebEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webendpoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebEndpoints(filter, page, perPage, sortBy, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebEndpointsApi.listWebEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebEndpointsApi - factory interface
 */
export const WebEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebEndpointsApiFp(configuration)
    return {
        /**
         * Creates a new web-endpoint for a device.
         * @summary Create a web-endpoint
         * @param {CreateWebEndpointRequest} createWebEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webendpoint> {
            return localVarFp.createWebEndpoint(createWebEndpointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a web-endpoint by address.
         * @summary Delete a web-endpoint
         * @param {string} address Tunnel\&#39;s address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebEndpoint(address, options).then((request) => request(axios, basePath));
        },
        /**
         * List all web-endpoints in the namespace.
         * @summary List web-endpoints
         * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
         * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig): AxiosPromise<Array<Webendpoint>> {
            return localVarFp.listWebEndpoints(filter, page, perPage, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebEndpointsApi - object-oriented interface
 */
export class WebEndpointsApi extends BaseAPI {
    /**
     * Creates a new web-endpoint for a device.
     * @summary Create a web-endpoint
     * @param {CreateWebEndpointRequest} createWebEndpointRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWebEndpoint(createWebEndpointRequest: CreateWebEndpointRequest, options?: RawAxiosRequestConfig) {
        return WebEndpointsApiFp(this.configuration).createWebEndpoint(createWebEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a web-endpoint by address.
     * @summary Delete a web-endpoint
     * @param {string} address Tunnel\&#39;s address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWebEndpoint(address: string, options?: RawAxiosRequestConfig) {
        return WebEndpointsApiFp(this.configuration).deleteWebEndpoint(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all web-endpoints in the namespace.
     * @summary List web-endpoints
     * @param {string} [filter] Web endpoint\&#39;s filter  Filter field receives a base64 enconded JSON object for limit a search. 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {ListWebEndpointsSortByParameter} [sortBy] Field to sort by
     * @param {ListWebEndpointsOrderByParameter} [orderBy] Sort order (asc or desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWebEndpoints(filter?: string, page?: number, perPage?: number, sortBy?: ListWebEndpointsSortByParameter, orderBy?: ListWebEndpointsOrderByParameter, options?: RawAxiosRequestConfig) {
        return WebEndpointsApiFp(this.configuration).listWebEndpoints(filter, page, perPage, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



