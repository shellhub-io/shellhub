/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub Cloud OpenAPI
 * > NOTICE: THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR.  ShellHub Cloud OpenAPI specification.  It documents all routes provided by ShellHub Cloud. 
 *
 * The version of the OpenAPI document: 1.0.0-alpha.5
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddNamespaceMemberRequest
 */
export interface AddNamespaceMemberRequest {
    /**
     * Member\'s username.
     * @type {string}
     * @memberof AddNamespaceMemberRequest
     */
    'username': string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof AddNamespaceMemberRequest
     */
    'role': NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface AddTagPublicKeyRequest
 */
export interface AddTagPublicKeyRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof AddTagPublicKeyRequest
     */
    'tag': string;
}
/**
 * Announcement.
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof Announcement
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof Announcement
     */
    'title'?: string;
    /**
     * Announcement description.
     * @type {string}
     * @memberof Announcement
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface AnnouncementShort
 */
export interface AnnouncementShort {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementShort
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * API Key ID.
     * @type {string}
     * @memberof ApiKey
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof ApiKey
     */
    'tenant_id'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof ApiKey
     */
    'user_id'?: string;
    /**
     * API Key name.
     * @type {string}
     * @memberof ApiKey
     */
    'name'?: string;
    /**
     * API Key expiration time until expiration.  It is a unix time or `-1` for unlimited tokens. 
     * @type {number}
     * @memberof ApiKey
     */
    'expires_in'?: number;
}
/**
 * API Key expiration date.  Expiry date time following this pattern:   30 to 30 days   60 to 60 days   90 to 90 days   365 to 1 year   -1 for token without expiration date 
 * @export
 * @enum {string}
 */

export const ApiKeyExpiresAt = {
    NUMBER_30: 30,
    NUMBER_60: 60,
    NUMBER_90: 90,
    NUMBER_365: 365,
    NUMBER_MINUS_1: -1
} as const;

export type ApiKeyExpiresAt = typeof ApiKeyExpiresAt[keyof typeof ApiKeyExpiresAt];


/**
 * 
 * @export
 * @interface AttachPaymentMethodRequest
 */
export interface AttachPaymentMethodRequest {
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof AttachPaymentMethodRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AuthDevice200Response
 */
export interface AuthDevice200Response {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'uid'?: string;
    /**
     * Device\'s token
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'token'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'name'?: string;
    /**
     * Device\'s namespace name
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface AuthDeviceRequest
 */
export interface AuthDeviceRequest {
    /**
     * 
     * @type {DeviceInfo}
     * @memberof AuthDeviceRequest
     */
    'info': DeviceInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthDeviceRequest
     */
    'sessions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'hostname': string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof AuthDeviceRequest
     */
    'identity'?: DeviceIdentity;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'public_key': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'tenant_id': string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKey200Response
 */
export interface AuthSSHPublicKey200Response {
    /**
     * Device\'s signature.
     * @type {string}
     * @memberof AuthSSHPublicKey200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKeyRequest
 */
export interface AuthSSHPublicKeyRequest {
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'fingerprint': string;
    /**
     * Public key\'s data.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ChoiceDevicesRequest
 */
export interface ChoiceDevicesRequest {
    /**
     * Device\'s list.
     * @type {Array<string>}
     * @memberof ChoiceDevicesRequest
     */
    'choices': Array<string>;
}
/**
 * 
 * @export
 * @interface ClsoeSessionRequest
 */
export interface ClsoeSessionRequest {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof ClsoeSessionRequest
     */
    'device': string;
}
/**
 * 
 * @export
 * @interface CreateApiKey200Response
 */
export interface CreateApiKey200Response {
    /**
     * API Key ID.
     * @type {string}
     * @memberof CreateApiKey200Response
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * API Key name.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'name': string;
    /**
     * 
     * @type {ApiKeyExpiresAt}
     * @memberof CreateApiKeyRequest
     */
    'expires_at': ApiKeyExpiresAt;
}
/**
 * 
 * @export
 * @interface CreateDeviceTagRequest
 */
export interface CreateDeviceTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof CreateDeviceTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface CreateNamespaceRequest
 */
export interface CreateNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof CreateNamespaceRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreatePublicKey200Response
 */
export interface CreatePublicKey200Response {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'fingerprint'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof CreatePublicKey200Response
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Device
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof Device
     */
    'identity'?: DeviceIdentity;
    /**
     * 
     * @type {DeviceInfo}
     * @memberof Device
     */
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof Device
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Device
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     * @type {string}
     * @memberof Device
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     * @type {boolean}
     * @memberof Device
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Device
     */
    'namespace'?: string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof Device
     */
    'status'?: DeviceStatus;
    /**
     * Device\'s status update date
     * @type {string}
     * @memberof Device
     */
    'status_update_at'?: string;
    /**
     * Device\'s creation date
     * @type {string}
     * @memberof Device
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     * @type {string}
     * @memberof Device
     */
    'remote_addr'?: string;
    /**
     * 
     * @type {DevicePosition}
     * @memberof Device
     */
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof Device
     */
    'tags'?: Array<string>;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof Device
     */
    'public_url'?: boolean;
    /**
     * Device\'s acceptable  The value \"acceptable\" is based on the number of devices removed and already accepted into a namespace. All devices are \"acceptable\" unless the \"namespace.max_devices\" is reached. This limit is set based on the sum up of accepted and removed devices into the namespace. When this limit is reached, only removed devices between 720 hours or 30 days are set to \"acceptable\". 
     * @type {boolean}
     * @memberof Device
     */
    'acceptable'?: boolean;
}
/**
 * Device\'s identity
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     * @type {string}
     * @memberof DeviceIdentity
     */
    'mac'?: string;
}
/**
 * Device\'s info
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     * @type {string}
     * @memberof DeviceInfo
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     * @type {string}
     * @memberof DeviceInfo
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     * @type {string}
     * @memberof DeviceInfo
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     * @type {string}
     * @memberof DeviceInfo
     */
    'arch'?: string;
    /**
     * Device\'s OS platform
     * @type {string}
     * @memberof DeviceInfo
     */
    'platform'?: DeviceInfoPlatformEnum;
}

export const DeviceInfoPlatformEnum = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatformEnum = typeof DeviceInfoPlatformEnum[keyof typeof DeviceInfoPlatformEnum];

/**
 * Device\'s geolocation position
 * @export
 * @interface DevicePosition
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Removed: 'removed',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface EditNamespaceRequest
 */
export interface EditNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof EditNamespaceRequest
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof EditNamespaceRequest
     */
    'settings'?: NamespaceSettings;
}
/**
 * 
 * @export
 * @interface Evaluate200Response
 */
export interface Evaluate200Response {
    /**
     * Namespaces\'s acceptance status.
     * @type {boolean}
     * @memberof Evaluate200Response
     */
    'can_accept'?: boolean;
    /**
     * Namespace\'s connection status.
     * @type {boolean}
     * @memberof Evaluate200Response
     */
    'can_connect'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallRulesRequest
 */
export interface FirewallRulesRequest {
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'action': FirewallRulesRequestActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesRequest
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesRequest
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesRequest
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'username': string;
}

export const FirewallRulesRequestActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesRequestActionEnum = typeof FirewallRulesRequestActionEnum[keyof typeof FirewallRulesRequestActionEnum];

/**
 * 
 * @export
 * @interface FirewallRulesResponse
 */
export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'tenant_id': string;
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'action': FirewallRulesResponseActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesResponse
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesResponse
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesResponse
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'username': string;
}

export const FirewallRulesResponseActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseActionEnum = typeof FirewallRulesResponseActionEnum[keyof typeof FirewallRulesResponseActionEnum];

/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 * @export
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf
 */
export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     * @type {string}
     * @memberof FirewallRulesResponseFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf1
 */
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     * @type {Array<string>}
     * @memberof FirewallRulesResponseFilterOneOf1
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetCustomer200Response
 */
export interface GetCustomer200Response {
    /**
     * Customer\'s ID.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'id'?: string;
    /**
     * Customer\'s name.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'name'?: string;
    /**
     * Customer\'s e-mail.
     * @type {string}
     * @memberof GetCustomer200Response
     */
    'email'?: string;
    /**
     * Customer\'s payment methods.
     * @type {Array<GetCustomer200ResponsePaymentMethodsInner>}
     * @memberof GetCustomer200Response
     */
    'payment_methods'?: Array<GetCustomer200ResponsePaymentMethodsInner>;
}
/**
 * 
 * @export
 * @interface GetCustomer200ResponsePaymentMethodsInner
 */
export interface GetCustomer200ResponsePaymentMethodsInner {
    /**
     * Payment method\'s ID.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'id'?: string;
    /**
     * Payment method card\'s number.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'number'?: string;
    /**
     * Payment method card\'s brand.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'brand'?: string;
    /**
     * Payment method card\'s expiration month.
     * @type {number}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'exp_month'?: number;
    /**
     * Payment method card\'s expiration year.
     * @type {number}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'exp_year'?: number;
    /**
     * Payment method card\'s CVC.
     * @type {string}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'cvc'?: string;
    /**
     * Payment method default status.
     * @type {boolean}
     * @memberof GetCustomer200ResponsePaymentMethodsInner
     */
    'default'?: boolean;
}
/**
 * @type GetCustomer400Response
 * @export
 */
export type GetCustomer400Response = GetCustomer400ResponseOneOf | RecordSession422Response;

/**
 * 
 * @export
 * @interface GetCustomer400ResponseOneOf
 */
export interface GetCustomer400ResponseOneOf {
    /**
     * Error\'s message.
     * @type {string}
     * @memberof GetCustomer400ResponseOneOf
     */
    'message'?: string;
    /**
     * Error\'s code.
     * @type {string}
     * @memberof GetCustomer400ResponseOneOf
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface GetSessionData401Response
 */
export interface GetSessionData401Response {
    /**
     * Error message
     * @type {string}
     * @memberof GetSessionData401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetSessionData500Response
 */
export interface GetSessionData500Response {
    /**
     * Error message.
     * @type {string}
     * @memberof GetSessionData500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetStatusDevices200Response
 */
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'active_sessions'?: number;
}
/**
 * 
 * @export
 * @interface GetSubscription200Response
 */
export interface GetSubscription200Response {
    /**
     * Subscription\'s ID.
     * @type {string}
     * @memberof GetSubscription200Response
     */
    'id'?: string;
    /**
     * Subscription\'s active.
     * @type {boolean}
     * @memberof GetSubscription200Response
     */
    'active'?: boolean;
    /**
     * Subscription\'s status.
     * @type {string}
     * @memberof GetSubscription200Response
     */
    'status'?: GetSubscription200ResponseStatusEnum;
    /**
     * Subscription\'s current period end.
     * @type {number}
     * @memberof GetSubscription200Response
     */
    'end_at'?: number;
    /**
     * Subscription\'s invoices.
     * @type {Array<GetSubscription200ResponseInvoicesInner>}
     * @memberof GetSubscription200Response
     */
    'invoices'?: Array<GetSubscription200ResponseInvoicesInner>;
}

export const GetSubscription200ResponseStatusEnum = {
    Inactive: 'inactive',
    Active: 'active',
    Trialing: 'trialing',
    Incomplete: 'incomplete',
    IncompleteExpired: 'incomplete_expired',
    PastDue: 'past_due',
    Canceled: 'canceled',
    Unpaid: 'unpaid',
    Paused: 'paused',
    ToCancelAtEndOfPeriod: 'to_cancel_at_end_of_period'
} as const;

export type GetSubscription200ResponseStatusEnum = typeof GetSubscription200ResponseStatusEnum[keyof typeof GetSubscription200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetSubscription200ResponseInvoicesInner
 */
export interface GetSubscription200ResponseInvoicesInner {
    /**
     * Invoice\'s ID.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'id'?: string;
    /**
     * Invoice\'s status.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'status'?: GetSubscription200ResponseInvoicesInnerStatusEnum;
    /**
     * Invoice\'s currency.
     * @type {string}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'currency'?: GetSubscription200ResponseInvoicesInnerCurrencyEnum;
    /**
     * Invoice\'s amount in cents.
     * @type {number}
     * @memberof GetSubscription200ResponseInvoicesInner
     */
    'amount'?: number;
}

export const GetSubscription200ResponseInvoicesInnerStatusEnum = {
    Draft: 'draft',
    Open: 'open',
    Paid: 'paid',
    Uncollectible: 'uncollectible',
    Voided: 'voided'
} as const;

export type GetSubscription200ResponseInvoicesInnerStatusEnum = typeof GetSubscription200ResponseInvoicesInnerStatusEnum[keyof typeof GetSubscription200ResponseInvoicesInnerStatusEnum];
export const GetSubscription200ResponseInvoicesInnerCurrencyEnum = {
    Usd: 'usd',
    Brl: 'brl'
} as const;

export type GetSubscription200ResponseInvoicesInnerCurrencyEnum = typeof GetSubscription200ResponseInvoicesInnerCurrencyEnum[keyof typeof GetSubscription200ResponseInvoicesInnerCurrencyEnum];

/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * ShellHub version.
     * @type {string}
     * @memberof Info
     */
    'version'?: string;
    /**
     * 
     * @type {InfoEndpoints}
     * @memberof Info
     */
    'endpoints'?: InfoEndpoints;
}
/**
 * 
 * @export
 * @interface InfoEndpoints
 */
export interface InfoEndpoints {
    /**
     * SSH endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'ssh'?: string;
    /**
     * API endpoint.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MfaAuth
 */
export interface MfaAuth {
    /**
     * The `X-MFA-Token` header returned by the authUser endpoint.
     * @type {string}
     * @memberof MfaAuth
     */
    'token': string;
    /**
     * The current code from the MFA authenticator.
     * @type {string}
     * @memberof MfaAuth
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface MfaDisable
 */
export interface MfaDisable {
    /**
     * The code generated by the MFA app.
     * @type {string}
     * @memberof MfaDisable
     */
    'code'?: string;
    /**
     * User\'s recovery code.
     * @type {string}
     * @memberof MfaDisable
     */
    'recovery_code'?: string;
}
/**
 * 
 * @export
 * @interface MfaEnable
 */
export interface MfaEnable {
    /**
     * The code generated by the MFA app.
     * @type {string}
     * @memberof MfaEnable
     */
    'code': string;
    /**
     * The secret generated by generateMFA endpoint.
     * @type {string}
     * @memberof MfaEnable
     */
    'secret': string;
    /**
     * A list of codes generated by generateMFA endpoint. These codes can be used when a user loses their MFA app. 
     * @type {Array<string>}
     * @memberof MfaEnable
     */
    'recovery_codes': Array<string>;
}
/**
 * 
 * @export
 * @interface MfaGenerate
 */
export interface MfaGenerate {
    /**
     * The link to establish a connection with the OTP server.
     * @type {string}
     * @memberof MfaGenerate
     */
    'link'?: string;
    /**
     * A secret key to authenticate with the OTP server.
     * @type {string}
     * @memberof MfaGenerate
     */
    'secret'?: string;
    /**
     * A list of recovery codes to use when the user loses access to their MFA app.
     * @type {Array<string>}
     * @memberof MfaGenerate
     */
    'recovery_codes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MfaRecover
 */
export interface MfaRecover {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     * @type {string}
     * @memberof MfaRecover
     */
    'identifier': string;
    /**
     * One of the user\'s recovery codes.
     * @type {string}
     * @memberof MfaRecover
     */
    'recovery_code': string;
}
/**
 * 
 * @export
 * @interface MfaReset
 */
export interface MfaReset {
    /**
     * The code sent to the main email address.
     * @type {string}
     * @memberof MfaReset
     */
    'main_email_code': string;
    /**
     * The code sent to the recovery email address.
     * @type {string}
     * @memberof MfaReset
     */
    'recovery_email_code': string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof Namespace
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Namespace
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     * @type {Array<NamespaceMembersInner>}
     * @memberof Namespace
     */
    'members'?: Array<NamespaceMembersInner>;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof Namespace
     */
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     * @type {number}
     * @memberof Namespace
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     * @type {number}
     * @memberof Namespace
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     * @type {string}
     * @memberof Namespace
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     * @type {object}
     * @memberof Namespace
     */
    'billing'?: object;
}
/**
 * Namespace\'s member role
 * @export
 * @enum {string}
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


/**
 * 
 * @export
 * @interface NamespaceMembersInner
 */
export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'id'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof NamespaceMembersInner
     */
    'role'?: NamespaceMemberRole;
}
/**
 * Namespace\'s settings.
 * @export
 * @interface NamespaceSettings
 */
export interface NamespaceSettings {
    /**
     * The session records define when the namespace should save or not record a session. This can be used to check logged activity when connecting to a device.
     * @type {boolean}
     * @memberof NamespaceSettings
     */
    'session_record'?: boolean;
    /**
     * A connection announcement is a custom string written during a session when a connection is established on a device within the namespace.
     * @type {string}
     * @memberof NamespaceSettings
     */
    'connection_announcement'?: string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags. 
 * @export
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf
 */
export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     * @type {string}
     * @memberof PublicKeyFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf1
 */
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     * @type {Set<string>}
     * @memberof PublicKeyFilterOneOf1
     */
    'tags': Set<string>;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'data': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyRequest
     */
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PublicKeyResponse
 */
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyResponse
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RecordSession422Response
 */
export interface RecordSession422Response {
    /**
     * Error\'s message.
     * @type {string}
     * @memberof RecordSession422Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RecordSessionRequest
 */
export interface RecordSessionRequest {
    /**
     * Session\'s UID.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'uid': string;
    /**
     * Session\'s data.
     * @type {string}
     * @memberof RecordSessionRequest
     */
    'message': string;
    /**
     * Session\'s pty width.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'width': number;
    /**
     * Session\'s pty height.
     * @type {number}
     * @memberof RecordSessionRequest
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecordedSessionResponseInner
 */
export interface RecordedSessionResponseInner {
    /**
     * Session\'s ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'uid': string;
    /**
     * Session\'s Data
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'message': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'tenant_id': string;
    /**
     * Session\'s time
     * @type {string}
     * @memberof RecordedSessionResponseInner
     */
    'time': string;
    /**
     * Session\'s terminal width
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'width': number;
    /**
     * Session\'s terminal height
     * @type {number}
     * @memberof RecordedSessionResponseInner
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface RecoverPasswordRequest
 */
export interface RecoverPasswordRequest {
    /**
     * 
     * @type {RecoverPasswordRequestUsername}
     * @memberof RecoverPasswordRequest
     */
    'username': RecoverPasswordRequestUsername;
}
/**
 * @type RecoverPasswordRequestUsername
 * @export
 */
export type RecoverPasswordRequestUsername = string;

/**
 * 
 * @export
 * @interface RenameTagRequest
 */
export interface RenameTagRequest {
    /**
     * Tag\'s name.
     * @type {string}
     * @memberof RenameTagRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface RequestResetMFARequest
 */
export interface RequestResetMFARequest {
    /**
     * The same as the login identifier; can be either the user\'s email or username.
     * @type {string}
     * @memberof RequestResetMFARequest
     */
    'identifier': string;
}
/**
 * 
 * @export
 * @interface ResendEmailRequest
 */
export interface ResendEmailRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof ResendEmailRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface RuleAddTagRequest
 */
export interface RuleAddTagRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleAddTagRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface RuleUpdateTagsRequest
 */
export interface RuleUpdateTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RuleUpdateTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session\'s UID
     * @type {string}
     * @memberof Session
     */
    'uid'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Session
     */
    'device_uid'?: string;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Session
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     * @type {string}
     * @memberof Session
     */
    'username'?: string;
    /**
     * Session\'s IP address
     * @type {string}
     * @memberof Session
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     * @type {string}
     * @memberof Session
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     * @type {string}
     * @memberof Session
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     * @type {boolean}
     * @memberof Session
     */
    'recorded'?: boolean;
    /**
     * Session\'s type
     * @type {string}
     * @memberof Session
     */
    'type'?: SessionTypeEnum;
    /**
     * Session\'s terminal
     * @type {string}
     * @memberof Session
     */
    'term'?: string;
    /**
     * 
     * @type {SessionPosition}
     * @memberof Session
     */
    'position'?: SessionPosition;
}

export const SessionTypeEnum = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionTypeEnum = typeof SessionTypeEnum[keyof typeof SessionTypeEnum];

/**
 * Session\'s geolocation position
 * @export
 * @interface SessionPosition
 */
export interface SessionPosition {
    /**
     * Session\'s latitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'latitude'?: number;
    /**
     * Session\'s longitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface SetSessionAuthenticationStatusRequest
 */
export interface SetSessionAuthenticationStatusRequest {
    /**
     * Session\'s authentication status.
     * @type {boolean}
     * @memberof SetSessionAuthenticationStatusRequest
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SetSessionRecordRequest
 */
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     * @type {boolean}
     * @memberof SetSessionRecordRequest
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateApiKeyRequest
 */
export interface UpdateApiKeyRequest {
    /**
     * API Key name.
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'name'?: string;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof UpdateDeviceRequest
     */
    'public_url'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateNamespaceMemberRequest
 */
export interface UpdateNamespaceMemberRequest {
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UpdateNamespaceMemberRequest
     */
    'role'?: NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s username.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'username': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof UpdatePublicKeyRequest
     */
    'filter': PublicKeyFilter;
}
/**
 * 
 * @export
 * @interface UpdateRecoverPasswordRequest
 */
export interface UpdateRecoverPasswordRequest {
    /**
     * User\'s password.
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'password': string;
    /**
     * User\'s recovery token.    It is the token from the email sent to user when the user request password reset. 
     * @type {string}
     * @memberof UpdateRecoverPasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UpdateTagsDeviceRequest
 */
export interface UpdateTagsDeviceRequest {
    /**
     * Device\'s Tags list
     * @type {Array<string>}
     * @memberof UpdateTagsDeviceRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTagsPublicKeyRequest
 */
export interface UpdateTagsPublicKeyRequest {
    /**
     * Public key\'s new tags.
     * @type {Set<string>}
     * @memberof UpdateTagsPublicKeyRequest
     */
    'tags'?: Set<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDataRequest
 */
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'name'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'username'?: string;
    /**
     * User\'s e-mail.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'email'?: string;
    /**
     * User\'s recovery e-mail. A recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'recovery_email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'current_password'?: string;
    /**
     * User new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User\'s name.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * User\'s email marketing option.
     * @type {boolean}
     * @memberof User
     */
    'email_marketing'?: boolean;
}
/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * JWT Token
     * @type {string}
     * @memberof UserAuth
     */
    'token'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAuth
     */
    'id'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAuth
     */
    'user'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAuth
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAuth
     */
    'email'?: string;
    /**
     * The recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UserAuth
     */
    'recovery_email'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof UserAuth
     */
    'tenant'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UserAuth
     */
    'role'?: NamespaceMemberRole;
    /**
     * Indicates whether the user has MFA enabled.
     * @type {boolean}
     * @memberof UserAuth
     */
    'mfa'?: boolean;
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an API Key.
         * @summary Creates an API Key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (tenant: string, createApiKeyRequest?: CreateApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createApiKey', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/api-key`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key.
         * @summary Delete an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (tenant: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteApiKey', 'tenant', tenant)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteApiKey', 'key', key)
            const localVarPath = `/api/namespaces/{tenant}/api-key/{key}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List API Keys.
         * @summary List API Keys
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] API Key\&#39;s property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKey: async (tenant: string, page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('listApiKey', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/api-key`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API key.
         * @summary Update an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {UpdateApiKeyRequest} [updateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey: async (tenant: string, key: string, updateApiKeyRequest?: UpdateApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateApiKey', 'tenant', tenant)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateApiKey', 'key', key)
            const localVarPath = `/api/namespaces/{tenant}/api-key/{key}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an API Key.
         * @summary Creates an API Key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(tenant: string, createApiKeyRequest?: CreateApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(tenant, createApiKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an API key.
         * @summary Delete an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(tenant: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(tenant, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List API Keys.
         * @summary List API Keys
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] API Key\&#39;s property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKey(tenant: string, page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKey(tenant, page, perPage, orderBy, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an API key.
         * @summary Update an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {UpdateApiKeyRequest} [updateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKey(tenant: string, key: string, updateApiKeyRequest?: UpdateApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(tenant, key, updateApiKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * Creates an API Key.
         * @summary Creates an API Key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(tenant: string, createApiKeyRequest?: CreateApiKeyRequest, options?: any): AxiosPromise<CreateApiKey200Response> {
            return localVarFp.createApiKey(tenant, createApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key.
         * @summary Delete an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(tenant: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApiKey(tenant, key, options).then((request) => request(axios, basePath));
        },
        /**
         * List API Keys.
         * @summary List API Keys
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] API Key\&#39;s property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKey(tenant: string, page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.listApiKey(tenant, page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an API key.
         * @summary Update an API key
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} key Api key ID.
         * @param {UpdateApiKeyRequest} [updateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(tenant: string, key: string, updateApiKeyRequest?: UpdateApiKeyRequest, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.updateApiKey(tenant, key, updateApiKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * Creates an API Key.
     * @summary Creates an API Key
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateApiKeyRequest} [createApiKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(tenant: string, createApiKeyRequest?: CreateApiKeyRequest, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey(tenant, createApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API key.
     * @summary Delete an API key
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} key Api key ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(tenant: string, key: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(tenant, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List API Keys.
     * @summary List API Keys
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {string} [sortBy] API Key\&#39;s property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listApiKey(tenant: string, page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).listApiKey(tenant, page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an API key.
     * @summary Update an API key
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} key Api key ID.
     * @param {UpdateApiKeyRequest} [updateApiKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public updateApiKey(tenant: string, key: string, updateApiKeyRequest?: UpdateApiKeyRequest, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).updateApiKey(tenant, key, updateApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: 'device_accept' | 'namespace_delete', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: any): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: any): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: any): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: 'device_accept' | 'namespace_delete', options?: any): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCustomer(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public evaluate(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomer(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {'device_accept' | 'namespace_delete'} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudApi - axios parameter creator
 * @export
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices: async (choiceDevicesRequest?: ChoiceDevicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/device-choice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceDevicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/devices-most-used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionData', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/play`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (action: 'device_accept' | 'namespace_delete', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('report', 'action', action)
            const localVarPath = `/api/billing/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (attachPaymentMethodRequest?: AttachPaymentMethodRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/paymentmethod/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 * @export
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceDevices(choiceDevicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesMostUsed(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesMostUsed(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionData(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionData(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(attachPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudApi - factory interface
 * @export
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Attachs a payment method to a customer.
         * @summary Attach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Choice devices when device\'s limit is rechead.
         * @summary Choice devices
         * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.choiceDevices(choiceDevicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new customer defining, optionaly, the default payment method.
         * @summary Create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(options?: any): AxiosPromise<void> {
            return localVarFp.createCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @summary Create subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(options?: any): AxiosPromise<void> {
            return localVarFp.createSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Detachs a payment method from a customer.
         * @summary Detach payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * evaluate the namespace capabilities.
         * @summary Evaluate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(options?: any): AxiosPromise<Evaluate200Response> {
            return localVarFp.evaluate(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: any): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer.
         * @summary Get Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(options?: any): AxiosPromise<GetCustomer200Response> {
            return localVarFp.getCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most used devices.
         * @summary Get devices most used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesMostUsed(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesMostUsed(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData(uid: string, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionData(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the subscription.
         * @summary Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Report an action.
         * @summary Report
         * @param {'device_accept' | 'namespace_delete'} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(action: 'device_accept' | 'namespace_delete', options?: any): AxiosPromise<void> {
            return localVarFp.report(action, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set default payment method to the customer.
         * @summary Set default payment method
         * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 * @export
 * @class CloudApi
 * @extends {BaseAPI}
 */
export class CloudApi extends BaseAPI {
    /**
     * Attachs a payment method to a customer.
     * @summary Attach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public attachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).attachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Choice devices when device\'s limit is rechead.
     * @summary Choice devices
     * @param {ChoiceDevicesRequest} [choiceDevicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public choiceDevices(choiceDevicesRequest?: ChoiceDevicesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).choiceDevices(choiceDevicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new customer defining, optionaly, the default payment method.
     * @summary Create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createCustomer(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @summary Create subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detachs a payment method from a customer.
     * @summary Detach payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public detachPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).detachPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * evaluate the namespace capabilities.
     * @summary Evaluate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public evaluate(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).evaluate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public generateMFA(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer.
     * @summary Get Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getCustomer(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getCustomer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most used devices.
     * @summary Get devices most used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getDevicesMostUsed(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getDevicesMostUsed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session recorded data.
     * @summary Get session recorded data
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSessionData(uid: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSessionData(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the subscription.
     * @summary Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getSubscription(options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recordSession(uid, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user
     * @summary Register user
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public registerUser(user?: User, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).registerUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report an action.
     * @summary Report
     * @param {'device_accept' | 'namespace_delete'} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public report(action: 'device_accept' | 'namespace_delete', options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).report(action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set default payment method to the customer.
     * @summary Set default payment method
     * @param {AttachPaymentMethodRequest} [attachPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public setDefaultPaymentMethod(attachPaymentMethodRequest?: AttachPaymentMethodRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).setDefaultPaymentMethod(attachPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get information about ShellHub instance like version, SSH and API addresses.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInfo(agentVersion?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(uid, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: any): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDevice(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public acceptDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getStatusDevices(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s data.
     * @summary Update device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDevice(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalApiFp(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MfaApi - axios parameter creator
 * @export
 */
export const MfaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MfaApi - functional programming interface
 * @export
 */
export const MfaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MfaApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMFA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaGenerate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMFA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MfaApi - factory interface
 * @export
 */
export const MfaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MfaApiFp(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
         * @summary Generate MFA Credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMFA(options?: any): AxiosPromise<MfaGenerate> {
            return localVarFp.generateMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MfaApi - object-oriented interface
 * @export
 * @class MfaApi
 * @extends {BaseAPI}
 */
export class MfaApi extends BaseAPI {
    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate the credentials to enable a user\'s MFA. The user must save the recovery codes a secure manner. 
     * @summary Generate MFA Credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public generateMFA(options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).generateMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MfaApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return MfaApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespacesApi - axios parameter creator
 * @export
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceRequest?: CreateNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, editNamespaceRequest?: EditNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, editNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * Add a member to a namespace.
         * @summary Add a member to a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceRequest} [createNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, editNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * Add a member to a namespace.
     * @summary Add a member to a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceRequest} [createNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(createNamespaceRequest?: CreateNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(createNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {EditNamespaceRequest} [editNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, editNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceToken(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleAddTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag: async (id: string, ruleAddTagRequest?: RuleAddTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleDeleteTag', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleAddTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags: async (id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleUpdateTags', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdateTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule: async (id: number, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRule', 'id', id)
            const localVarPath = `/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRule(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRules(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleAddTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleDeleteTag(id, ruleAddTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleUpdateTags(id, ruleUpdateTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRule(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRule(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRule(id: number, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRules(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRules(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to firewall rule
         * @summary Add a tag to firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from firewall rule
         * @summary Remove a tag from firewall rule
         * @param {string} id 
         * @param {RuleAddTagRequest} [ruleAddTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags in firewall rule
         * @summary Update tags in firewall rule
         * @param {string} id 
         * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule
         * @param {number} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createFirewallRule(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRule(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRule(id: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRules(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRules(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to firewall rule
     * @summary Add a tag to firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleAddTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleAddTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from firewall rule
     * @summary Remove a tag from firewall rule
     * @param {string} id 
     * @param {RuleAddTagRequest} [ruleAddTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleDeleteTag(id: string, ruleAddTagRequest?: RuleAddTagRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleDeleteTag(id, ruleAddTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags in firewall rule
     * @summary Update tags in firewall rule
     * @param {string} id 
     * @param {RuleUpdateTagsRequest} [ruleUpdateTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public ruleUpdateTags(id: string, ruleUpdateTagsRequest?: RuleUpdateTagsRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).ruleUpdateTags(id, ruleUpdateTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule
     * @param {number} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateFirewallRule(id: number, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRule(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession: async (uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('clsoeSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clsoeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionData', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/play`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession: async (uid: string, recordSessionRequest?: RecordSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('recordSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}/record`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clsoeSession(uid, clsoeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionData(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordedSessionResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionData(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordSession(uid, recordSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Close a session.
         * @summary Close session
         * @param {string} uid 
         * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session recorded data.
         * @summary Get session recorded data
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionData(uid: string, options?: any): AxiosPromise<Array<RecordedSessionResponseInner>> {
            return localVarFp.getSessionData(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Record data about session session.
         * @summary Record session
         * @param {string} uid 
         * @param {RecordSessionRequest} [recordSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recordSession(uid, recordSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Close a session.
     * @summary Close session
     * @param {string} uid 
     * @param {ClsoeSessionRequest} [clsoeSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public clsoeSession(uid: string, clsoeSessionRequest?: ClsoeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).clsoeSession(uid, clsoeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session recorded data.
     * @summary Get session recorded data
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionData(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionData(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record data about session session.
     * @summary Record session
     * @param {string} uid 
     * @param {RecordSessionRequest} [recordSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public recordSession(uid: string, recordSessionRequest?: RecordSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).recordSession(uid, recordSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusRequest} [setSessionAuthenticationStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusRequest?: SetSessionAuthenticationStatusRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SshApi - axios parameter creator
 * @export
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 * @export
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SshApi - factory interface
 * @export
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 * @export
 * @class SshApi
 * @extends {BaseAPI}
 */
export class SshApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public deletePublicKey(fingerprint: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey: async (fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('addTagPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTagPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag: async (uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createDeviceTag', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (uid: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceTag', 'uid', uid)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tag', tag)
            const localVarPath = `/api/devices/{uid}/tags/{tag}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey: async (fingerprint: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('removeTagPublicKey', 'fingerprint', fingerprint)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('removeTagPublicKey', 'tag', tag)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags/{tag}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag: async (tag: string, renameTagRequest?: RenameTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('renameTag', 'tag', tag)
            const localVarPath = `/api/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice: async (uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTagsDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/tags`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey: async (fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updateTagsPublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}/tags`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagsPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceTag(uid, createDeviceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(uid, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTagPublicKey(fingerprint, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameTag(tag, renameTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsDevice(uid, updateTagsDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Add a tag to a public key.
         * @summary Add tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {string} uid Device\&#39;s UID
         * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tag from device.
         * @summary Delete a tag from device
         * @param {string} uid Device\&#39;s UID
         * @param {string} tag Device\&#39;s tag name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(uid: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(uid, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from public key.
         * @summary Remove tag public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {string} tag Tag\&#39;s name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTagPublicKey(fingerprint: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeTagPublicKey(fingerprint, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a tag name.
         * @param {string} tag Tag\&#39;s name.
         * @param {RenameTagRequest} [renameTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.renameTag(tag, renameTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tags to device
         * @summary Update tags to device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags in a public key.
         * @summary Update tags public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Add a tag to a public key.
     * @summary Add tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {AddTagPublicKeyRequest} [addTagPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public addTagPublicKey(fingerprint: string, addTagPublicKeyRequest?: AddTagPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).addTagPublicKey(fingerprint, addTagPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {string} uid Device\&#39;s UID
     * @param {CreateDeviceTagRequest} [createDeviceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createDeviceTag(uid: string, createDeviceTagRequest?: CreateDeviceTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createDeviceTag(uid, createDeviceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tag from device.
     * @summary Delete a tag from device
     * @param {string} uid Device\&#39;s UID
     * @param {string} tag Device\&#39;s tag name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteDeviceTag(uid: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteDeviceTag(uid, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from public key.
     * @summary Remove tag public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {string} tag Tag\&#39;s name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public removeTagPublicKey(fingerprint: string, tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).removeTagPublicKey(fingerprint, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a tag name.
     * @param {string} tag Tag\&#39;s name.
     * @param {RenameTagRequest} [renameTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public renameTag(tag: string, renameTagRequest?: RenameTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).renameTag(tag, renameTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tags to device
     * @summary Update tags to device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateTagsDeviceRequest} [updateTagsDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsDevice(uid: string, updateTagsDeviceRequest?: UpdateTagsDeviceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsDevice(uid, updateTagsDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags in a public key.
     * @summary Update tags public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdateTagsPublicKeyRequest} [updateTagsPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagsPublicKey(fingerprint: string, updateTagsPublicKeyRequest?: UpdateTagsPublicKeyRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagsPublicKey(fingerprint, updateTagsPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA: async (mfaAuth?: MfaAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (mfaDisable?: MfaDisable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (mfaEnable?: MfaEnable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEnable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount: async (email: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getValidateAccount', 'email', email)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getValidateAccount', 'token', token)
            const localVarPath = `/api/user/validation_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover: async (mfaRecover?: MfaRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword: async (recoverPasswordRequest?: RecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/recover_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA: async (requestResetMFARequest?: RequestResetMFARequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestResetMFARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/resend_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA: async (userId?: string, mfaReset?: MfaReset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/mfa/reset/{user-id}`
                .replace(`{${"user-id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword: async (uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateRecoverPassword', 'uid', uid)
            const localVarPath = `/api/user/{uid}/update_password`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecoverPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMFA(mfaAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(mfaDisable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(mfaEnable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateAccount(email: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidateAccount(email, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaRecover(mfaRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPassword(recoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestResetMFA(requestResetMFARequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetMFA(userId, mfaReset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoverPassword(uid, updateRecoverPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
         * @summary Auth MFA
         * @param {MfaAuth} [mfaAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMFA(mfaAuth?: MfaAuth, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authMFA(mfaAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
         * @summary Disable MFA
         * @param {MfaDisable} [mfaDisable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(mfaDisable?: MfaDisable, options?: any): AxiosPromise<void> {
            return localVarFp.disableMFA(mfaDisable, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
         * @summary Enable MFA
         * @param {MfaEnable} [mfaEnable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(mfaEnable?: MfaEnable, options?: any): AxiosPromise<void> {
            return localVarFp.enableMFA(mfaEnable, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status from if `session record` feature is enable.
         * @summary Get session record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.getSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the activation link for user.
         * @summary Validate activation link
         * @param {string} email User\&#39;s email.
         * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidateAccount(email: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getValidateAccount(email, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
         * @summary Recover MFA
         * @param {MfaRecover} [mfaRecover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaRecover(mfaRecover?: MfaRecover, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.mfaRecover(mfaRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a recovery email to the user.
         * @summary Recover password
         * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.recoverPassword(recoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user
         * @summary Register user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.registerUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
         * @summary Request Reset MFA
         * @param {RequestResetMFARequest} [requestResetMFARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestResetMFA(requestResetMFARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend confirmation to user.
         * @summary Resend confirmation
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
         * @summary Reset MFA
         * @param {string} [userId] 
         * @param {MfaReset} [mfaReset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetMFA(userId?: string, mfaReset?: MfaReset, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.resetMFA(userId, mfaReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password from a recovery token got from email.
         * @summary Update user password
         * @param {string} uid User\&#39;s UID.
         * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Authenticate a user who has MFA enabled. This endpoint should be called after the default authUser endpoint, which generates an `X-MFA-Token` indicating that the user has already authenticated with a password. 
     * @summary Auth MFA
     * @param {MfaAuth} [mfaAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authMFA(mfaAuth?: MfaAuth, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authMFA(mfaAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable MFA for a user. To disable MFA, the user must provide either a recovery code or the current MFA code. If a recovery code is used, it will be invalidated for future use.  The recovery code used to regain access to the account can be used within a 10-minute window on this endpoint. 
     * @summary Disable MFA
     * @param {MfaDisable} [mfaDisable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public disableMFA(mfaDisable?: MfaDisable, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).disableMFA(mfaDisable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable MFA for a user. The secret and recovery codes must be created by the generateMFA endpoint. Users with MFA already enabled cannot override their MFA credentials; in these cases, a user must disable MFA before proceeding. The recovery e-mail must be a valid value in order to enable the MFA. 
     * @summary Enable MFA
     * @param {MfaEnable} [mfaEnable] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public enableMFA(mfaEnable?: MfaEnable, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).enableMFA(mfaEnable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status from if `session record` feature is enable.
     * @summary Get session record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSessionRecord(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} [tenant] Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getToken(tenant?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the activation link for user.
     * @summary Validate activation link
     * @param {string} email User\&#39;s email.
     * @param {string} token User\&#39;s validation token.   It is a token received from the email used to validate the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getValidateAccount(email: string, token: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getValidateAccount(email, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and user data.  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover account access by providing one of the user\'s recovery codes. It will be invalidated for future uses.  The recovery code will be cached for 10 minutes. During this period, the user can use the same recovery code to disable their MFA without needing to provide two separate codes. The `X-Expires-At` header specifies the epoch value marking the end of the cache period. 
     * @summary Recover MFA
     * @param {MfaRecover} [mfaRecover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public mfaRecover(mfaRecover?: MfaRecover, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).mfaRecover(mfaRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a recovery email to the user.
     * @summary Recover password
     * @param {RecoverPasswordRequest} [recoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public recoverPassword(recoverPasswordRequest?: RecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).recoverPassword(recoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user
     * @summary Register user
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerUser(user?: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to both the user\'s main and recovery addresses. Each email contains a unique code, which remains valid for at most 1 day. The user must provide both codes to reset their MFA. 
     * @summary Request Reset MFA
     * @param {RequestResetMFARequest} [requestResetMFARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestResetMFA(requestResetMFARequest?: RequestResetMFARequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestResetMFA(requestResetMFARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend confirmation to user.
     * @summary Resend confirmation
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to the `disableMFA` operation, this endpoint uses the two codes sent by `requestResetMFA` instead of a TOTP or recovery code. The user ID must be the same as the one used for `requestResetMFA`. 
     * @summary Reset MFA
     * @param {string} [userId] 
     * @param {MfaReset} [mfaReset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetMFA(userId?: string, mfaReset?: MfaReset, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resetMFA(userId, mfaReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password from a recovery token got from email.
     * @summary Update user password
     * @param {string} uid User\&#39;s UID.
     * @param {UpdateRecoverPasswordRequest} [updateRecoverPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateRecoverPassword(uid: string, updateRecoverPasswordRequest?: UpdateRecoverPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateRecoverPassword(uid, updateRecoverPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} [id] User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


