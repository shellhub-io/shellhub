/* tslint:disable */
/* eslint-disable */
/**
 * ShellHub Enterprise OpenAPI
 * > NOTICE: THE API IS NOT STABLE YET; ERROR AND INCONSISTENCIES MAY OCCUR.  ShellHub Enterprise OpenAPI specification.  It documents all routes provided by ShellHub Enterprise. 
 *
 * The version of the OpenAPI document: 0.20.0
 * Contact: contato@ossystems.com.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddNamespaceMemberRequest
 */
export interface AddNamespaceMemberRequest {
    /**
     * The email of the member.
     * @type {string}
     * @memberof AddNamespaceMemberRequest
     */
    'email': string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof AddNamespaceMemberRequest
     */
    'role': NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface AdminResetUserPassword200Response
 */
export interface AdminResetUserPassword200Response {
    /**
     * The newly generated password
     * @type {string}
     * @memberof AdminResetUserPassword200Response
     */
    'password'?: string;
}
/**
 * Announcement.
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof Announcement
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof Announcement
     */
    'title'?: string;
    /**
     * Announcement description.
     * @type {string}
     * @memberof Announcement
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface AnnouncementShort
 */
export interface AnnouncementShort {
    /**
     * Announcement UUID.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'uuid'?: string;
    /**
     * Announcement title.
     * @type {string}
     * @memberof AnnouncementShort
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementShort
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * The tenant ID of the namespace with which the key is associated.
     * @type {string}
     * @memberof ApiKey
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     * @type {string}
     * @memberof ApiKey
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     * @type {string}
     * @memberof ApiKey
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKey
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     * @type {number}
     * @memberof ApiKey
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     * @type {string}
     * @memberof ApiKey
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyCreate
 */
export interface ApiKeyCreate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'name': string;
    /**
     * Number of days until expiration. Use -1 for no expiration.
     * @type {number}
     * @memberof ApiKeyCreate
     */
    'expires_at': ApiKeyCreateExpiresAtEnum;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. Leave it blank to use the user\'s role. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'role'?: string;
    /**
     * An optional and unique value to be used as the API key\'s internal identifier. This value is the \"internal ID\" and will NEVER be returned to the client. Leave it blank for a random one to be generated. 
     * @type {string}
     * @memberof ApiKeyCreate
     */
    'key'?: string;
}

export const ApiKeyCreateExpiresAtEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_30: 30,
    NUMBER_60: 60,
    NUMBER_90: 90,
    NUMBER_365: 365
} as const;

export type ApiKeyCreateExpiresAtEnum = typeof ApiKeyCreateExpiresAtEnum[keyof typeof ApiKeyCreateExpiresAtEnum];

/**
 * 
 * @export
 * @interface ApiKeyUpdate
 */
export interface ApiKeyUpdate {
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyUpdate
     */
    'name'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. It must be less or equal than the user\'s role. 
     * @type {string}
     * @memberof ApiKeyUpdate
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyWithID
 */
export interface ApiKeyWithID {
    /**
     * The UUID of the API key. It is used only internally and, except for the create operation, is never returned to the client. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'id'?: string;
    /**
     * The tenant ID of the namespace with which the key is associated.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'tenant_id'?: string;
    /**
     * The ID of the user who created the API key.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'created_by'?: string;
    /**
     * The role of the key. It serves as a \"level\" indicating which endpoints the key can access. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'role'?: string;
    /**
     * The name of the API key. This serves as an \"external ID\" since the UUID will never be returned. It is unique per namespace. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'name'?: string;
    /**
     * Epoch time until expiration. It for unlimited keys. 
     * @type {number}
     * @memberof ApiKeyWithID
     */
    'expires_in'?: number;
    /**
     * The UTC date when the key was created.
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'created_at'?: string;
    /**
     * The UTC date when the key was last updated. It is updated whenever the key is modified. 
     * @type {string}
     * @memberof ApiKeyWithID
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface AuthDevice200Response
 */
export interface AuthDevice200Response {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'uid'?: string;
    /**
     * Device\'s token
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'token'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'name'?: string;
    /**
     * Device\'s namespace name
     * @type {string}
     * @memberof AuthDevice200Response
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface AuthDeviceRequest
 */
export interface AuthDeviceRequest {
    /**
     * 
     * @type {DeviceInfo}
     * @memberof AuthDeviceRequest
     */
    'info': DeviceInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthDeviceRequest
     */
    'sessions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'hostname': string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof AuthDeviceRequest
     */
    'identity'?: DeviceIdentity;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'public_key': string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof AuthDeviceRequest
     */
    'tenant_id': string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKey200Response
 */
export interface AuthSSHPublicKey200Response {
    /**
     * Device\'s signature.
     * @type {string}
     * @memberof AuthSSHPublicKey200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface AuthSSHPublicKeyRequest
 */
export interface AuthSSHPublicKeyRequest {
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'fingerprint': string;
    /**
     * Public key\'s data.
     * @type {string}
     * @memberof AuthSSHPublicKeyRequest
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ConfigureLocalAuthenticationRequest
 */
export interface ConfigureLocalAuthenticationRequest {
    /**
     * Specifies whether to activate (`true`) or deactivate (`false`) local authentication. 
     * @type {boolean}
     * @memberof ConfigureLocalAuthenticationRequest
     */
    'enable': boolean;
}
/**
 * 
 * @export
 * @interface ConfigureSAMLAuthenticationRequest
 */
export interface ConfigureSAMLAuthenticationRequest {
    /**
     * Specifies whether to activate (`true`) or deactivate (`false`) SAML authentication. If set to `false`, all other attributes will be ignored. 
     * @type {boolean}
     * @memberof ConfigureSAMLAuthenticationRequest
     */
    'enable': boolean;
    /**
     * 
     * @type {ConfigureSAMLAuthenticationRequestIdp}
     * @memberof ConfigureSAMLAuthenticationRequest
     */
    'idp': ConfigureSAMLAuthenticationRequestIdp;
    /**
     * 
     * @type {ConfigureSAMLAuthenticationRequestSp}
     * @memberof ConfigureSAMLAuthenticationRequest
     */
    'sp': ConfigureSAMLAuthenticationRequestSp;
}
/**
 * Configuration for the Identity Provider (IdP) that ShellHub will use for authentication.  You can provide either a metadata URL to fetch all necessary information automatically  or specify the `SignOn URL`, `Entity ID`, and `X509 certificate` explicitly. 
 * @export
 * @interface ConfigureSAMLAuthenticationRequestIdp
 */
export interface ConfigureSAMLAuthenticationRequestIdp {
    /**
     * The URL to fetch IdP metadata. If provided, this will automatically retrieve all necessary configuration details and take precedence over manually specified values. 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdp
     */
    'metadata_url'?: string;
    /**
     * The Entity ID of the IdP.
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdp
     */
    'entity_id'?: string;
    /**
     * The public X509 certificate of the IdP. It can be provided with or without  the PEM delimiters (`-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`). 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdp
     */
    'certificate'?: string;
    /**
     * 
     * @type {ConfigureSAMLAuthenticationRequestIdpBinding}
     * @memberof ConfigureSAMLAuthenticationRequestIdp
     */
    'binding'?: ConfigureSAMLAuthenticationRequestIdpBinding;
    /**
     * 
     * @type {ConfigureSAMLAuthenticationRequestIdpMappings}
     * @memberof ConfigureSAMLAuthenticationRequestIdp
     */
    'mappings'?: ConfigureSAMLAuthenticationRequestIdpMappings;
}
/**
 * Configuration for SAML binding methods that define how authentication requests  and responses are transmitted between ShellHub and the IdP. SAML supports  different binding protocols for flexibility in deployment scenarios. 
 * @export
 * @interface ConfigureSAMLAuthenticationRequestIdpBinding
 */
export interface ConfigureSAMLAuthenticationRequestIdpBinding {
    /**
     * The Single Sign-On URL for HTTP-POST binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-POST method, which  sends SAML data in the body of an HTTP POST request. This binding is more  secure as it doesn\'t expose SAML data in URL parameters. 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdpBinding
     */
    'post'?: string;
    /**
     * The Single Sign-On URL for HTTP-Redirect binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-Redirect method, which  sends SAML data as URL parameters. This binding is simpler but has URL length  limitations and exposes SAML data in browser history and server logs. 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdpBinding
     */
    'redirect'?: string;
    /**
     * Specifies which binding method ShellHub should prefer when both POST and  Redirect bindings are available. If only one binding URL is provided,  that binding will be used regardless of this preference setting. If left blank or empty, POST binding is preferred by default. 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdpBinding
     */
    'preferred'?: ConfigureSAMLAuthenticationRequestIdpBindingPreferredEnum;
}

export const ConfigureSAMLAuthenticationRequestIdpBindingPreferredEnum = {
    Post: 'post',
    Redirect: 'redirect'
} as const;

export type ConfigureSAMLAuthenticationRequestIdpBindingPreferredEnum = typeof ConfigureSAMLAuthenticationRequestIdpBindingPreferredEnum[keyof typeof ConfigureSAMLAuthenticationRequestIdpBindingPreferredEnum];

/**
 * Defines how SAML attributes from the IdP should be mapped to ShellHub user attributes. 
 * @export
 * @interface ConfigureSAMLAuthenticationRequestIdpMappings
 */
export interface ConfigureSAMLAuthenticationRequestIdpMappings {
    /**
     * The name of the SAML attribute that contains the user\'s email address. This attribute will be used to identify and authenticate users in ShellHub. For example, if your IdP sends the email in a SAML attribute named \"mail\", set this value to \"mail\". 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdpMappings
     */
    'email'?: string;
    /**
     * The name of the SAML attribute that contains the user\'s display name. This attribute will be used as the user\'s name in ShellHub. For example, if your IdP sends the user\'s name in a SAML attribute  named \"displayName\", set this value to \"displayName\". 
     * @type {string}
     * @memberof ConfigureSAMLAuthenticationRequestIdpMappings
     */
    'name'?: string;
}
/**
 * Configuration settings for how ShellHub will function as a Service Provider (SP).
 * @export
 * @interface ConfigureSAMLAuthenticationRequestSp
 */
export interface ConfigureSAMLAuthenticationRequestSp {
    /**
     * Indicates whether ShellHub should sign authentication requests.  If `true`, ShellHub will generate a public X509 certificate that must be deployed on the IdP for validation.  The IdP-initiated workflow is not supported when this option is enabled. 
     * @type {boolean}
     * @memberof ConfigureSAMLAuthenticationRequestSp
     */
    'sign_requests'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateAnnouncementRequest
 */
export interface CreateAnnouncementRequest {
    /**
     * Announcement title.
     * @type {string}
     * @memberof CreateAnnouncementRequest
     */
    'title'?: string;
    /**
     * Announcement description.
     * @type {string}
     * @memberof CreateAnnouncementRequest
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface CreateNamespaceAdminRequest
 */
export interface CreateNamespaceAdminRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof CreateNamespaceAdminRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreatePublicKey200Response
 */
export interface CreatePublicKey200Response {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'fingerprint'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof CreatePublicKey200Response
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof CreatePublicKey200Response
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CreateTagRequest
 */
export interface CreateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Device
     */
    'uid'?: string;
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceIdentity}
     * @memberof Device
     */
    'identity'?: DeviceIdentity;
    /**
     * 
     * @type {DeviceInfo}
     * @memberof Device
     */
    'info'?: DeviceInfo;
    /**
     * Device\'s public key.
     * @type {string}
     * @memberof Device
     */
    'public_key'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Device
     */
    'tenant_id'?: string;
    /**
     * Device\'s last seen date
     * @type {string}
     * @memberof Device
     */
    'last_seen'?: string;
    /**
     * Device\'s availability status
     * @type {boolean}
     * @memberof Device
     */
    'online'?: boolean;
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Device
     */
    'namespace'?: string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof Device
     */
    'status'?: DeviceStatus;
    /**
     * Device\'s status update date
     * @type {string}
     * @memberof Device
     */
    'status_update_at'?: string;
    /**
     * Device\'s creation date
     * @type {string}
     * @memberof Device
     */
    'created_at'?: string;
    /**
     * Device\'s remote address
     * @type {string}
     * @memberof Device
     */
    'remote_addr'?: string;
    /**
     * 
     * @type {DevicePosition}
     * @memberof Device
     */
    'position'?: DevicePosition;
    /**
     * Device\'s Tags list
     * @type {Array<Tag>}
     * @memberof Device
     */
    'tags'?: Array<Tag>;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof Device
     */
    'public_url'?: boolean;
    /**
     * Device\'s acceptable  The value \"acceptable\" is based on the number of devices removed and already accepted into a namespace. All devices are \"acceptable\" unless the \"namespace.max_devices\" is reached. This limit is set based on the sum up of accepted and removed devices into the namespace. When this limit is reached, only removed devices between 720 hours or 30 days are set to \"acceptable\". 
     * @type {boolean}
     * @memberof Device
     */
    'acceptable'?: boolean;
}
/**
 * Device\'s identity
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * Device\'s MAC
     * @type {string}
     * @memberof DeviceIdentity
     */
    'mac'?: string;
}
/**
 * Device\'s info
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * Device\'s OS name
     * @type {string}
     * @memberof DeviceInfo
     */
    'id'?: string;
    /**
     * Device\'s OS pretty name
     * @type {string}
     * @memberof DeviceInfo
     */
    'pretty_name'?: string;
    /**
     * Device\'s OS version
     * @type {string}
     * @memberof DeviceInfo
     */
    'version'?: string;
    /**
     * Device\'s OS arch
     * @type {string}
     * @memberof DeviceInfo
     */
    'arch'?: string;
    /**
     * Device\'s OS platform
     * @type {string}
     * @memberof DeviceInfo
     */
    'platform'?: DeviceInfoPlatformEnum;
}

export const DeviceInfoPlatformEnum = {
    Docker: 'docker',
    Native: 'native'
} as const;

export type DeviceInfoPlatformEnum = typeof DeviceInfoPlatformEnum[keyof typeof DeviceInfoPlatformEnum];

/**
 * Device\'s geolocation position
 * @export
 * @interface DevicePosition
 */
export interface DevicePosition {
    /**
     * Device\'s latitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'latitude'?: number;
    /**
     * Device\'s longitude position
     * @type {number}
     * @memberof DevicePosition
     */
    'longitude'?: number;
}
/**
 * Device\'s status
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Pending: 'pending',
    Removed: 'removed',
    Unused: 'unused'
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface EditNamespaceRequest
 */
export interface EditNamespaceRequest {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof EditNamespaceRequest
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof EditNamespaceRequest
     */
    'settings'?: NamespaceSettings;
}
/**
 * 
 * @export
 * @interface FirewallRulesRequest
 */
export interface FirewallRulesRequest {
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'action': FirewallRulesRequestActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesRequest
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesRequest
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesRequest
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesRequest
     */
    'username': string;
}

export const FirewallRulesRequestActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesRequestActionEnum = typeof FirewallRulesRequestActionEnum[keyof typeof FirewallRulesRequestActionEnum];

/**
 * 
 * @export
 * @interface FirewallRulesResponse
 */
export interface FirewallRulesResponse {
    /**
     * Firewall rule\'s ID.
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'id'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'tenant_id': string;
    /**
     * Firewall rule\'s action
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'action': FirewallRulesResponseActionEnum;
    /**
     * Firewall rule active\'s status
     * @type {boolean}
     * @memberof FirewallRulesResponse
     */
    'active': boolean;
    /**
     * 
     * @type {FirewallRulesResponseFilter}
     * @memberof FirewallRulesResponse
     */
    'filter': FirewallRulesResponseFilter;
    /**
     * Firewall rule\'s priority
     * @type {number}
     * @memberof FirewallRulesResponse
     */
    'priority': number;
    /**
     * Firewall rule\'s source IP regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'source_ip': string;
    /**
     * Firewall rule\'s username regexp
     * @type {string}
     * @memberof FirewallRulesResponse
     */
    'username': string;
}

export const FirewallRulesResponseActionEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type FirewallRulesResponseActionEnum = typeof FirewallRulesResponseActionEnum[keyof typeof FirewallRulesResponseActionEnum];

/**
 * @type FirewallRulesResponseFilter
 * Firewall rule\'s filter
 * @export
 */
export type FirewallRulesResponseFilter = FirewallRulesResponseFilterOneOf | FirewallRulesResponseFilterOneOf1;

/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf
 */
export interface FirewallRulesResponseFilterOneOf {
    /**
     * Firewall rule\'s hostname
     * @type {string}
     * @memberof FirewallRulesResponseFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface FirewallRulesResponseFilterOneOf1
 */
export interface FirewallRulesResponseFilterOneOf1 {
    /**
     * Firewall\'s rule tags
     * @type {Array<Tag>}
     * @memberof FirewallRulesResponseFilterOneOf1
     */
    'tags': Array<Tag>;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings200Response
 */
export interface GetAuthenticationSettings200Response {
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseLocal}
     * @memberof GetAuthenticationSettings200Response
     */
    'local'?: GetAuthenticationSettings200ResponseLocal;
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseSaml}
     * @memberof GetAuthenticationSettings200Response
     */
    'saml'?: GetAuthenticationSettings200ResponseSaml;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings200ResponseLocal
 */
export interface GetAuthenticationSettings200ResponseLocal {
    /**
     * Indicates whether local authentication is active.
     * @type {boolean}
     * @memberof GetAuthenticationSettings200ResponseLocal
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings200ResponseSaml
 */
export interface GetAuthenticationSettings200ResponseSaml {
    /**
     * Indicates whether SAML authentication is active.
     * @type {boolean}
     * @memberof GetAuthenticationSettings200ResponseSaml
     */
    'enabled'?: boolean;
    /**
     * The URL used to authenticate the SAML user.
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSaml
     */
    'auth_url'?: string;
    /**
     * The URL where the IdP must permit redirects.
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSaml
     */
    'assertion_url'?: string;
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseSamlIdp}
     * @memberof GetAuthenticationSettings200ResponseSaml
     */
    'idp'?: GetAuthenticationSettings200ResponseSamlIdp;
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseSamlSp}
     * @memberof GetAuthenticationSettings200ResponseSaml
     */
    'sp'?: GetAuthenticationSettings200ResponseSamlSp;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings200ResponseSamlIdp
 */
export interface GetAuthenticationSettings200ResponseSamlIdp {
    /**
     * The Entity ID of the IdP.
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdp
     */
    'entity_id'?: string;
    /**
     * The list of public X509 certificates of the IdP.
     * @type {Array<string>}
     * @memberof GetAuthenticationSettings200ResponseSamlIdp
     */
    'certificates'?: Array<string>;
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseSamlIdpBinding}
     * @memberof GetAuthenticationSettings200ResponseSamlIdp
     */
    'binding'?: GetAuthenticationSettings200ResponseSamlIdpBinding;
    /**
     * 
     * @type {GetAuthenticationSettings200ResponseSamlIdpMappings}
     * @memberof GetAuthenticationSettings200ResponseSamlIdp
     */
    'mappings'?: GetAuthenticationSettings200ResponseSamlIdpMappings;
}
/**
 * Configuration for SAML binding methods that define how authentication requests  and responses are transmitted between ShellHub and the IdP. 
 * @export
 * @interface GetAuthenticationSettings200ResponseSamlIdpBinding
 */
export interface GetAuthenticationSettings200ResponseSamlIdpBinding {
    /**
     * The Single Sign-On URL for HTTP-POST binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-POST method. 
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdpBinding
     */
    'post'?: string;
    /**
     * The Single Sign-On URL for HTTP-Redirect binding. This URL is where ShellHub  will redirect users for authentication using the HTTP-Redirect method. 
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdpBinding
     */
    'redirect'?: string;
    /**
     * Specifies which binding method ShellHub prefers when both POST and  Redirect bindings are available. If left blank or empty, POST binding is preferred. 
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdpBinding
     */
    'preferred'?: GetAuthenticationSettings200ResponseSamlIdpBindingPreferredEnum;
}

export const GetAuthenticationSettings200ResponseSamlIdpBindingPreferredEnum = {
    Post: 'post',
    Redirect: 'redirect'
} as const;

export type GetAuthenticationSettings200ResponseSamlIdpBindingPreferredEnum = typeof GetAuthenticationSettings200ResponseSamlIdpBindingPreferredEnum[keyof typeof GetAuthenticationSettings200ResponseSamlIdpBindingPreferredEnum];

/**
 * 
 * @export
 * @interface GetAuthenticationSettings200ResponseSamlIdpMappings
 */
export interface GetAuthenticationSettings200ResponseSamlIdpMappings {
    /**
     * 
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdpMappings
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthenticationSettings200ResponseSamlIdpMappings
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings200ResponseSamlSp
 */
export interface GetAuthenticationSettings200ResponseSamlSp {
    /**
     * Indicates whether ShellHub signs authentication requests.
     * @type {boolean}
     * @memberof GetAuthenticationSettings200ResponseSamlSp
     */
    'sign_requests'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings401Response
 */
export interface GetAuthenticationSettings401Response {
    /**
     * Error message
     * @type {string}
     * @memberof GetAuthenticationSettings401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetAuthenticationSettings404Response
 */
export interface GetAuthenticationSettings404Response {
    /**
     * Error message.
     * @type {string}
     * @memberof GetAuthenticationSettings404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetLicense200Response
 */
export interface GetLicense200Response {
    /**
     * License\'s ID
     * @type {string}
     * @memberof GetLicense200Response
     */
    'id': string;
    /**
     * License\'s expired status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'expired': boolean;
    /**
     * License\'s about to expire status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'about_to_expire': boolean;
    /**
     * License\'s grace period status
     * @type {boolean}
     * @memberof GetLicense200Response
     */
    'grace_period': boolean;
    /**
     * License\'s issued at  It is the number of seconds elapsed since January 1, 1970 UTC.
     * @type {number}
     * @memberof GetLicense200Response
     */
    'issued_at': number;
    /**
     * License\'s started at  It is the number of seconds elapsed since January 1, 1970 UTC.
     * @type {number}
     * @memberof GetLicense200Response
     */
    'starts_at': number;
    /**
     * License\'s expired at  It is the number of seconds elapsed since January 1, 1970 UTC.  `-1` means license does not expire
     * @type {number}
     * @memberof GetLicense200Response
     */
    'expires_at': number;
    /**
     * License\'s allowed regions  It is a list of regions in `ISO 3166-1 alpha-2` format.
     * @type {Array<string>}
     * @memberof GetLicense200Response
     */
    'allowed_regions': Array<GetLicense200ResponseAllowedRegionsEnum>;
    /**
     * 
     * @type {GetLicense200ResponseCustomer}
     * @memberof GetLicense200Response
     */
    'customer': GetLicense200ResponseCustomer;
    /**
     * 
     * @type {GetLicense200ResponseFeatures}
     * @memberof GetLicense200Response
     */
    'features': GetLicense200ResponseFeatures;
}

export const GetLicense200ResponseAllowedRegionsEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    Ao: 'AO',
    Aq: 'AQ',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Ax: 'AX',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bl: 'BL',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Bq: 'BQ',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bv: 'BV',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cc: 'CC',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cw: 'CW',
    Cx: 'CX',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Eh: 'EH',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gs: 'GS',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hm: 'HM',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    Im: 'IM',
    In: 'IN',
    Io: 'IO',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mf: 'MF',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Nf: 'NF',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pm: 'PM',
    Pn: 'PN',
    Pr: 'PR',
    Ps: 'PS',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sj: 'SJ',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sx: 'SX',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tf: 'TF',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tk: 'TK',
    Tm: 'TM',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Um: 'UM',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Wf: 'WF',
    Ws: 'WS',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type GetLicense200ResponseAllowedRegionsEnum = typeof GetLicense200ResponseAllowedRegionsEnum[keyof typeof GetLicense200ResponseAllowedRegionsEnum];

/**
 * License\'s customer
 * @export
 * @interface GetLicense200ResponseCustomer
 */
export interface GetLicense200ResponseCustomer {
    /**
     * Customer\'s ID
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'id'?: string;
    /**
     * Customer\'s name
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'name'?: string;
    /**
     * Customer\'s email
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'email'?: string;
    /**
     * Customer\'s company
     * @type {string}
     * @memberof GetLicense200ResponseCustomer
     */
    'company'?: string;
}
/**
 * License\'s features
 * @export
 * @interface GetLicense200ResponseFeatures
 */
export interface GetLicense200ResponseFeatures {
    /**
     * Number of devices allowed   `-1` means unlimited number of devices and any other number means the number of devices allowed 
     * @type {number}
     * @memberof GetLicense200ResponseFeatures
     */
    'devices': number;
    /**
     * Session recording status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'session_recording': boolean;
    /**
     * Firewall rules status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'firewall_rules': boolean;
    /**
     * Reports status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'reports': boolean;
    /**
     * Login link status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'login_link': boolean;
    /**
     * Billing status
     * @type {boolean}
     * @memberof GetLicense200ResponseFeatures
     */
    'billing': boolean;
}
/**
 * 
 * @export
 * @interface GetStats200Response
 */
export interface GetStats200Response {
    /**
     * Number of registered users.
     * @type {number}
     * @memberof GetStats200Response
     */
    'registered_users'?: number;
    /**
     * Number of registered devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'online_devices'?: number;
    /**
     * Number of active sessions.
     * @type {number}
     * @memberof GetStats200Response
     */
    'active_sessions'?: number;
    /**
     * Number of pending devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices.
     * @type {number}
     * @memberof GetStats200Response
     */
    'rejected_devices'?: number;
}
/**
 * 
 * @export
 * @interface GetStatusDevices200Response
 */
export interface GetStatusDevices200Response {
    /**
     * Number of registered devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'registered_devices'?: number;
    /**
     * Number of online devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'online_devices'?: number;
    /**
     * Number of pending devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'pending_devices'?: number;
    /**
     * Number of rejected devices
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'rejected_devices'?: number;
    /**
     * Active sessions
     * @type {number}
     * @memberof GetStatusDevices200Response
     */
    'active_sessions'?: number;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {UserAdminResponse}
     * @memberof GetUser200Response
     */
    'user'?: UserAdminResponse;
    /**
     * User\'s integer of owned namespaces
     * @type {number}
     * @memberof GetUser200Response
     */
    'namespacesOwned'?: number;
}
/**
 * 
 * @export
 * @interface GetUserTokenAdmin200Response
 */
export interface GetUserTokenAdmin200Response {
    /**
     * JWT Token
     * @type {string}
     * @memberof GetUserTokenAdmin200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * The current version of ShellHub.
     * @type {string}
     * @memberof Info
     */
    'version'?: string;
    /**
     * 
     * @type {InfoEndpoints}
     * @memberof Info
     */
    'endpoints'?: InfoEndpoints;
    /**
     * Indicates whether the instance setup is complete.
     * @type {boolean}
     * @memberof Info
     */
    'setup'?: boolean;
    /**
     * 
     * @type {InfoAuthentication}
     * @memberof Info
     */
    'authentication'?: InfoAuthentication;
}
/**
 * Authentication methods available for the ShellHub instance.
 * @export
 * @interface InfoAuthentication
 */
export interface InfoAuthentication {
    /**
     * Indicates if local authentication using email and password is enabled.
     * @type {boolean}
     * @memberof InfoAuthentication
     */
    'local'?: boolean;
    /**
     * Indicates if SAML-based single sign-on (SSO) is enabled.
     * @type {boolean}
     * @memberof InfoAuthentication
     */
    'saml'?: boolean;
}
/**
 * Network endpoints for the ShellHub instance.
 * @export
 * @interface InfoEndpoints
 */
export interface InfoEndpoints {
    /**
     * The SSH endpoint where devices connect.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'ssh'?: string;
    /**
     * The API endpoint for managing ShellHub configurations.
     * @type {string}
     * @memberof InfoEndpoints
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface LoginAdmin200Response
 */
export interface LoginAdmin200Response {
    /**
     * JWT token
     * @type {string}
     * @memberof LoginAdmin200Response
     */
    'token'?: string;
    /**
     * username
     * @type {string}
     * @memberof LoginAdmin200Response
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface LoginAdminRequest
 */
export interface LoginAdminRequest {
    /**
     * Admin\'s username
     * @type {string}
     * @memberof LoginAdminRequest
     */
    'username': string;
    /**
     * Admin\'s password
     * @type {string}
     * @memberof LoginAdminRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * User\'s username.
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Namespace\'s name
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof Namespace
     */
    'owner'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Namespace
     */
    'tenant_id'?: string;
    /**
     * Namespace\'s members
     * @type {Array<NamespaceMembersInner>}
     * @memberof Namespace
     */
    'members'?: Array<NamespaceMembersInner>;
    /**
     * 
     * @type {NamespaceSettings}
     * @memberof Namespace
     */
    'settings'?: NamespaceSettings;
    /**
     * Namespace\'s max device numbers
     * @type {number}
     * @memberof Namespace
     */
    'max_devices'?: number;
    /**
     * Namespace\'s total devices
     * @type {number}
     * @memberof Namespace
     */
    'device_count'?: number;
    /**
     * Namespace\'s creation date
     * @type {string}
     * @memberof Namespace
     */
    'created_at'?: string;
    /**
     * Namespace\'s billing
     * @type {object}
     * @memberof Namespace
     */
    'billing'?: object;
    /**
     * Number of devices currently in pending status awaiting approval
     * @type {number}
     * @memberof Namespace
     */
    'devices_pending_count'?: number;
    /**
     * Number of devices that have been accepted and are active in the namespace
     * @type {number}
     * @memberof Namespace
     */
    'devices_accepted_count'?: number;
    /**
     * Number of devices that have been explicitly rejected from the namespace
     * @type {number}
     * @memberof Namespace
     */
    'devices_rejected_count'?: number;
}
/**
 * Namespace\'s member role
 * @export
 * @enum {string}
 */

export const NamespaceMemberRole = {
    Administrator: 'administrator',
    Operator: 'operator',
    Observer: 'observer',
    Owner: 'owner'
} as const;

export type NamespaceMemberRole = typeof NamespaceMemberRole[keyof typeof NamespaceMemberRole];


/**
 * 
 * @export
 * @interface NamespaceMembersInner
 */
export interface NamespaceMembersInner {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'id'?: string;
    /**
     * The time when the member was invited.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'added_at'?: string;
    /**
     * **NOTE: ONLY USED IN CLOUD INSTANCE.**  The time when the invite expires. If the member is not in `pending` status, this will be set to the zero UTC time. 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'expires_at'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof NamespaceMembersInner
     */
    'role'?: NamespaceMemberRole;
    /**
     * this field, on majority of cases is default \'personal\', if the running instance of shellhub is cloud, the default value is \'team\'.  This field requires a valid input of either \'personal\' or \'team\'. the default will match the current Shellhub instance type. When a \"type\" field value is specified, it will override the default, but must be either \'personal\' or \'team\'. Any other input will be rejected. 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'type'?: NamespaceMembersInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'status'?: NamespaceMembersInnerStatusEnum;
    /**
     * Member\'s email.
     * @type {string}
     * @memberof NamespaceMembersInner
     */
    'email'?: string;
}

export const NamespaceMembersInnerTypeEnum = {
    Personal: 'personal',
    Team: 'team'
} as const;

export type NamespaceMembersInnerTypeEnum = typeof NamespaceMembersInnerTypeEnum[keyof typeof NamespaceMembersInnerTypeEnum];
export const NamespaceMembersInnerStatusEnum = {
    Accepted: 'accepted',
    Pending: 'pending'
} as const;

export type NamespaceMembersInnerStatusEnum = typeof NamespaceMembersInnerStatusEnum[keyof typeof NamespaceMembersInnerStatusEnum];

/**
 * Namespace\'s settings.
 * @export
 * @interface NamespaceSettings
 */
export interface NamespaceSettings {
    /**
     * The session records define when the namespace should save or not record a session. This can be used to check logged activity when connecting to a device.
     * @type {boolean}
     * @memberof NamespaceSettings
     */
    'session_record'?: boolean;
    /**
     * A connection announcement is a custom string written during a session when a connection is established on a device within the namespace.
     * @type {string}
     * @memberof NamespaceSettings
     */
    'connection_announcement'?: string;
}
/**
 * @type PublicKeyFilter
 * Public key\'s filter rule.   The `filter`` rule defines how if the public key is valid to a device.  - When `hostname` object is set, the public key will be used in a device what matches with hostname. - When `tags` object is set, it matches the device what contains at least one of that tags. 
 * @export
 */
export type PublicKeyFilter = PublicKeyFilterOneOf | PublicKeyFilterOneOf1;

/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf
 */
export interface PublicKeyFilterOneOf {
    /**
     * Public key\'s regex hostname.
     * @type {string}
     * @memberof PublicKeyFilterOneOf
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PublicKeyFilterOneOf1
 */
export interface PublicKeyFilterOneOf1 {
    /**
     * Public key\'s tags.
     * @type {Set<Tag>}
     * @memberof PublicKeyFilterOneOf1
     */
    'tags': Set<Tag>;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'data': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyRequest
     */
    'filter': PublicKeyFilter;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PublicKeyResponse
 */
export interface PublicKeyResponse {
    /**
     * Public key\'s data.  The `data` field receives the public key enconded as `base64` string. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'data'?: string;
    /**
     * Public key\'s fingerprint.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'fingerprint'?: string;
    /**
     * Public key\'s creation date.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'created_at'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'tenant_id'?: string;
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'name'?: string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof PublicKeyResponse
     */
    'filter'?: PublicKeyFilter;
    /**
     * Public key\'s regex username.   The `username` field define which user, in the device, may be access through this public key. 
     * @type {string}
     * @memberof PublicKeyResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ResolveDevice404Response
 */
export interface ResolveDevice404Response {
    /**
     * 
     * @type {string}
     * @memberof ResolveDevice404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session\'s UID
     * @type {string}
     * @memberof Session
     */
    'uid'?: string;
    /**
     * Device\'s UID
     * @type {string}
     * @memberof Session
     */
    'device_uid'?: string;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device'?: Device;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof Session
     */
    'tenant_id'?: string;
    /**
     * Session\'s username
     * @type {string}
     * @memberof Session
     */
    'username'?: string;
    /**
     * Session\'s IP address
     * @type {string}
     * @memberof Session
     */
    'ip_address'?: string;
    /**
     * Session\'s started date
     * @type {string}
     * @memberof Session
     */
    'started_at'?: string;
    /**
     * Session\'s last seen date
     * @type {string}
     * @memberof Session
     */
    'last_seen'?: string;
    /**
     * Session\'s active status
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * Session\'s authenticated status
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
    /**
     * Session\'s recorded status
     * @type {boolean}
     * @memberof Session
     */
    'recorded'?: boolean;
    /**
     * Session\'s type
     * @type {string}
     * @memberof Session
     */
    'type'?: SessionTypeEnum;
    /**
     * Session\'s terminal
     * @type {string}
     * @memberof Session
     */
    'term'?: string;
    /**
     * 
     * @type {SessionPosition}
     * @memberof Session
     */
    'position'?: SessionPosition;
    /**
     * 
     * @type {SessionEvents}
     * @memberof Session
     */
    'events'?: SessionEvents;
}

export const SessionTypeEnum = {
    Web: 'web',
    Term: 'term'
} as const;

export type SessionTypeEnum = typeof SessionTypeEnum[keyof typeof SessionTypeEnum];

/**
 * Session\'s events
 * @export
 * @interface SessionEvents
 */
export interface SessionEvents {
    /**
     * Session\'s set of types
     * @type {Array<string>}
     * @memberof SessionEvents
     */
    'types'?: Array<string>;
    /**
     * Session\'s seats
     * @type {Array<number>}
     * @memberof SessionEvents
     */
    'seats'?: Array<number>;
    /**
     * Session\'s list of events
     * @type {Array<SessionEventsItemsInner>}
     * @memberof SessionEvents
     */
    'items'?: Array<SessionEventsItemsInner>;
}
/**
 * 
 * @export
 * @interface SessionEventsItemsInner
 */
export interface SessionEventsItemsInner {
    /**
     * The type of the event
     * @type {string}
     * @memberof SessionEventsItemsInner
     */
    'type'?: string;
    /**
     * The time the event occurred in ISO 8601 format
     * @type {string}
     * @memberof SessionEventsItemsInner
     */
    'timestamp'?: string;
    /**
     * Additional data related to the event
     * @type {object}
     * @memberof SessionEventsItemsInner
     */
    'data'?: object;
    /**
     * Seat where the event happened
     * @type {number}
     * @memberof SessionEventsItemsInner
     */
    'seat'?: number;
}
/**
 * Session\'s geolocation position
 * @export
 * @interface SessionPosition
 */
export interface SessionPosition {
    /**
     * Session\'s latitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'latitude'?: number;
    /**
     * Session\'s longitude position
     * @type {number}
     * @memberof SessionPosition
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface SetSessionAuthenticationStatusAdminRequest
 */
export interface SetSessionAuthenticationStatusAdminRequest {
    /**
     * Session\'s authentication status.
     * @type {boolean}
     * @memberof SetSessionAuthenticationStatusAdminRequest
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SetSessionRecordRequest
 */
export interface SetSessionRecordRequest {
    /**
     * Session\'s record status.
     * @type {boolean}
     * @memberof SetSessionRecordRequest
     */
    'session_record'?: boolean;
}
/**
 * 
 * @export
 * @interface SetupRequest
 */
export interface SetupRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof SetupRequest
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof SetupRequest
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof SetupRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof SetupRequest
     */
    'password': string;
}
/**
 * A tag represents a label or category that can be attached to devices, firewall rules and public keys for organization and filtering purposes. 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * The display name of the tag
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDeviceNameAdminRequest
 */
export interface UpdateDeviceNameAdminRequest {
    /**
     * Device\'s new name.
     * @type {string}
     * @memberof UpdateDeviceNameAdminRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * Device\'s name   By default, the name is the device\'s MAC address when it just added. 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    'name'?: string;
    /**
     * Device\'s public URL status.
     * @type {boolean}
     * @memberof UpdateDeviceRequest
     */
    'public_url'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateNamespaceMemberRequest
 */
export interface UpdateNamespaceMemberRequest {
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UpdateNamespaceMemberRequest
     */
    'role'?: NamespaceMemberRole;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key\'s name.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'name': string;
    /**
     * Public key\'s username.
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'username': string;
    /**
     * 
     * @type {PublicKeyFilter}
     * @memberof UpdatePublicKeyRequest
     */
    'filter': PublicKeyFilter;
}
/**
 * 
 * @export
 * @interface UpdateTagRequest
 */
export interface UpdateTagRequest {
    /**
     * New tag name
     * @type {string}
     * @memberof UpdateTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateUserDataRequest
 */
export interface UpdateUserDataRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'name'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'username'?: string;
    /**
     * User\'s e-mail.
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'email'?: string;
    /**
     * User\'s recovery e-mail. A recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UpdateUserDataRequest
     */
    'recovery_email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * User current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'current_password'?: string;
    /**
     * User new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * A recovery email serves as the user\'s final recourse to regain access to their account. It cannot be the same as the user\'s primary email. Once defined, it cannot be updated to an empty value. 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'recovery_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'password'?: string;
    /**
     * It\'s required when updating the user\'s password. 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'current_password'?: string;
}
/**
 * 
 * @export
 * @interface UserAdminRequest
 */
export interface UserAdminRequest {
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'name': string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'email': string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'username': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof UserAdminRequest
     */
    'password': string;
    /**
     * User\'s email confirmed.
     * @type {boolean}
     * @memberof UserAdminRequest
     */
    'confirmed'?: boolean;
    /**
     * Indicates the maximum number of namespaces a user is allowed to create. If set to 0, the user is not permitted to create any namespaces. If set to -1, the user has no limit on the number of namespaces they can create.
     * @type {number}
     * @memberof UserAdminRequest
     */
    'max_namespaces'?: number;
}
/**
 * 
 * @export
 * @interface UserAdminResponse
 */
export interface UserAdminResponse {
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'id'?: string;
    /**
     * User\'s integer of owned namespaces.
     * @type {number}
     * @memberof UserAdminResponse
     */
    'namespaces'?: number;
    /**
     * User\'s confirmation.
     * @type {boolean}
     * @memberof UserAdminResponse
     */
    'confirmed'?: boolean;
    /**
     * User\'s creating date.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'created_at'?: string;
    /**
     * User\'s last login date.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'last_login'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'email'?: string;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'username'?: string;
    /**
     * User\'s hashed password.
     * @type {string}
     * @memberof UserAdminResponse
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * JWT Token
     * @type {string}
     * @memberof UserAuth
     */
    'token'?: string;
    /**
     * User\'s ID.
     * @type {string}
     * @memberof UserAuth
     */
    'id'?: string;
    /**
     * 
     * @type {UserOrigin}
     * @memberof UserAuth
     */
    'origin'?: UserOrigin;
    /**
     * User\'s username.
     * @type {string}
     * @memberof UserAuth
     */
    'user'?: string;
    /**
     * User\'s name.
     * @type {string}
     * @memberof UserAuth
     */
    'name'?: string;
    /**
     * User\'s E-mail.
     * @type {string}
     * @memberof UserAuth
     */
    'email'?: string;
    /**
     * The recovery email serves as the user\'s final recourse to regain access to their account. 
     * @type {string}
     * @memberof UserAuth
     */
    'recovery_email'?: string;
    /**
     * Namespace\'s tenant ID
     * @type {string}
     * @memberof UserAuth
     */
    'tenant'?: string;
    /**
     * 
     * @type {NamespaceMemberRole}
     * @memberof UserAuth
     */
    'role'?: NamespaceMemberRole;
    /**
     * Indicates whether the user has MFA enabled.
     * @type {boolean}
     * @memberof UserAuth
     */
    'mfa'?: boolean;
    /**
     * Indicates the maximum number of namespaces a user is allowed to create. If set to 0, the user is not permitted to create any namespaces. If set to -1, the user has no limit on the number of namespaces they can create.
     * @type {number}
     * @memberof UserAuth
     */
    'max_namespaces'?: number;
}
/**
 * Specifies the method the user employed to register with ShellHub.
 * @export
 * @enum {string}
 */

export const UserOrigin = {
    Local: 'local'
} as const;

export type UserOrigin = typeof UserOrigin[keyof typeof UserOrigin];



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminResetUserPassword', 'id', id)
            const localVarPath = `/admin/api/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication: async (configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureLocalAuthenticationRequest' is not null or undefined
            assertParamExists('configureLocalAuthentication', 'configureLocalAuthenticationRequest', configureLocalAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureLocalAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication: async (configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureSAMLAuthenticationRequest' is not null or undefined
            assertParamExists('configureSAMLAuthentication', 'configureSAMLAuthenticationRequest', configureSAMLAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureSAMLAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (createAnnouncementRequest?: CreateAnnouncementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncementAdmin', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin: async (loginAdminRequest?: LoginAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminResetUserPassword(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminResetUserPassword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(id, userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLocalAuthentication(configureLocalAuthenticationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(createAnnouncementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementAdmin(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementAdmin(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticationSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticationSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncementsAdmin(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAdmin(loginAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(uuid, createAnnouncementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword(id: string, options?: any): AxiosPromise<AdminResetUserPassword200Response> {
            return localVarFp.adminResetUserPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adminUpdateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: any): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.deleteAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: any): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncementAdmin(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings(options?: any): AxiosPromise<GetAuthenticationSettings200Response> {
            return localVarFp.getAuthenticationSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: string, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: any): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: any): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Login on Admin
         * @summary Login on Admin
         * @param {LoginAdminRequest} [loginAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: any): AxiosPromise<LoginAdmin200Response> {
            return localVarFp.loginAdmin(loginAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: any): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
     * @summary Reset user password
     * @param {string} id The ID of the user whose password needs to be reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminResetUserPassword(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminResetUserPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure local authentication settings for the ShellHub instance.
     * @summary Configure Local Authentication
     * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
     * @summary Configure SAML Authentication
     * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an announcement.
     * @summary Create an announcement
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createAnnouncement(createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an announcement.
     * @summary Delete an announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteFirewallRuleAdmin(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAnnouncementAdmin(uuid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAnnouncementAdmin(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current authentication settings.
     * @summary Get Authentication Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAuthenticationSettings(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAuthenticationSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getFirewallRuleAdmin(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getLicense(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionAdmin(uid: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUserTokenAdmin(id: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login on Admin
     * @summary Login on Admin
     * @param {LoginAdminRequest} [loginAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public loginAdmin(loginAdminRequest?: LoginAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).loginAdmin(loginAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {any} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public sendLicense(file?: any, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an announcement.
     * @summary Update an announcement
     * @param {string} uuid 
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncement', 'uuid', uuid)
            const localVarPath = `/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncements(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncements(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public listAnnouncements(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key?: string, apiKeyUpdate?: ApiKeyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: any): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyDelete(key?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} [key] 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationSettingsApi - axios parameter creator
 * @export
 */
export const AuthenticationSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication: async (configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureLocalAuthenticationRequest' is not null or undefined
            assertParamExists('configureLocalAuthentication', 'configureLocalAuthenticationRequest', configureLocalAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureLocalAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication: async (configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureSAMLAuthenticationRequest' is not null or undefined
            assertParamExists('configureSAMLAuthentication', 'configureSAMLAuthenticationRequest', configureSAMLAuthenticationRequest)
            const localVarPath = `/admin/api/authentication/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureSAMLAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationSettingsApi - functional programming interface
 * @export
 */
export const AuthenticationSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLocalAuthentication(configureLocalAuthenticationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticationSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticationSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationSettingsApi - factory interface
 * @export
 */
export const AuthenticationSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationSettingsApiFp(configuration)
    return {
        /**
         * Configure local authentication settings for the ShellHub instance.
         * @summary Configure Local Authentication
         * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
         * @summary Configure SAML Authentication
         * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current authentication settings.
         * @summary Get Authentication Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticationSettings(options?: any): AxiosPromise<GetAuthenticationSettings200Response> {
            return localVarFp.getAuthenticationSettings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationSettingsApi - object-oriented interface
 * @export
 * @class AuthenticationSettingsApi
 * @extends {BaseAPI}
 */
export class AuthenticationSettingsApi extends BaseAPI {
    /**
     * Configure local authentication settings for the ShellHub instance.
     * @summary Configure Local Authentication
     * @param {ConfigureLocalAuthenticationRequest} configureLocalAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationSettingsApi
     */
    public configureLocalAuthentication(configureLocalAuthenticationRequest: ConfigureLocalAuthenticationRequest, options?: AxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).configureLocalAuthentication(configureLocalAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure SAML authentication settings for the ShellHub instance.  The NameID in the SAML assertion from the IdP must be configured to use a format that provides a unique and persistent identifier for each user. This could be a persistent ID, email address, or any other attribute that uniquely identifies the user within your IdP. 
     * @summary Configure SAML Authentication
     * @param {ConfigureSAMLAuthenticationRequest} configureSAMLAuthenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationSettingsApi
     */
    public configureSAMLAuthentication(configureSAMLAuthenticationRequest: ConfigureSAMLAuthenticationRequest, options?: AxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).configureSAMLAuthentication(configureSAMLAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current authentication settings.
     * @summary Get Authentication Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationSettingsApi
     */
    public getAuthenticationSettings(options?: AxiosRequestConfig) {
        return AuthenticationSettingsApiFp(this.configuration).getAuthenticationSettings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudApi - axios parameter creator
 * @export
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (createAnnouncementRequest?: CreateAnnouncementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAnnouncementAdmin', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateAnnouncement', 'uuid', uuid)
            const localVarPath = `/admin/api/announcements/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 * @export
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(createAnnouncementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementAdmin(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementAdmin(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnouncementShort>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAnnouncementsAdmin(page, perPage, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(uuid, createAnnouncementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudApi - factory interface
 * @export
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Create an announcement.
         * @summary Create an announcement
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: any): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an announcement.
         * @summary Delete an announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.deleteAnnouncement(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a announcement.
         * @summary Get a announcement
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementAdmin(uuid: string, options?: any): AxiosPromise<Announcement> {
            return localVarFp.getAnnouncementAdmin(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List the announcements posted by ShellHub Cloud.
         * @summary List announcements
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<AnnouncementShort>> {
            return localVarFp.listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an announcement.
         * @summary Update an announcement
         * @param {string} uuid 
         * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: any): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudApi - object-oriented interface
 * @export
 * @class CloudApi
 * @extends {BaseAPI}
 */
export class CloudApi extends BaseAPI {
    /**
     * Create an announcement.
     * @summary Create an announcement
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public createAnnouncement(createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).createAnnouncement(createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an announcement.
     * @summary Delete an announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public deleteAnnouncement(uuid: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).deleteAnnouncement(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a announcement.
     * @summary Get a announcement
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public getAnnouncementAdmin(uuid: string, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).getAnnouncementAdmin(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the announcements posted by ShellHub Cloud.
     * @summary List announcements
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public listAnnouncementsAdmin(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).listAnnouncementsAdmin(page, perPage, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an announcement.
     * @summary Update an announcement
     * @param {string} uuid 
     * @param {CreateAnnouncementRequest} [createAnnouncementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudApi
     */
    public updateAnnouncement(uuid: string, createAnnouncementRequest?: CreateAnnouncementRequest, options?: AxiosRequestConfig) {
        return CloudApiFp(this.configuration).updateAnnouncement(uuid, createAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainer', 'uid', uid)
            const localVarPath = `/api/containers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateContainerStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateContainerStatus', 'status', status)
            const localVarPath = `/api/containers/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainers(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(uid, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainerStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Delete a container.
         * @summary Delete container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a container.
         * @summary Get container
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getContainer(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of containers.
         * @summary Get containers
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Container\&#39;s status
         * @param {string} [sortBy] Container\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s data.
         * @summary Update container
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateContainer(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container\'s status.
         * @summary Update container status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateContainerStatus(uid, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Delete a container.
     * @summary Delete container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public deleteContainer(uid: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).deleteContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a container.
     * @summary Get container
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainer(uid: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainer(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of containers.
     * @summary Get containers
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Container\&#39;s status
     * @param {string} [sortBy] Container\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainers(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainers(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s data.
     * @summary Update container
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container\'s status.
     * @summary Update container status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Container\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainerStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainerStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acceptDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}/accept`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDeviceAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin: async (filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice: async (hostname?: string, uid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (uid: string, updateDeviceRequest?: UpdateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDevice', 'uid', uid)
            const localVarPath = `/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin: async (uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceNameAdmin', 'uid', uid)
            const localVarPath = `/admin/api/devices/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceNameAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatus', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatus', 'status', status)
            const localVarPath = `/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin: async (uid: string, status: DeviceStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'uid', uid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateDeviceStatusAdmin', 'status', status)
            const localVarPath = `/admin/api/devices/{uid}/{status}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusDevices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveDevice(hostname?: string, uid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveDevice(hostname, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(uid, updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatus(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusAdmin(uid, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Change device status to `accepted`.
         * @summary Accept device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a device.
         * @summary Delete device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceAdmin(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a device.
         * @summary Get device admin
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAdmin(uid: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Get devices admin
         * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {DeviceStatus} [status] Device\&#39;s status
         * @param {string} [sortBy] Device\&#39;s property to sort of
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats ShellHub instance.
         * @summary Get stats ShellHub instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDevices(options?: any): AxiosPromise<GetStatusDevices200Response> {
            return localVarFp.getStatusDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
         * @summary Resolve Device
         * @param {string} [hostname] The UID of the device
         * @param {string} [uid] The hostname of the device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveDevice(hostname?: string, uid?: string, options?: any): AxiosPromise<Device> {
            return localVarFp.resolveDevice(hostname, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s data.
         * @summary Update device
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDevice(uid, updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s name.
         * @summary Update device name Admin
         * @param {string} uid Device\&#39;s UID
         * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update device status
         * @param {string} uid Device\&#39;s UID
         * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatus(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status.
         * @summary Update status Admin
         * @param {string} uid Device\&#39;s UID
         * @param {DeviceStatus} status Device\&#39;s status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusAdmin(uid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Change device status to `accepted`.
     * @summary Accept device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public acceptDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).acceptDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a device.
     * @summary Delete device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a device.
     * @summary Get device admin
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceAdmin(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Get devices admin
     * @param {string} [filter] Device\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;linux&#x60;.  If you want get only Devices name as &#x60;Linux&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;name\&quot;,           \&quot;operator\&quot;:\&quot;contains\&quot;,           \&quot;value\&quot;:\&quot;linux\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZDAifX1d&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {DeviceStatus} [status] Device\&#39;s status
     * @param {string} [sortBy] Device\&#39;s property to sort of
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevicesAdmin(filter?: string, page?: number, perPage?: number, status?: DeviceStatus, sortBy?: string, orderBy?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevicesAdmin(filter, page, perPage, status, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats ShellHub instance.
     * @summary Get stats ShellHub instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getStatusDevices(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getStatusDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a device using flexible resolution methods. The device can be identified by either its unique identifier (UID) or hostname. The endpoint automatically scopes results to the authenticated tenant\'s namespace for security isolation.  When both UID and hostname are provided, UID takes precedence over hostname. 
     * @summary Resolve Device
     * @param {string} [hostname] The UID of the device
     * @param {string} [uid] The hostname of the device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public resolveDevice(hostname?: string, uid?: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).resolveDevice(hostname, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s data.
     * @summary Update device
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDevice(uid: string, updateDeviceRequest?: UpdateDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDevice(uid, updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s name.
     * @summary Update device name Admin
     * @param {string} uid Device\&#39;s UID
     * @param {UpdateDeviceNameAdminRequest} [updateDeviceNameAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceNameAdmin(uid: string, updateDeviceNameAdminRequest?: UpdateDeviceNameAdminRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceNameAdmin(uid, updateDeviceNameAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update device status
     * @param {string} uid Device\&#39;s UID
     * @param {'accept' | 'reject' | 'pending' | 'unused'} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatus(uid: string, status: 'accept' | 'reject' | 'pending' | 'unused', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatus(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status.
     * @summary Update status Admin
     * @param {string} uid Device\&#39;s UID
     * @param {DeviceStatus} status Device\&#39;s status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatusAdmin(uid: string, status: DeviceStatus, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusAdmin(uid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalApiFp(configuration)
    return {
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return ExternalApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1: async (xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xRealIP !== undefined && xRealIP !== null) {
                localVarHeaderParameter['X-Real-IP'] = String(xRealIP);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDeviceStatusOffline', 'uid', uid)
            const localVarPath = `/internal/devices/{uid}/offline`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDevice_1(xRealIP, authDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceStatusOffline(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
         * @summary Auth device
         * @param {string} [xRealIP] 
         * @param {AuthDeviceRequest} [authDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: any): AxiosPromise<AuthDevice200Response> {
            return localVarFp.authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update device\'s status to offiline.
         * @summary Update device status to offline
         * @param {string} uid Device\&#39;s UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusOffline(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeviceStatusOffline(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a ShellHub agent into the ShellHub server.  Every 30 seconds, this route is hit by ShellHub agent to inform device availability. 
     * @summary Auth device
     * @param {string} [xRealIP] 
     * @param {AuthDeviceRequest} [authDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authDevice_1(xRealIP?: string, authDeviceRequest?: AuthDeviceRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authDevice_1(xRealIP, authDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update device\'s status to offiline.
     * @summary Update device status to offline
     * @param {string} uid Device\&#39;s UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateDeviceStatusOffline(uid: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateDeviceStatusOffline(uid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicense(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicense200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLicense(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLicense(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Get the license data.
         * @summary Get license data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicense(options?: any): AxiosPromise<GetLicense200Response> {
            return localVarFp.getLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Send license data
         * @summary Send license data
         * @param {any} [file] License\\\&#39;s file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLicense(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.sendLicense(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI {
    /**
     * Get the license data.
     * @summary Get license data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public getLicense(options?: AxiosRequestConfig) {
        return LicenseApiFp(this.configuration).getLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send license data
     * @summary Send license data
     * @param {any} [file] License\\\&#39;s file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public sendLicense(file?: any, options?: AxiosRequestConfig) {
        return LicenseApiFp(this.configuration).sendLicense(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public leaveNamespace(tenant: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespacesApi - axios parameter creator
 * @export
 */
export const NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember: async (tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('addNamespaceMember', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate: async (apiKeyCreate?: ApiKeyCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList: async (page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate: async (key?: string, apiKeyUpdate?: ApiKeyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces/api-key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace: async (createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin: async (tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNamespaceAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace: async (tenant: string, editNamespaceRequest?: EditNamespaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('editNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editNamespaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin: async (tenantID: string, namespace?: Namespace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantID' is not null or undefined
            assertParamExists('editNamespaceAdmin', 'tenantID', tenantID)
            const localVarPath = `/admin/api/namespaces-update/{tenantID}`
                .replace(`{${"tenantID"}}`, encodeURIComponent(String(tenantID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceAdmin', 'tenant', tenant)
            const localVarPath = `/admin/api/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getNamespaceToken', 'tenant', tenant)
            const localVarPath = `/api/auth/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace: async (tenant: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('leaveNamespace', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/members`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember: async (tenant: string, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('removeNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('removeNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember: async (tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateNamespaceMember', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateNamespaceMember', 'uid', uid)
            const localVarPath = `/api/namespaces/{tenant}/members/{uid}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNamespaceMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNamespaceMember(tenant, addNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyCreate(apiKeyCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyList(page, perPage, orderBy, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyUpdate(key, apiKeyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespace(createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespace(createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespace(tenant, editNamespaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNamespaceAdmin(tenantID, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceAdmin(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceToken(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaces(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Namespace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveNamespace(tenant: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveNamespace(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Namespace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNamespaceMember(tenant, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespacesApiFp(configuration)
    return {
        /**
         * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
         * @summary Invite member
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
         * @summary Creates an API key.
         * @param {ApiKeyCreate} [apiKeyCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: any): AxiosPromise<ApiKeyWithID> {
            return localVarFp.apiKeyCreate(apiKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an API key
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(key?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API Keys
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {'asc' | 'desc'} [orderBy] 
         * @param {string} [sortBy] The property to sort of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an API key
         * @param {string} [key] 
         * @param {ApiKeyUpdate} [apiKeyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespace(createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a namespace.
         * @summary Create namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace.
         * @summary Delete namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceAdmin(tenant: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {EditNamespaceRequest} [editNamespaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: any): AxiosPromise<Namespace> {
            return localVarFp.editNamespace(tenant, editNamespaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a namespace.
         * @summary Edit namespace admin
         * @param {string} tenantID Namespace\&#39;s tenant ID
         * @param {Namespace} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: any): AxiosPromise<void> {
            return localVarFp.editNamespaceAdmin(tenantID, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
         * @summary export namespace
         * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        exportNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a namespace.
         * @summary Get namespace admin
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAdmin(tenant: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.getNamespaceAdmin(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
         * @summary Get a new namespace\'s token
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceToken(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getNamespaceToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces list
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespaces(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of namespaces.
         * @summary Get namespaces admin
         * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Namespace>> {
            return localVarFp.getNamespacesAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
         * @summary Leave Namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveNamespace(tenant: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.leaveNamespace(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from a namespace.
         * @summary Remove a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMember(tenant: string, uid: string, options?: any): AxiosPromise<Namespace> {
            return localVarFp.removeNamespaceMember(tenant, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member role from a namespace.
         * @summary Update a member from a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Member\&#39;s ID
         * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * Invites a member to a namespace.  In enterprise and community instances, the member will automatically accept the invite and will have an `accepted` status.  In cloud instances, the member will have a `pending` status until they accept the invite via an email sent to them. The invite is valid for **7 days**. If the member was previously invited and the invite is no longer valid, the same route will resend the invite. 
     * @summary Invite member
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {AddNamespaceMemberRequest} [addNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public addNamespaceMember(tenant: string, addNamespaceMemberRequest?: AddNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).addNamespaceMember(tenant, addNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `created_by`, `tenant_id`, and `role` (unless provided in the request body) values will be obtained from the JWT token. 
     * @summary Creates an API key.
     * @param {ApiKeyCreate} [apiKeyCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyCreate(apiKeyCreate?: ApiKeyCreate, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyCreate(apiKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an API key
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyDelete(key?: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyDelete(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API Keys
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {'asc' | 'desc'} [orderBy] 
     * @param {string} [sortBy] The property to sort of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyList(page?: number, perPage?: number, orderBy?: 'asc' | 'desc', sortBy?: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyList(page, perPage, orderBy, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an API key
     * @param {string} [key] 
     * @param {ApiKeyUpdate} [apiKeyUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public apiKeyUpdate(key?: string, apiKeyUpdate?: ApiKeyUpdate, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).apiKeyUpdate(key, apiKeyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespace(createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a namespace.
     * @summary Create namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateNamespaceAdminRequest} [createNamespaceAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespaceAdmin(tenant: string, createNamespaceAdminRequest?: CreateNamespaceAdminRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).createNamespaceAdmin(tenant, createNamespaceAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace.
     * @summary Delete namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).deleteNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {EditNamespaceRequest} [editNamespaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespace(tenant: string, editNamespaceRequest?: EditNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespace(tenant, editNamespaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a namespace.
     * @summary Edit namespace admin
     * @param {string} tenantID Namespace\&#39;s tenant ID
     * @param {Namespace} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public editNamespaceAdmin(tenantID: string, namespace?: Namespace, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).editNamespaceAdmin(tenantID, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export namespaces to csv file. This endpoint has been deprecated and will be removed in v1.0.0. 
     * @summary export namespace
     * @param {string} [filter] Namespace\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;devices&#x60; where the value should be \&#39;gt\&#39; &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;devices\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJkZXZpY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public exportNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).exportNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a namespace.
     * @summary Get namespace admin
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceAdmin(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceAdmin(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route works like a login\'s one; returns a JWT token and extra information about namespace.  You can use this route to swap between namespaces. 
     * @summary Get a new namespace\'s token
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceToken(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaceToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces list
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespaces(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of namespaces.
     * @summary Get namespaces admin
     * @param {string} [filter] Namespaces\&#39;s filter.   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;name&#x60; where the value should &#x60;contains&#x60; &#x60;examplespace&#x60;.  If you want get only Namespaces name as &#x60;examplespace&#x60;, the JSON object will looks like this   &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;:\&quot;property\&quot;,     \&quot;params\&quot;:{       \&quot;name\&quot;:\&quot;name\&quot;,       \&quot;operator\&quot;:\&quot;contains\&quot;,       \&quot;value\&quot;:\&quot;examplespace\&quot;     }   } ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lIiwib3BlcmF0b3IiOiJjb250YWlucyIsInZhbHVlIjoiZXhhbXBsZXNwYWNlIn19XQ&#x3D;&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespacesAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).getNamespacesAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the authenticated user to leave the specified namespace. Owners cannot leave a namespace; they must delete it instead. If the user attempts to leave their current authenticated namespace, the response will provide a new token that excludes this namespace. 
     * @summary Leave Namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public leaveNamespace(tenant: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).leaveNamespace(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from a namespace.
     * @summary Remove a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMember(tenant: string, uid: string, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).removeNamespaceMember(tenant, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member role from a namespace.
     * @summary Update a member from a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Member\&#39;s ID
     * @param {UpdateNamespaceMemberRequest} [updateNamespaceMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public updateNamespaceMember(tenant: string, uid: string, updateNamespaceMemberRequest?: UpdateNamespaceMemberRequest, options?: AxiosRequestConfig) {
        return NamespacesApiFp(this.configuration).updateNamespaceMember(tenant, uid, updateNamespaceMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin: async (firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/firewall/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin: async (id: string, firewallRulesRequest?: FirewallRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFirewallRuleAdmin', 'id', id)
            const localVarPath = `/admin/api/firewall/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firewallRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleAdmin(firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRuleAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRuleAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirewallRulesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallRulesAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleAdmin(id, firewallRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Create a firewall rule.
         * @summary Create firewall rule Admin
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a firewall rule.
         * @summary Delete firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleAdmin(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a firewall rule.
         * @summary Get firewall rule admin
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRuleAdmin(id: string, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.getFirewallRuleAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of firewall rules.
         * @summary Get firewall rules Admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallRulesAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<FirewallRulesResponse>> {
            return localVarFp.getFirewallRulesAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a firewall rule.
         * @summary Update firewall rule admin
         * @param {string} id 
         * @param {FirewallRulesRequest} [firewallRulesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: any): AxiosPromise<FirewallRulesResponse> {
            return localVarFp.updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Create a firewall rule.
     * @summary Create firewall rule Admin
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createFirewallRuleAdmin(firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createFirewallRuleAdmin(firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a firewall rule.
     * @summary Delete firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteFirewallRuleAdmin(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a firewall rule.
     * @summary Get firewall rule admin
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRuleAdmin(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRuleAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of firewall rules.
     * @summary Get firewall rules Admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getFirewallRulesAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getFirewallRulesAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a firewall rule.
     * @summary Update firewall rule admin
     * @param {string} id 
     * @param {FirewallRulesRequest} [firewallRulesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateFirewallRuleAdmin(id: string, firewallRulesRequest?: FirewallRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateFirewallRuleAdmin(id, firewallRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSessionAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatus', 'uid', uid)
            const localVarPath = `/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin: async (uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setSessionAuthenticationStatusAdmin', 'uid', uid)
            const localVarPath = `/admin/api/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionAuthenticationStatusAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAdmin(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAdmin(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsAdmin(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a session.
         * @summary Get session admin
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAdmin(uid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.getSessionAdmin(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessions(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list sessions.
         * @summary Get sessions admin
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAdmin(page?: number, perPage?: number, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSessionsAdmin(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set session authentication status.
         * @summary Set session authentication status admin
         * @param {string} uid 
         * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public checkSessionRecord(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a session.
     * @summary Get session admin
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionAdmin(uid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionAdmin(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list sessions.
     * @summary Get sessions admin
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionsAdmin(page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionsAdmin(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatus(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatus(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set session authentication status.
     * @summary Set session authentication status admin
     * @param {string} uid 
     * @param {SetSessionAuthenticationStatusAdminRequest} [setSessionAuthenticationStatusAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionAuthenticationStatusAdmin(uid: string, setSessionAuthenticationStatusAdminRequest?: SetSessionAuthenticationStatusAdminRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionAuthenticationStatusAdmin(uid, setSessionAuthenticationStatusAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SshApi - axios parameter creator
 * @export
 */
export const SshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey: async (authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/ssh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSSHPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin: async (publicKeyRequest?: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deletePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/sshkeys/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey: async (fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('updatePublicKey', 'fingerprint', fingerprint)
            const localVarPath = `/api/sshkeys/public-keys/{fingerprint}`
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SshApi - functional programming interface
 * @export
 */
export const SshApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SshApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSHPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSSHPublicKey(authSSHPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKeyAdmin(publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeysAdmin(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicKey(fingerprint, updatePublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SshApi - factory interface
 * @export
 */
export const SshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SshApiFp(configuration)
    return {
        /**
         * Authenticate a SSH public key to ShellHub server.
         * @summary Auth SSH public key
         * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: any): AxiosPromise<AuthSSHPublicKey200Response> {
            return localVarFp.authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<CreatePublicKey200Response> {
            return localVarFp.createPublicKey(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new public key.
         * @summary Create public key admin
         * @param {PublicKeyRequest} [publicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key.
         * @summary Delete public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(fingerprint: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicKey(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<PublicKeyResponse>> {
            return localVarFp.getPublicKeys(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list from all public keys.
         * @summary Get public keys admin
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a public key.
         * @summary Update public key
         * @param {string} fingerprint Public key\&#39;s fingerprint.
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<PublicKeyResponse> {
            return localVarFp.updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SshApi - object-oriented interface
 * @export
 * @class SshApi
 * @extends {BaseAPI}
 */
export class SshApi extends BaseAPI {
    /**
     * Authenticate a SSH public key to ShellHub server.
     * @summary Auth SSH public key
     * @param {AuthSSHPublicKeyRequest} [authSSHPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public authSSHPublicKey(authSSHPublicKeyRequest?: AuthSSHPublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).authSSHPublicKey(authSSHPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKey(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKey(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new public key.
     * @summary Create public key admin
     * @param {PublicKeyRequest} [publicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public createPublicKeyAdmin(publicKeyRequest?: PublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).createPublicKeyAdmin(publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key.
     * @summary Delete public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public deletePublicKey(fingerprint: string, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).deletePublicKey(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeys(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeys(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list from all public keys.
     * @summary Get public keys admin
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public getPublicKeysAdmin(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).getPublicKeysAdmin(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a public key.
     * @summary Update public key
     * @param {string} fingerprint Public key\&#39;s fingerprint.
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SshApi
     */
    public updatePublicKey(fingerprint: string, updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: AxiosRequestConfig) {
        return SshApiFp(this.configuration).updatePublicKey(fingerprint, updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Get stats about the ShellHub instance.
         * @summary Get stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<GetStats200Response> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Get stats about the ShellHub instance.
     * @summary Get stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return StatsApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (agentVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (agentVersion !== undefined) {
                localVarQueryParameter['agent_version'] = agentVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup: async (sign: string, setupRequest?: SetupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sign' is not null or undefined
            assertParamExists('setup', 'sign', sign)
            const localVarPath = `/api/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sign !== undefined) {
                localVarQueryParameter['sign'] = sign;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(agentVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(agentVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup(sign: string, setupRequest?: SetupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup(sign, setupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Get information about ShellHub instance like version, SSH and API addresses.
         * @summary Get info
         * @param {string} [agentVersion] Agent\&#39;s version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(agentVersion?: string, options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(agentVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an user and create namespace with the same name as username
         * @summary User setup
         * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
         * @param {SetupRequest} [setupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup(sign: string, setupRequest?: SetupRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setup(sign, setupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Get information about ShellHub instance like version, SSH and API addresses.
     * @summary Get info
     * @param {string} [agentVersion] Agent\&#39;s version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getInfo(agentVersion?: string, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).getInfo(agentVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an user and create namespace with the same name as username
     * @summary User setup
     * @param {string} sign Signature used to validate request origin generated by running &#x60;./bin/setup&#x60; script
     * @param {SetupRequest} [setupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public setup(sign: string, setupRequest?: SetupRequest, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).setup(sign, setupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (tenant: string, createTagRequest: CreateTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createTag', 'tenant', tenant)
            // verify required parameter 'createTagRequest' is not null or undefined
            assertParamExists('createTag', 'createTagRequest', createTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tenant: string, currentName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('deleteTag', 'tenant', tenant)
            // verify required parameter 'currentName' is not null or undefined
            assertParamExists('deleteTag', 'currentName', currentName)
            const localVarPath = `/api/namespaces/{tenant}/tags/{current_name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"current_name"}}`, encodeURIComponent(String(currentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (tenant: string, filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('getTags', 'tenant', tenant)
            const localVarPath = `/api/namespaces/{tenant}/tags`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer: async (tenant: string, uid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice: async (tenant: string, uid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pullTagFromDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pullTagFromDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pullTagFromDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer: async (tenant: string, uid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToContainer', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToContainer', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToContainer', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/containers/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice: async (tenant: string, uid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('pushTagToDevice', 'tenant', tenant)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('pushTagToDevice', 'uid', uid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pushTagToDevice', 'name', name)
            const localVarPath = `/api/namespaces/{tenant}/devices/{uid}/tags/{name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tenant: string, currentName: string, updateTagRequest: UpdateTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateTag', 'tenant', tenant)
            // verify required parameter 'currentName' is not null or undefined
            assertParamExists('updateTag', 'currentName', currentName)
            // verify required parameter 'updateTagRequest' is not null or undefined
            assertParamExists('updateTag', 'updateTagRequest', updateTagRequest)
            const localVarPath = `/api/namespaces/{tenant}/tags/{current_name}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"current_name"}}`, encodeURIComponent(String(currentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(tenant: string, createTagRequest: CreateTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(tenant, createTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tenant: string, currentName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tenant, currentName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(tenant, filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromContainer(tenant: string, uid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromContainer(tenant, uid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullTagFromDevice(tenant: string, uid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullTagFromDevice(tenant, uid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToContainer(tenant: string, uid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToContainer(tenant, uid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushTagToDevice(tenant: string, uid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushTagToDevice(tenant, uid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tenant: string, currentName: string, updateTagRequest: UpdateTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tenant, currentName, updateTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
         * @summary Create a new tag in the namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {CreateTagRequest} createTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(tenant: string, createTagRequest: CreateTagRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createTag(tenant, createTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a tag and all its associations
         * @summary Delete a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Tag name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tenant: string, currentName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tenant, currentName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all tags associated with a namespace
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getTags(tenant, filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromContainer(tenant: string, uid: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.pullTagFromContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a tag from a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullTagFromDevice(tenant: string, uid: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.pullTagFromDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a container
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToContainer(tenant: string, uid: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.pushTagToContainer(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a tag with a device
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} uid Device\&#39;s UID
         * @param {string} name Tag name to associate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushTagToDevice(tenant: string, uid: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.pushTagToDevice(tenant, uid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a tag
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {string} currentName Current tag name
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tenant: string, currentName: string, updateTagRequest: UpdateTagRequest, options?: any): AxiosPromise<Tag> {
            return localVarFp.updateTag(tenant, currentName, updateTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Creates a tag that can be later associated with content. Tag names must be unique within the namespace.
     * @summary Create a new tag in the namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {CreateTagRequest} createTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(tenant: string, createTagRequest: CreateTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(tenant, createTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a tag and all its associations
     * @summary Delete a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} currentName Tag name to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tenant: string, currentName: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tenant, currentName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all tags associated with a namespace
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(tenant: string, filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(tenant, filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public pullTagFromContainer(tenant: string, uid: string, name: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).pullTagFromContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a tag from a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public pullTagFromDevice(tenant: string, uid: string, name: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).pullTagFromDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a container
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public pushTagToContainer(tenant: string, uid: string, name: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).pushTagToContainer(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a tag with a device
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} uid Device\&#39;s UID
     * @param {string} name Tag name to associate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public pushTagToDevice(tenant: string, uid: string, name: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).pushTagToDevice(tenant, uid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a tag
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {string} currentName Current tag name
     * @param {UpdateTagRequest} updateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(tenant: string, currentName: string, updateTagRequest: UpdateTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(tenant, currentName, updateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminResetUserPassword', 'id', id)
            const localVarPath = `/admin/api/users/{id}/password/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (id: string, userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin: async (userAdminRequest?: UserAdminRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/export/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/admin/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTokenAdmin', 'id', id)
            const localVarPath = `/admin/api/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filter?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord: async (tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('setSessionRecord', 'tenant', tenant)
            const localVarPath = `/api/users/security/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, updateUserDataRequest?: UpdateUserDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            const localVarPath = `/api/users/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword: async (id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminResetUserPassword(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminResetUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminResetUserPassword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(id, userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkSessionRecord(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkSessionRecord(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdmin(userAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenAdmin(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTokenAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filter, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionRecord(tenant, setSessionRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, updateUserDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(id, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
         * @summary Reset user password
         * @param {string} id The ID of the user whose password needs to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminResetUserPassword(id: string, options?: any): AxiosPromise<AdminResetUserPassword200Response> {
            return localVarFp.adminResetUserPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update user
         * @param {string} id 
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adminUpdateUser(id, userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user, returning the session\'s JWT token and data about the user.
         * @summary Auth a user
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.authUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check status from if `session record` feature is enable.
         * @summary Check session record status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkSessionRecord(options?: any): AxiosPromise<boolean> {
            return localVarFp.checkSessionRecord(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a User.
         * @summary Create a User admin
         * @param {UserAdminRequest} [userAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAdmin(userAdminRequest?: UserAdminRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserAdmin(userAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Export users to csv file.
         * @summary export users
         * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<any> {
            return localVarFp.exportUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a token from its tenant.
         * @summary Get token
         * @param {string} [tenant] Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tenant?: string, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user.
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserAuth> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user JWT token to login.
         * @summary Get user token
         * @param {string} id User\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenAdmin(id: string, options?: any): AxiosPromise<GetUserTokenAdmin200Response> {
            return localVarFp.getUserTokenAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of users.
         * @summary Get users
         * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
         * @param {number} [page] Page number
         * @param {number} [perPage] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filter?: string, page?: number, perPage?: number, options?: any): AxiosPromise<Array<UserAdminResponse>> {
            return localVarFp.getUsers(filter, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
         * @summary Login
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<UserAuth> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Define if sessions will be recorded.
         * @summary Set session record
         * @param {string} tenant Namespace\&#39;s tenant ID
         * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s data.
         * @summary Update user data
         * @param {string} id User\&#39;s ID.
         * @param {UpdateUserDataRequest} [updateUserDataRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserData(id, updateUserDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update only the user password.
         * @summary Update user password
         * @param {string} [id] User ID
         * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Resets the password for a specified user. It\'s particularly useful for users who initially authenticated via SAML and therefore may not have a password set up. This enables them to maintain access even if their original authentication method becomes unavailable (e.g., if SAML authentication is disabled).  The endpoint generates a secure 16-character random password that includes: - Uppercase letters - Lowercase letters - Numbers - Special characters  Users are strongly encouraged to change this temporary password after their first successful authentication. If the user already has a password, a `400 Bad Request` status code will be returned. 
     * @summary Reset user password
     * @param {string} id The ID of the user whose password needs to be reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public adminResetUserPassword(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminResetUserPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update user
     * @param {string} id 
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public adminUpdateUser(id: string, userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminUpdateUser(id, userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user, returning the session\'s JWT token and data about the user.
     * @summary Auth a user
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authUser(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check status from if `session record` feature is enable.
     * @summary Check session record status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkSessionRecord(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkSessionRecord(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a User.
     * @summary Create a User admin
     * @param {UserAdminRequest} [userAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserAdmin(userAdminRequest?: UserAdminRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserAdmin(userAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export users to csv file.
     * @summary export users
     * @param {string} [filter] User\&#39;s filter   Filter field receives a base64 enconded JSON object for limit a search. The JSON object should have a property called &#x60;type&#x60;, it will filter by a &#x60;property&#x60; called &#x60;namespaces&#x60; where the value should be &#x60;eq&#x60; to &#x60;0&#x60;.  An example of JSON object will looks like this:  &#x60;&#x60;&#x60;json   [     {       \&quot;type\&quot;:\&quot;property\&quot;,       \&quot;params\&quot;:         {           \&quot;name\&quot;:\&quot;namespace\&quot;,           \&quot;operator\&quot;:\&quot;eq\&quot;,           \&quot;value\&quot;:\&quot;0\&quot;         }     }   ] &#x60;&#x60;&#x60;  So, the output encoded string will result on: &#x60;W3sidHlwZSI6InByb3BlcnR5IiwicGFyYW1zIjp7Im5hbWUiOiJuYW1lc3BhY2VzIiwib3BlcmF0b3IiOiJndCIsInZhbHVlIjoiMCJ9fV0&#x3D;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public exportUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).exportUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a token from its tenant.
     * @summary Get token
     * @param {string} [tenant] Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getToken(tenant?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user.
     * @summary Get user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user JWT token to login.
     * @summary Get user token
     * @param {string} id User\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserTokenAdmin(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTokenAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of users.
     * @summary Get users
     * @param {string} [filter] Filter field receives a JSON object enconded as base64 string for limit a search.  The JSON enconded must follow these interafaces: &#x60;&#x60;&#x60;typescript interface ParamProperty {   name: string;   operator: \&quot;contains\&quot; | \&quot;eq\&quot; | \&quot;bool\&quot; | \&quot;gt\&quot; | \&quot;lt\&quot;;   value: string; }  interface ParamOperator {   name: \&quot;and\&quot; | \&quot;or\&quot;; }  interface Filter {   type: \&quot;property\&quot; | \&quot;operator\&quot;;   param: ParamOperator | ParamProperty; }  interface FilterList {   Filters: Array&lt;Filter&gt;; }  &#x60;&#x60;&#x60;  ## Examples  This is a example to filter and get only the resource what property \&quot;confirmed\&quot; is \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {   \&quot;type\&quot;: \&quot;property\&quot;,   \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;confirmed\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;       }   } ] &#x60;&#x60;&#x60;  This one, filter resource by the property \&quot;id\&quot; inside \&quot;info\&quot; structure when it is equal to \&quot;manjaro\&quot; and online property is set to \&quot;true\&quot; &#x60;&#x60;&#x60;json [   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;info.id\&quot;,       \&quot;operator\&quot;: \&quot;eq\&quot;,       \&quot;value\&quot;: \&quot;manjaro\&quot;     }   },   {     \&quot;type\&quot;: \&quot;property\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;online\&quot;,       \&quot;operator\&quot;: \&quot;bool\&quot;,       \&quot;value\&quot;: \&quot;true\&quot;     }   },   {     \&quot;type\&quot;: \&quot;operator\&quot;,     \&quot;params\&quot;: {       \&quot;name\&quot;: \&quot;and\&quot;     }   } ] &#x60;&#x60;&#x60; 
     * @param {number} [page] Page number
     * @param {number} [perPage] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(filter?: string, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(filter, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a \"local\" user by returning the session\'s JWT token and user data. Local users are those registered via the ShellHub form without relying on external Identity Providers (IdPs).  Authentication may result in an account lockout after N consecutive incorrect login attempts. The lockout applies specifically to a particular source and user combination. Check for the presence of the `X-Account-Lockout` header to determine the account lockout status. When it\'s 0, there are no active lockouts.  Users with MFA enabled cannot authenticate via this route. In such cases, the API will respond with a status `401` and an `X-MFA-Token` header with a UUID. Authentication must be med to `/api/mfa/auth` with this token in these instances. 
     * @summary Login
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Define if sessions will be recorded.
     * @summary Set session record
     * @param {string} tenant Namespace\&#39;s tenant ID
     * @param {SetSessionRecordRequest} [setSessionRecordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setSessionRecord(tenant: string, setSessionRecordRequest?: SetSessionRecordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setSessionRecord(tenant, setSessionRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s data.
     * @summary Update user data
     * @param {string} id User\&#39;s ID.
     * @param {UpdateUserDataRequest} [updateUserDataRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserData(id: string, updateUserDataRequest?: UpdateUserDataRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserData(id, updateUserDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update only the user password.
     * @summary Update user password
     * @param {string} [id] User ID
     * @param {UpdateUserPasswordRequest} [updateUserPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(id?: string, updateUserPasswordRequest?: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(id, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


